This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.eslintrc.js
.gitattributes
.gitignore
.windsurfrules
AI/Cascade.md
AI/componet simplification prompt.txt
AI/Game Architecture.md
AI/Game Core Rules.md
AI/Game Phase Implementation Plan with Gameplay Description.md
AI/service-pattern-reference.ts
babel.config.js
cypress.config.ts
Initial.html
LICENSE
package.json
public/index.html
README.md
src/App.vue
src/assets/.md
src/assets/scss/_animations.scss
src/assets/scss/_typography.scss
src/assets/scss/_variables.scss
src/assets/scss/main.scss
src/assets/styles.css
src/assets/vue-js-initial-plan.md
src/components/CardSection.vue
src/components/CompanionCard.vue
src/components/CraftingRecipeCard.vue
src/components/GameCard.vue
src/components/phases/AnimalCompanionPhase.vue
src/components/phases/ChallengeResolutionPhase.vue
src/components/phases/CraftingPhase.vue
src/components/phases/ExplorationPhase.vue
src/components/phases/JourneyProgressionPhase.vue
src/components/phases/LandscapeChallengePhase.vue
src/components/phases/PhaseFactory.vue
src/components/phases/ResourceManagementPhase.vue
src/components/phases/SeasonalAssessmentPhase.vue
src/components/phases/ThreatLevelCheckPhase.vue
src/components/ResourceCard.vue
src/composables/useGameState.ts
src/composables/useServices.ts
src/main.ts
src/models/data/characters.d.ts
src/models/data/characters.js
src/models/data/companions.d.ts
src/models/data/companions.js
src/models/data/crafted-items.d.ts
src/models/data/crafted-items.js
src/models/data/landscapes.d.ts
src/models/data/landscapes.js
src/models/data/resources.d.ts
src/models/data/resources.js
src/models/data/seasons.d.ts
src/models/data/seasons.js
src/models/enums/actions.ts
src/models/enums/cardTypes.ts
src/models/enums/phases.ts
src/models/enums/seasons.ts
src/models/types/cards.ts
src/models/types/game.ts
src/models/types/player.ts
src/router/index.ts
src/services/CardRepository.ts
src/services/challenge/ChallengeService.ts
src/services/challenge/ChallengeStrategy.ts
src/services/challenge/index.ts
src/services/challenge/strategies/MentalChallengeStrategy.ts
src/services/challenge/strategies/PhysicalChallengeStrategy.ts
src/services/challenge/strategies/SocialChallengeStrategy.ts
src/services/challenge/strategies/SpiritualChallengeStrategy.ts
src/services/challengeService.ts
src/services/companionService.ts
src/services/core/BaseService.ts
src/services/core/ServiceRegistry.ts
src/services/core/StoreRegistry.ts
src/services/craftingService.ts
src/services/diceService.ts
src/services/journeyService.ts
src/services/phaseService.ts
src/services/resourceService.ts
src/services/threatService.ts
src/services/victoryService.ts
src/shims-vue.d.ts
src/stores/cardStore.ts
src/stores/challengeStore.ts
src/stores/gameStore.ts
src/stores/gameStore.ts.backup
src/stores/index.ts
src/stores/journeyStore.ts
src/stores/logStore.ts
src/stores/playerStore.ts
src/stores/seasonStore.ts
src/types/companions.d.ts
src/types/store-extensions.d.ts
src/utils/typeMapping.ts
src/views/GameBoardView.vue
src/views/GameSetupView.vue
tests/unit/TurnSequenceSeasonalTransition.spec.ts
tsconfig.json
vitest.config.ts
vue.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AI/service-pattern-reference.ts">
/**
 * Service Pattern Reference
 * 
 * This file provides a reference implementation for standardizing
 * service classes in the PathfindersJourney codebase.
 * 
 * Key aspects of the standardization:
 * 1. Consistent class implementation with proper JSDoc comments
 * 2. Consistent singleton pattern (export const serviceName = new ServiceName())
 * 3. Direct store access within methods (using useGameStore(), etc.)
 * 4. Consistent method naming and organization
 * 5. Addition of reset() method to all services for state management
 * 6. Private properties with consistent naming (_propertyName)
 */

// Mock store type declarations for reference purposes
// In real code, you would import from the actual modules
interface GameStore {
  currentPhase: string;
  currentTurn: number;
}

interface PlayerStore {
  health: number;
  resources: string[];
}

interface CardStore {
  getAllCards(): any[];
  getCardById(id: string): any;
}

// Mock functions to represent the store imports
const useGameStore = (): GameStore => ({ currentPhase: 'EXPLORATION', currentTurn: 1 });
const usePlayerStore = (): PlayerStore => ({ health: 10, resources: [] });
const useCardStore = (): CardStore => ({ 
  getAllCards: () => [], 
  getCardById: (id: string) => ({ id, name: 'Test Card' }) 
});

/**
 * Example Service class following standardized pattern
 */
class ExampleService {
  // Private properties with consistent naming using underscore prefix
  private _stateVariable1: number = 0;
  private _stateVariable2: boolean = false;
  
  /**
   * Public method with clear purpose
   * @param param1 Description of parameter
   * @returns Description of return value
   */
  public publicMethod(param1: string): number {
    // Direct store access
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    
    // Implementation...
    return 0;
  }
  
  /**
   * Another public method
   */
  public anotherPublicMethod(): void {
    // Implementation...
  }
  
  /**
   * Private helper method with clear purpose
   * @param param1 Description of parameter
   * @returns Description of return value
   */
  private _helperMethod(param1: string): boolean {
    // Implementation...
    return true;
  }
  
  /**
   * Reset service state
   * All services should implement this method
   */
  public reset(): void {
    this._stateVariable1 = 0;
    this._stateVariable2 = false;
  }
}

// Export as singleton instance for consistent access pattern
export const exampleService = new ExampleService();
</file>

<file path="src/components/phases/AnimalCompanionPhase.vue">
<template>
  <div class="animal-companion-phase">
    <h2 class="phase-title">ANIMAL COMPANION</h2>
    
    <div v-if="playerStore.animalCompanions.length === 0">
      <AnimalCompanionSelection
        @select-companion="selectCompanion"
      />
      
      <div class="action-buttons mt-4">
        <GameCard 
          title="Skip Animal Companion" 
          cardType="ACTION"
          @click="advancePhase"
        >
          <div style="font-size: 1rem; padding: 5px;">
            Continue without a companion
          </div>
        </GameCard>
      </div>
    </div>
    
    <div v-else>
      <CompanionManagement />
      
      <div class="action-buttons mt-4">
        <GameCard 
          title="Continue Journey" 
          cardType="ACTION"
          @click="advancePhase"
        >
          <div style="font-size: 1rem; padding: 5px;">
            Proceed to the next phase
          </div>
        </GameCard>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';
import AnimalCompanionSelection from '@/components/game/AnimalCompanionSelection.vue';
import CompanionManagement from '@/components/game/CompanionManagement.vue';

const gameStore = useGameStore();
const playerStore = usePlayerStore();
const { phaseService, companionService } = useServices();

// Select a companion
const selectCompanion = (companionId: string) => {
  companionService.selectCompanion(companionId);
};

// Advance to the next phase
const advancePhase = () => {
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.animal-companion-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.action-buttons {
  margin-top: 1rem;
  display: flex;
  justify-content: center;
}

.mt-4 {
  margin-top: 1rem;
}
</style>
</file>

<file path="src/components/phases/ChallengeResolutionPhase.vue">
<template>
  <div class="challenge-resolution-phase">
    <h2 class="phase-title">CHALLENGE OUTCOME</h2>
    
    <div v-if="lastChallengeResult" class="challenge-result" :class="{ 
      'success': lastChallengeResult.success, 
      'partial-success': lastChallengeResult.partialSuccess,
      'failure': !lastChallengeResult.success && !lastChallengeResult.partialSuccess
    }">
      <h3>{{ lastChallengeResult.success ? 'Success!' : lastChallengeResult.partialSuccess ? 'Partial Success' : 'Failure' }}</h3>
    </div>
    
    <GameCard 
      title="Continue to Next Phase" 
      cardType="ACTION"
      @click="advancePhase"
    >
      <div style="font-size: 1rem; padding: 5px;">
        Proceed with your journey
      </div>
    </GameCard>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';

const gameStore = useGameStore();
const { phaseService, challengeService } = useServices();

// Get the last challenge result from the challenge service
const lastChallengeResult = computed(() => {
  return challengeService.getLastChallengeResult();
});

// Advance to the next phase
const advancePhase = () => {
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.challenge-resolution-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.challenge-result {
  margin: 1rem 0;
  padding: 1rem;
  width: 100%;
  text-align: center;
  border-radius: 0.5rem;
  
  &.success {
    background-color: rgba(0, 128, 0, 0.2);
  }
  
  &.partial-success {
    background-color: rgba(255, 165, 0, 0.2);
  }
  
  &.failure {
    background-color: rgba(255, 0, 0, 0.2);
  }
}
</style>
</file>

<file path="src/components/phases/CraftingPhase.vue">
<template>
  <div class="crafting-phase">
    <h2 class="phase-title">CRAFTING</h2>
    <div class="phase-description">
      <p>Craft items using your gathered resources.</p>
    </div>
    
    <!-- Reusing existing CraftingStation component -->
    <CraftingStation />
    
    <GameCard 
      title="Continue Journey" 
      cardType="ACTION"
      @click="advancePhase"
    >
      <div style="font-size: 1.1rem; padding: 10px;">
        Proceed to the next phase
      </div>
    </GameCard>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/gameStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';
import CraftingStation from '@/components/game/CraftingStation.vue';

const gameStore = useGameStore();
const { phaseService } = useServices();

// Advance to the next phase
const advancePhase = () => {
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.crafting-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
}
</style>
</file>

<file path="src/components/phases/ExplorationPhase.vue">
<template>
  <div class="exploration-phase">
    <h2 class="phase-title">EXPLORATION</h2>
    <div class="phase-description">
      <p v-if="currentLandscape">You are exploring {{ currentLandscape.name }}. What will you discover?</p>
      <p v-else>Choose a landscape to explore.</p>
    </div>
    
    <GameCard 
      title="Continue to Next Phase" 
      cardType="ACTION"
      @click="advancePhase"
    >
      <div style="font-size: 1.1rem; padding: 10px;">
        Proceed with your exploration
      </div>
    </GameCard>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { useLogStore } from '@/stores/logStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';

const gameStore = useGameStore();
const logStore = useLogStore();
const { phaseService, cardRepository } = useServices();

// Get the current landscape
const currentLandscape = computed(() => {
  if (!gameStore.currentLandscapeId) return null;
  return cardRepository.getLandscapeById(gameStore.currentLandscapeId);
});

// Advance to the next phase
const advancePhase = () => {
  if (currentLandscape.value) {
    logStore.addToGameLog(`You have completed your exploration of ${currentLandscape.value.name}.`, true, 'phase');
  }
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.exploration-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
}
</style>
</file>

<file path="src/components/phases/JourneyProgressionPhase.vue">
<template>
  <div class="journey-progression-phase">
    <h2 class="phase-title">JOURNEY PROGRESSION</h2>
    <div class="phase-description">
      <p>You are ready to journey to the next landscape.</p>
      
      <div v-if="nextLandscape" class="next-landscape">
        <GameCard 
          :title="nextLandscape.name" 
          subtitle="Next Landscape"
          :cardType="CardType.LANDSCAPE"
          @click="startNewTurn"
        >
          <p>{{ nextLandscape.description }}</p>
          <div class="action-text">
            Click to journey to this location
          </div>
        </GameCard>
      </div>
      
      <div v-else>
        <GameCard 
          title="Continue Journey" 
          cardType="ACTION"
          @click="advancePhase"
        >
          <div style="font-size: 1.1rem; padding: 10px;">
            Begin the next turn of your adventure
          </div>
        </GameCard>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';
import { CardType } from '@/models/enums/cardTypes';

const gameStore = useGameStore();
const { phaseService, journeyService, cardRepository } = useServices();

// Get the next landscape
const nextLandscape = computed(() => {
  const nextId = journeyService.getNextLandscapeId();
  return nextId ? cardRepository.getLandscapeById(nextId) : null;
});

// Start new turn by moving to the next landscape
const startNewTurn = () => {
  journeyService.startNewTurn();
  phaseService.setPhase(phaseService.getCurrentPhase());
};

// Advance to the next phase
const advancePhase = () => {
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.journey-progression-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
  width: 100%;
}

.next-landscape {
  margin-top: 1rem;
  width: 100%;
}

.action-text {
  font-weight: bold;
  margin-top: 10px;
  text-align: center;
  color: #5a3e2b;
}
</style>
</file>

<file path="src/components/phases/LandscapeChallengePhase.vue">
<template>
  <div class="landscape-challenge-phase">
    <h2 class="phase-title">LANDSCAPE CHALLENGE</h2>
    <div class="phase-description">
      <p>Will you face the challenges of this landscape?</p>
    </div>
    
    <div class="challenge-actions">
      <GameCard 
        title="Roll D8 and Resolve Challenge" 
        cardType="ACTION"
        @click="resolveChallenge"
      >
        <div style="font-size: 1rem; padding: 5px;">
          Test your skills against the challenge
        </div>
      </GameCard>
      
      <GameCard 
        title="Avoid Challenge" 
        cardType="ACTION"
        @click="avoidChallenge"
      >
        <div style="font-size: 1rem; padding: 5px;">
          Cost: 2 Resources
        </div>
      </GameCard>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';

const gameStore = useGameStore();
const playerStore = usePlayerStore();
const { phaseService, challengeService } = useServices();

// Resolve landscape challenge
const resolveChallenge = () => {
  challengeService.resolveChallengeLandscape();
  phaseService.advancePhase();
};

// Avoid landscape challenge by spending resources
const avoidChallenge = () => {
  challengeService.avoidChallengeLandscape();
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.landscape-challenge-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
}

.challenge-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}
</style>
</file>

<file path="src/components/phases/PhaseFactory.vue">
<template>
  <div class="phase-content" :class="`phase-${formatPhaseClass(currentPhase)}`">
    <component :is="currentPhaseComponent" />
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { GamePhase } from '@/models/enums/phases';

// Import all phase components
import SeasonalAssessmentPhase from './SeasonalAssessmentPhase.vue';
import ThreatLevelCheckPhase from './ThreatLevelCheckPhase.vue';
import LandscapeChallengePhase from './LandscapeChallengePhase.vue';
import ChallengeResolutionPhase from './ChallengeResolutionPhase.vue';
import ResourceManagementPhase from './ResourceManagementPhase.vue';
import AnimalCompanionPhase from './AnimalCompanionPhase.vue';
import CraftingPhase from './CraftingPhase.vue';
import JourneyProgressionPhase from './JourneyProgressionPhase.vue';
import ExplorationPhase from './ExplorationPhase.vue';

// Get current game phase from store
const gameStore = useGameStore();
const currentPhase = computed(() => gameStore.currentPhase);

// Map phases to components
const phaseComponentMap = {
  [GamePhase.SEASONAL_ASSESSMENT]: SeasonalAssessmentPhase,
  [GamePhase.THREAT_LEVEL_CHECK]: ThreatLevelCheckPhase,
  [GamePhase.LANDSCAPE_CHALLENGE]: LandscapeChallengePhase,
  [GamePhase.CHALLENGE_RESOLUTION]: ChallengeResolutionPhase,
  [GamePhase.RESOURCE_MANAGEMENT]: ResourceManagementPhase,
  [GamePhase.ANIMAL_COMPANION]: AnimalCompanionPhase,
  [GamePhase.CRAFTING]: CraftingPhase,
  [GamePhase.JOURNEY_PROGRESSION]: JourneyProgressionPhase,
  [GamePhase.EXPLORATION]: ExplorationPhase,
};

// Get the component for the current phase
const currentPhaseComponent = computed(() => {
  return phaseComponentMap[currentPhase.value] || null;
});

// Helper function to format phase for CSS class
const formatPhaseClass = (phase: GamePhase): string => {
  return phase.toLowerCase().replace(/_/g, '-');
};
</script>

<style lang="scss" scoped>
.phase-content {
  position: relative;
  border: 2px solid lightblue;
  padding: 1rem;
  margin-top: 1rem;
  background-color: rgba(240, 230, 210, 0.3);
  border-radius: 8px;
  border: 1px solid #8c7851;
}
</style>
</file>

<file path="src/components/phases/ResourceManagementPhase.vue">
<template>
  <div class="resource-management-phase">
    <h2 class="phase-title">RESOURCE MANAGEMENT</h2>
    <div class="phase-description">
      <p>Manage your resources and gather new ones.</p>
    </div>
    
    <!-- Reusing existing ResourceManagement component -->
    <ResourceManagement />
    
    <GameCard 
      title="Continue Journey" 
      cardType="ACTION"
      @click="advancePhase"
    >
      <div style="font-size: 1.1rem; padding: 10px;">
        Proceed to the next phase
      </div>
    </GameCard>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/gameStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';
import ResourceManagement from '@/components/game/ResourceManagement.vue';

const gameStore = useGameStore();
const { phaseService, resourceService } = useServices();

// Advance to the next phase
const advancePhase = () => {
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.resource-management-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
}
</style>
</file>

<file path="src/components/phases/SeasonalAssessmentPhase.vue">
<template>
  <div class="seasonal-assessment-phase">
    <h2 class="phase-title">SEASONAL ASSESSMENT</h2>
    <div class="phase-description">
      <p>The current season is {{ formatSeason(gameStore.currentSeason) }}.</p>
      <p>The seasons affect which resources are available and the effectiveness of your animal companions.</p>
    </div>
    <GameCard 
      title="Continue Journey" 
      cardType="ACTION"
      @click="advancePhase"
    >
      <div style="font-size: 1.1rem; padding: 10px;">
        Proceed to the next phase of your adventure
      </div>
    </GameCard>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/gameStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';
import { Season } from '@/models/enums/seasons';

const gameStore = useGameStore();
const { phaseService } = useServices();

// Format season for display
const formatSeason = (season: Season): string => {
  return season.split('_').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
  ).join(' ');
};

// Advance to the next phase
const advancePhase = () => {
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.seasonal-assessment-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
}
</style>
</file>

<file path="src/components/phases/ThreatLevelCheckPhase.vue">
<template>
  <div class="threat-level-check-phase">
    <h2 class="phase-title">THREAT LEVEL CHECK</h2>
    <div class="phase-description">
      <p>Your current threat level: {{ gameStore.threatTokens }}</p>
    </div>
    <GameCard 
      title="Remain Vigilant" 
      cardType="ACTION"
      @click="advancePhase"
    >
      <div style="font-size: 1.1rem; padding: 10px;">
        Stay alert and advance to the next phase
      </div>
    </GameCard>
  </div>
</template>

<script setup lang="ts">
import { useGameStore } from '@/stores/gameStore';
import { useServices } from '@/composables/useServices';
import GameCard from '@/components/GameCard.vue';

const gameStore = useGameStore();
const { phaseService, threatService } = useServices();

// Handle threat check
const handleThreatCheck = () => {
  // This would call logic in the threatService
  threatService.checkThreatLevel();
};

// Advance to the next phase
const advancePhase = () => {
  // Perform threat check
  handleThreatCheck();
  // Advance to next phase
  phaseService.advancePhase();
};
</script>

<style lang="scss" scoped>
.threat-level-check-phase {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.phase-title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #5a3e2b;
}

.phase-description {
  text-align: center;
  margin-bottom: 1.5rem;
}
</style>
</file>

<file path="src/composables/useServices.ts">
/**
 * useServices
 * 
 * Composable function to access services throughout the application.
 * Provides a consistent interface to interact with game services.
 */
import { ServiceRegistry } from '@/services/core/ServiceRegistry';

export function useServices() {
  const serviceRegistry = ServiceRegistry.getInstance();
  
  return {
    // Return all services through the registry
    challengeService: serviceRegistry.challengeService,
    diceService: serviceRegistry.diceService,
    companionService: serviceRegistry.companionService,
    journeyService: serviceRegistry.journeyService,
    resourceService: serviceRegistry.resourceService,
    craftingService: serviceRegistry.craftingService,
    threatService: serviceRegistry.threatService,
    victoryService: serviceRegistry.victoryService,
    phaseService: serviceRegistry.phaseService,
    cardRepository: serviceRegistry.cardRepository
  };
}
</file>

<file path="src/services/challenge/ChallengeService.ts">
/**
 * Challenge Service
 * Centralized service for all challenge resolution logic using strategy pattern
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { useChallenge } from '@/stores/challengeStore';
import { useLogStore } from '@/stores/logStore';
import { diceService } from '@/services/diceService';
import { ChallengeOutcome, Challenge } from '@/models/types/game';
import { ChallengeType } from '@/models/enums/cardTypes';
import { ChallengeStrategy } from './ChallengeStrategy';
import { PhysicalChallengeStrategy } from './strategies/PhysicalChallengeStrategy';
import { MentalChallengeStrategy } from './strategies/MentalChallengeStrategy';
import { SpiritualChallengeStrategy } from './strategies/SpiritualChallengeStrategy';
import { SocialChallengeStrategy } from './strategies/SocialChallengeStrategy';

/**
 * Centralized service for handling all challenge-related operations
 */
class ChallengeService {
  // Private properties with consistent naming
  private _lastChallengeId: string | null = null;
  private _lastChallengeOutcome: ChallengeOutcome | null = null;
  private _strategies: Record<string, ChallengeStrategy>;
  
  /**
   * Initialize challenge service with strategies for different challenge types
   */
  constructor() {
    // Initialize strategies for different challenge types
    // Map physical, mental, spiritual, social strategies to appropriate challenge types
    this._strategies = {
      [ChallengeType.STRENGTH]: new PhysicalChallengeStrategy(),
      [ChallengeType.WISDOM]: new MentalChallengeStrategy(),
      [ChallengeType.SURVIVAL]: new SpiritualChallengeStrategy(),
      [ChallengeType.DIPLOMACY]: new SocialChallengeStrategy(),
      [ChallengeType.AGILITY]: new PhysicalChallengeStrategy() // Fallback to physical for agility
    };
  }
  
  /**
   * Calculate challenge difficulty based on challenge type and other factors
   * @param challenge The challenge to calculate difficulty for
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number {
    // Delegate to appropriate strategy based on challenge type
    return this._getStrategyForChallenge(challenge).calculateDifficulty(challenge);
  }
  
  /**
   * Calculate player's bonus for a challenge based on its type
   * @param challenge The challenge to calculate bonus for
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number {
    // Delegate to appropriate strategy based on challenge type
    return this._getStrategyForChallenge(challenge).calculatePlayerBonus(challenge);
  }
  
  /**
   * Determine challenge outcome using unified formula
   * @param challenge The challenge to resolve
   * @returns The challenge outcome
   */
  resolveChallenge(challenge: Challenge): ChallengeOutcome {
    const difficulty = this.calculateDifficulty(challenge);
    const playerBonus = this.calculatePlayerBonus(challenge);
    
    const diceRoll = diceService.rollD8();
    const total = diceRoll + playerBonus;
    
    // Record the challenge attempt
    this._recordChallengeAttempt({
      challengeType: challenge.type,
      difficulty,
      diceRoll,
      playerBonus,
      total
    });
    
    // Determine outcome based on unified formula
    let success: boolean | 'partial' = false;
    let exceptional = false;
    
    // Natural 8 always succeeds
    if (diceRoll === 8) {
      success = true;
      exceptional = true;
    }
    // Success: total >= difficulty
    else if (total >= difficulty) {
      success = true;
      exceptional = total >= difficulty + 2;
    }
    // Partial success: total = difficulty - 1
    else if (total === difficulty - 1) {
      success = 'partial';
      exceptional = false;
    }
    // Failure
    else {
      success = false;
      exceptional = total <= difficulty - 3;
    }
    
    // Create outcome object
    const outcome: ChallengeOutcome = {
      success,
      exceptional,
      roll: diceRoll,
      total,
      difficulty
    };
    
    // Store the outcome
    this._lastChallengeOutcome = outcome;
    
    return outcome;
  }
  
  /**
   * Apply challenge outcomes using appropriate strategy
   * @param outcome The challenge outcome
   * @param challenge The challenge that was attempted
   */
  applyOutcome(outcome: ChallengeOutcome, challenge: Challenge): void {
    // Common outcome handling
    const logStore = useLogStore();
    const challengeStore = useChallenge();
    
    // Log the outcome
    const outcomeText = outcome.success === true 
      ? 'Success' 
      : outcome.success === 'partial' 
        ? 'Partial Success' 
        : 'Failure';
    
    logStore.addToGameLog(`Challenge ${outcomeText}: ${challenge.name} (Roll: ${outcome.roll}, Total: ${outcome.total}, Difficulty: ${outcome.difficulty})`, false);
    
    // Delegate to strategy for type-specific effects
    this._getStrategyForChallenge(challenge).applyOutcomeEffects(outcome, challenge);
    
    // Additional common handling based on outcome type
    if (outcome.success === true && outcome.exceptional) {
      // All exceptional successes get a blessing token
      challengeStore.blessingTokens++;
    } else if (outcome.success === false && outcome.exceptional) {
      // All exceptional failures add a threat token
      challengeStore.addThreatTokens(1);
    }
  }
  
  /**
   * Handle a landscape challenge
   * Complete process from challenge resolution to outcome application
   */
  resolveLandscapeChallenge(): void {
    const gameStore = useGameStore();
    const cardStore = useCardStore();
    const challengeStore = useChallenge();
    const logStore = useLogStore();
    
    // Get the current landscape and its challenge
    const landscape = cardStore.getLandscapeById(gameStore.currentLandscapeId);
    
    if (!landscape || !landscape.challenge) {
      logStore.addToGameLog('No landscape challenge found', true);
      return;
    }
    
    // Need to handle the fact that landscape.challenge might be a string ID or an actual Challenge object
    const challengeObj = typeof landscape.challenge === 'string' 
      ? { type: ChallengeType.STRENGTH, difficulty: 5, name: landscape.challenge } as Challenge 
      : landscape.challenge as Challenge;
      
    const outcome = this.resolveChallenge(challengeObj);
    
    // Apply the outcome
    this.applyOutcome(outcome, challengeObj);
    
    // Progress the game state based on the outcome
    if (outcome.success === true) {
      // Full success - advance journey track
      gameStore.currentTurn++; // Simple way to progress the game
    } else if (outcome.success === 'partial') {
      // Partial success - may have some benefit but no journey advancement
    } else {
      // Failure - add threat
      challengeStore.addThreatTokens(1);
    }
  }
  
  /**
   * Allow player to avoid a landscape challenge by spending resources
   */
  avoidLandscapeChallenge(): void {
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    const logStore = useLogStore();
    
    // Check if player has enough resources
    const requiredResources = 2;
    const resourceCount = playerStore.resourceCount;
    
    if (resourceCount >= requiredResources) {
      // Spend resources to avoid challenge
      // In a real implementation, we would select specific resources to spend
      for (let i = 0; i < requiredResources; i++) {
        if (playerStore.resources.length > 0) {
          const resourceToSpend = playerStore.resources[0];
          playerStore.removeResource(resourceToSpend);
        }
      }
      
      logStore.addToGameLog(`You spent ${requiredResources} resources to avoid the challenge.`, false);
      // Continue journey without challenge penalties
      gameStore.currentTurn++;
    } else {
      logStore.addToGameLog(`You don't have enough resources to avoid the challenge. You need at least ${requiredResources}.`, true);
    }
  }
  
  /**
   * Get the last challenge outcome
   * @returns The last challenge outcome or null if no challenge has been resolved
   */
  getLastOutcome(): ChallengeOutcome | null {
    return this._lastChallengeOutcome;
  }
  
  /**
   * Reset the service state
   */
  reset(): void {
    this._lastChallengeId = null;
    this._lastChallengeOutcome = null;
  }
  
  /**
   * Get the appropriate strategy for a challenge type
   * @param challenge The challenge to get strategy for
   * @returns The challenge strategy
   */
  private _getStrategyForChallenge(challenge: Challenge): ChallengeStrategy {
    return this._strategies[challenge.type] || this._strategies[ChallengeType.STRENGTH];
  }
  
  /**
   * Record details of a challenge attempt for historical reference
   * @param attempt The challenge attempt details
   */
  private _recordChallengeAttempt(attempt: {
    challengeType: string;
    difficulty: number;
    diceRoll: number;
    playerBonus: number;
    total: number;
  }): void {
    const challengeStore = useChallenge();
    
    challengeStore.addChallengeHistory(attempt.challengeType, 
      `Roll: ${attempt.diceRoll}, Player Bonus: ${attempt.playerBonus}, Total: ${attempt.total}, Difficulty: ${attempt.difficulty}`
    );
    
    this._lastChallengeOutcome = {
      roll: attempt.diceRoll,
      total: attempt.total,
      difficulty: attempt.difficulty,
      success: attempt.total >= attempt.difficulty,
      exceptional: (attempt.total >= attempt.difficulty + 2) || (attempt.diceRoll === 8)
    };
  }
}

// Export as a singleton instance for consistent access pattern
export const challengeService = new ChallengeService();
</file>

<file path="src/services/challenge/ChallengeStrategy.ts">
/**
 * Challenge Strategy Interface
 * Defines strategy pattern for handling different challenge types
 */
import { Challenge, ChallengeOutcome } from '@/models/types/game';

/**
 * Interface for challenge resolution strategies
 */
export interface ChallengeStrategy {
  /**
   * Calculate difficulty of a specific challenge type
   * @param challenge The challenge to calculate difficulty for
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number;
  
  /**
   * Calculate player's bonus for a specific challenge type
   * @param challenge The challenge to calculate bonus for
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number;
  
  /**
   * Apply specific effects for this challenge type
   * @param outcome The challenge outcome
   * @param challenge The challenge that was attempted
   */
  applyOutcomeEffects(outcome: ChallengeOutcome, challenge: Challenge): void;
}
</file>

<file path="src/services/challenge/index.ts">
/**
 * Challenge Service Index
 * Exports all challenge-related services and types
 */

// Export the main challenge service
export { challengeService } from './ChallengeService';

// Export the strategy interface for extensions
export { ChallengeStrategy } from './ChallengeStrategy';

// Export individual strategies for direct access if needed
export { PhysicalChallengeStrategy } from './strategies/PhysicalChallengeStrategy';
export { MentalChallengeStrategy } from './strategies/MentalChallengeStrategy';
export { SpiritualChallengeStrategy } from './strategies/SpiritualChallengeStrategy';
export { SocialChallengeStrategy } from './strategies/SocialChallengeStrategy';
</file>

<file path="src/services/challenge/strategies/MentalChallengeStrategy.ts">
/**
 * Mental Challenge Strategy
 * Implements strategy for mental challenges
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { useChallenge } from '@/stores/challengeStore';
import { useSeasonStore } from '@/stores/seasonStore';
import { useLogStore } from '@/stores/logStore';
import { Challenge, ChallengeOutcome } from '@/models/types/game';
import { ChallengeType } from '@/models/enums/cardTypes';
import { ChallengeStrategy } from '../ChallengeStrategy';
import { Season } from '@/models/enums/seasons';

/**
 * Strategy for handling mental challenges
 */
export class MentalChallengeStrategy implements ChallengeStrategy {
  /**
   * Calculate difficulty of a mental challenge
   * @param challenge The mental challenge
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number {
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    const baseDifficulty = challenge.difficulty;
    
    // Get seasonal modifiers for mental challenges
    let seasonalModifier = 0;
    
    // Different seasons have different effects on mental challenges
    switch (seasonStore.currentSeason) {
      case Season.IMBOLC:
        // Imbolc - time of inspiration - mental challenges easier
        seasonalModifier = -1;
        break;
      case Season.SAMHAIN:
        // Thin veil between worlds makes mental challenges more difficult
        seasonalModifier = 1;
        break;
      // Other seasons have no specific effect on mental challenges
    }
    
    // Apply threat level modifier
    const threatModifier = challengeStore.threatLevel;
    
    return baseDifficulty + seasonalModifier + threatModifier;
  }
  
  /**
   * Calculate player's bonus for a mental challenge
   * @param challenge The mental challenge
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number {
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    
    // Character ability bonus
    const character = cardStore.getCharacterById(playerStore.characterId);
    let bonus = (character?.challengeBonuses?.mental || 0);
    
    // Item bonuses - only count items that provide mental challenge bonuses
    for (const itemId of playerStore.craftedItems) {
      const item = cardStore.getCraftedItemById(itemId);
      if (item?.challengeBonuses?.mental) {
        bonus += item.challengeBonuses.mental;
      }
    }
    
    // Companion bonuses - only count companions that help with mental challenges
    for (const companionId of playerStore.animalCompanions) {
      const companion = cardStore.getCompanionById(companionId);
      if (companion?.challengeBonuses?.mental) {
        bonus += companion.challengeBonuses.mental;
        
        // Apply seasonal companion bonuses if applicable
        if (companion.seasonalBonuses?.[seasonStore.currentSeason]?.mental) {
          bonus += companion.seasonalBonuses[seasonStore.currentSeason].mental;
        }
      }
    }
    
    // Blessing tokens
    bonus += challengeStore.blessingTokens;
    
    return bonus;
  }
  
  /**
   * Apply specific effects for mental challenges
   * @param outcome The challenge outcome
   * @param challenge The mental challenge that was attempted
   */
  applyOutcomeEffects(outcome: ChallengeOutcome, challenge: Challenge): void {
    const logStore = useLogStore();
    const playerStore = usePlayerStore();
    
    // Common outcome handling
    if (outcome.success === true) {
      // Handle mental success - may gain insight
      if (challenge.resourceReward) {
        // Mental challenges yield insight which can be used to gain experience
        playerStore.addExperience(1);
        logStore.addToGameLog('Your keen insight has led to greater understanding. You gain 1 experience point.');
      }
      
      if (outcome.exceptional) {
        // Exceptional mental success - might reveal hidden information
        logStore.addToGameLog('Your exceptional mental prowess has revealed a deeper understanding!');
        playerStore.addExperience(1);
      }
    } else if (outcome.success === 'partial') {
      // Partial success - might gain a little insight
      if (challenge.resourceReward) {
        // Some small benefit
        logStore.addToGameLog('You gain a partial understanding from this challenge.');
      }
    } else {
      // Failure
      if (outcome.exceptional) {
        // Exceptional mental failure might cause temporary mental fatigue
        logStore.addToGameLog('Your exceptional failure leaves your mind clouded and confused.');
      }
    }
  }
}
</file>

<file path="src/services/challenge/strategies/PhysicalChallengeStrategy.ts">
/**
 * Physical Challenge Strategy
 * Implements strategy for physical challenges
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { useChallenge } from '@/stores/challengeStore';
import { useSeasonStore } from '@/stores/seasonStore';
import { useLogStore } from '@/stores/logStore';
import { Challenge, ChallengeOutcome } from '@/models/types/game';
import { ChallengeType } from '@/models/enums/cardTypes';
import { ChallengeStrategy } from '../ChallengeStrategy';
import { Season } from '@/models/enums/seasons';

/**
 * Strategy for handling physical challenges
 */
export class PhysicalChallengeStrategy implements ChallengeStrategy {
  /**
   * Calculate difficulty of a physical challenge
   * @param challenge The physical challenge
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number {
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    const baseDifficulty = challenge.difficulty;
    
    // Get seasonal modifiers for physical challenges
    let seasonalModifier = 0;
    
    // Different seasons have different effects on physical challenges
    switch (seasonStore.currentSeason) {
      case Season.WINTERS_DEPTH:
        // Winter makes physical challenges harder
        seasonalModifier = 1;
        break;
      case Season.LUGHNASADH:
        // Harvest season - physical challenges easier
        seasonalModifier = -1;
        break;
      // Other seasons have no specific effect on physical challenges
    }
    
    // Apply threat level modifier
    const threatModifier = challengeStore.threatLevel;
    
    return baseDifficulty + seasonalModifier + threatModifier;
  }
  
  /**
   * Calculate player's bonus for a physical challenge
   * @param challenge The physical challenge
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number {
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    
    // Character ability bonus
    const character = cardStore.getCharacterById(playerStore.characterId);
    let bonus = (character?.challengeBonuses?.physical || 0);
    
    // Item bonuses - only count items that provide physical challenge bonuses
    for (const itemId of playerStore.craftedItems) {
      const item = cardStore.getCraftedItemById(itemId);
      if (item?.challengeBonuses?.physical) {
        bonus += item.challengeBonuses.physical;
      }
    }
    
    // Companion bonuses - only count companions that help with physical challenges
    for (const companionId of playerStore.animalCompanions) {
      const companion = cardStore.getCompanionById(companionId);
      if (companion?.challengeBonuses?.physical) {
        bonus += companion.challengeBonuses.physical;
        
        // Apply seasonal companion bonuses if applicable
        if (companion.seasonalBonuses?.[seasonStore.currentSeason]?.physical) {
          bonus += companion.seasonalBonuses[seasonStore.currentSeason].physical;
        }
      }
    }
    
    // Blessing tokens
    bonus += challengeStore.blessingTokens;
    
    return bonus;
  }
  
  /**
   * Apply specific effects for physical challenges
   * @param outcome The challenge outcome
   * @param challenge The physical challenge that was attempted
   */
  applyOutcomeEffects(outcome: ChallengeOutcome, challenge: Challenge): void {
    const logStore = useLogStore();
    const playerStore = usePlayerStore();
    const challengeStore = useChallenge();
    
    // Common outcome handling
    if (outcome.success === true) {
      // Handle physical success - may have specific physical rewards
      if (challenge.resourceReward) {
        // Physical challenges might yield more raw materials
        this._collectPhysicalResources(2);
      }
      
      if (outcome.exceptional) {
        // Exceptional physical success - gain a strength token
        logStore.addToGameLog('You gained 1 strength token from your exceptional physical prowess!');
      }
    } else if (outcome.success === 'partial') {
      // Partial success
      if (challenge.resourceReward) {
        this._collectPhysicalResources(1);
      }
    } else {
      // Failure handling
      if (outcome.exceptional) {
        // Exceptional physical failure might cause injury
        logStore.addToGameLog('Your exceptional failure has left you weakened.');
      }
    }
  }
  
  /**
   * Collect resources from physical challenge
   * @param count Number of resources to collect
   */
  private _collectPhysicalResources(count: number): void {
    const playerStore = usePlayerStore();
    const logStore = useLogStore();
    
    // Physical challenges might yield specific types of resources
    for (let i = 0; i < Math.ceil(count / 2); i++) {
      playerStore.addResource('wood');
    }
    
    for (let i = 0; i < Math.floor(count / 2); i++) {
      playerStore.addResource('stone');
    }
    
    logStore.addToGameLog(`Collected ${count} physical resources (wood and stone).`);
  }
}
</file>

<file path="src/services/challenge/strategies/SocialChallengeStrategy.ts">
/**
 * Social Challenge Strategy
 * Implements strategy for social challenges
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { useChallenge } from '@/stores/challengeStore';
import { useSeasonStore } from '@/stores/seasonStore';
import { useLogStore } from '@/stores/logStore';
import { Challenge, ChallengeOutcome } from '@/models/types/game';
import { ChallengeType } from '@/models/enums/cardTypes';
import { ChallengeStrategy } from '../ChallengeStrategy';
import { Season } from '@/models/enums/seasons';

/**
 * Strategy for handling social challenges
 */
export class SocialChallengeStrategy implements ChallengeStrategy {
  /**
   * Calculate difficulty of a social challenge
   * @param challenge The social challenge
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number {
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    const baseDifficulty = challenge.difficulty;
    
    // Get seasonal modifiers for social challenges
    let seasonalModifier = 0;
    
    // Different seasons have different effects on social challenges
    switch (seasonStore.currentSeason) {
      case Season.BELTANE:
        // Beltane - time of community and celebration - social challenges easier
        seasonalModifier = -1;
        break;
      case Season.WINTERS_DEPTH:
        // Winter - isolation makes social challenges harder
        seasonalModifier = 1;
        break;
      // Other seasons have no specific effect on social challenges
    }
    
    // Apply threat level modifier
    const threatModifier = challengeStore.threatLevel;
    
    return baseDifficulty + seasonalModifier + threatModifier;
  }
  
  /**
   * Calculate player's bonus for a social challenge
   * @param challenge The social challenge
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number {
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    
    // Character ability bonus
    const character = cardStore.getCharacterById(playerStore.characterId);
    let bonus = (character?.challengeBonuses?.social || 0);
    
    // Item bonuses - only count items that provide social challenge bonuses
    for (const itemId of playerStore.craftedItems) {
      const item = cardStore.getCraftedItemById(itemId);
      if (item?.challengeBonuses?.social) {
        bonus += item.challengeBonuses.social;
      }
    }
    
    // Companion bonuses - only count companions that help with social challenges
    for (const companionId of playerStore.animalCompanions) {
      const companion = cardStore.getCompanionById(companionId);
      if (companion?.challengeBonuses?.social) {
        bonus += companion.challengeBonuses.social;
        
        // Apply seasonal companion bonuses if applicable
        if (companion.seasonalBonuses?.[seasonStore.currentSeason]?.social) {
          bonus += companion.seasonalBonuses[seasonStore.currentSeason].social;
        }
      }
    }
    
    // Blessing tokens
    bonus += challengeStore.blessingTokens;
    
    return bonus;
  }
  
  /**
   * Apply specific effects for social challenges
   * @param outcome The challenge outcome
   * @param challenge The social challenge that was attempted
   */
  applyOutcomeEffects(outcome: ChallengeOutcome, challenge: Challenge): void {
    const logStore = useLogStore();
    const playerStore = usePlayerStore();
    
    // Common outcome handling
    if (outcome.success === true) {
      // Handle social success - may lead to allies or community support
      if (challenge.resourceReward) {
        // Social challenges might yield community resources or allies
        this._collectSocialResources(2);
      }
      
      if (outcome.exceptional) {
        // Exceptional social success - might gain a special ally or information
        logStore.addToGameLog('Your exceptional social skills have earned you a valuable friendship!');
      }
    } else if (outcome.success === 'partial') {
      // Partial success
      if (challenge.resourceReward) {
        this._collectSocialResources(1);
      }
    } else {
      // Failure
      if (outcome.exceptional) {
        // Exceptional social failure might damage reputation
        logStore.addToGameLog('Your exceptional failure has damaged your standing with the local community.');
      }
    }
  }
  
  /**
   * Collect resources from social challenge
   * @param count Number of resources to collect
   */
  private _collectSocialResources(count: number): void {
    const playerStore = usePlayerStore();
    const logStore = useLogStore();
    
    // Social challenges might yield favors or special items from locals
    for (let i = 0; i < count; i++) {
      playerStore.addResource('herbs');
    }
    
    logStore.addToGameLog(`Your social connections helped you gather ${count} herbs from locals.`);
  }
}
</file>

<file path="src/services/challenge/strategies/SpiritualChallengeStrategy.ts">
/**
 * Spiritual Challenge Strategy
 * Implements strategy for spiritual challenges
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { useChallenge } from '@/stores/challengeStore';
import { useSeasonStore } from '@/stores/seasonStore';
import { useLogStore } from '@/stores/logStore';
import { Challenge, ChallengeOutcome } from '@/models/types/game';
import { ChallengeType } from '@/models/enums/cardTypes';
import { ChallengeStrategy } from '../ChallengeStrategy';
import { Season } from '@/models/enums/seasons';

/**
 * Strategy for handling spiritual challenges
 */
export class SpiritualChallengeStrategy implements ChallengeStrategy {
  /**
   * Calculate difficulty of a spiritual challenge
   * @param challenge The spiritual challenge
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number {
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    const baseDifficulty = challenge.difficulty;
    
    // Get seasonal modifiers for spiritual challenges
    let seasonalModifier = 0;
    
    // Different seasons have different effects on spiritual challenges
    switch (seasonStore.currentSeason) {
      case Season.SAMHAIN:
        // Samhain - veil between worlds is thin - spiritual challenges easier
        seasonalModifier = -1;
        break;
      case Season.BELTANE:
        // Beltane - time of life and growth, not introspection - spiritual challenges harder
        seasonalModifier = 1;
        break;
      // Other seasons have no specific effect on spiritual challenges
    }
    
    // Apply threat level modifier
    const threatModifier = challengeStore.threatLevel;
    
    return baseDifficulty + seasonalModifier + threatModifier;
  }
  
  /**
   * Calculate player's bonus for a spiritual challenge
   * @param challenge The spiritual challenge
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number {
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    const seasonStore = useSeasonStore();
    const challengeStore = useChallenge();
    
    // Character ability bonus
    const character = cardStore.getCharacterById(playerStore.characterId);
    let bonus = (character?.challengeBonuses?.spiritual || 0);
    
    // Item bonuses - only count items that provide spiritual challenge bonuses
    for (const itemId of playerStore.craftedItems) {
      const item = cardStore.getCraftedItemById(itemId);
      if (item?.challengeBonuses?.spiritual) {
        bonus += item.challengeBonuses.spiritual;
      }
    }
    
    // Companion bonuses - only count companions that help with spiritual challenges
    for (const companionId of playerStore.animalCompanions) {
      const companion = cardStore.getCompanionById(companionId);
      if (companion?.challengeBonuses?.spiritual) {
        bonus += companion.challengeBonuses.spiritual;
        
        // Apply seasonal companion bonuses if applicable
        if (companion.seasonalBonuses?.[seasonStore.currentSeason]?.spiritual) {
          bonus += companion.seasonalBonuses[seasonStore.currentSeason].spiritual;
        }
      }
    }
    
    // Blessing tokens
    bonus += challengeStore.blessingTokens;
    
    return bonus;
  }
  
  /**
   * Apply specific effects for spiritual challenges
   * @param outcome The challenge outcome
   * @param challenge The spiritual challenge that was attempted
   */
  applyOutcomeEffects(outcome: ChallengeOutcome, challenge: Challenge): void {
    const logStore = useLogStore();
    const challengeStore = useChallenge();
    
    // Common outcome handling
    if (outcome.success === true) {
      // Handle spiritual success
      if (challenge.resourceReward) {
        // Spiritual challenges might reduce threat by connecting with nature
        const threatReduction = 1;
        challengeStore.removeThreatTokens(threatReduction);
        logStore.addToGameLog(`Your spiritual connection with nature reduces threat by ${threatReduction}.`);
      }
      
      if (outcome.exceptional) {
        // Exceptional spiritual success - might gain blessing token
        logStore.addToGameLog('Your exceptional spiritual connection has blessed your journey!');
      }
    } else if (outcome.success === 'partial') {
      // Partial success
      if (challenge.resourceReward) {
        logStore.addToGameLog('Your spiritual connection is maintained, but yields no additional benefits.');
      }
    } else {
      // Failure
      if (outcome.exceptional) {
        // Exceptional spiritual failure might increase threat
        challengeStore.addThreatTokens(1);
        logStore.addToGameLog('Your exceptional failure has disturbed the spiritual balance, increasing threat.');
      }
    }
  }
}
</file>

<file path="src/services/core/BaseService.ts">
/**
 * BaseService
 * 
 * Base class for all services in the application.
 * Provides common functionality and enforces consistency across services.
 */
import { StoreRegistry } from '../core/StoreRegistry';

export abstract class BaseService {
  protected storeRegistry: StoreRegistry;

  /**
   * Constructor for all services
   * @param storeRegistry The store registry for accessing stores
   */
  constructor(storeRegistry: StoreRegistry) {
    this.storeRegistry = storeRegistry;
  }

  /**
   * Initialize the service
   * This method can be overridden by derived services to perform initialization logic
   */
  public initialize(): void {
    // Base implementation does nothing
  }

  /**
   * Reset the service state
   * This method can be overridden by derived services to reset their state
   */
  public reset(): void {
    // Base implementation does nothing
  }
}
</file>

<file path="src/services/core/ServiceRegistry.ts">
/**
 * ServiceRegistry
 * 
 * Central registry for all services in the application.
 * Manages service instantiation and provides a consistent access pattern.
 */
import { StoreRegistry } from './StoreRegistry';

// Import existing service instances instead of non-existent class types
import { challengeService } from '../challenge';
import { diceService } from '../diceService';
import { companionService } from '../companionService';
import { journeyService } from '../journeyService';
import { resourceService } from '../resourceService';
import { craftingService } from '../craftingService';
import { threatService } from '../threatService';
import { victoryService } from '../victoryService';
import { phaseService } from '../phaseService';
import { cardRepository } from '../CardRepository';

export class ServiceRegistry {
  private static instance: ServiceRegistry;
  private storeRegistry: StoreRegistry;
  
  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    this.storeRegistry = new StoreRegistry();
  }

  /**
   * Get the singleton instance of the service registry
   * @returns The service registry instance
   */
  public static getInstance(): ServiceRegistry {
    if (!ServiceRegistry.instance) {
      ServiceRegistry.instance = new ServiceRegistry();
    }
    return ServiceRegistry.instance;
  }

  // Service getters - return the existing service instances
  public get challengeService() {
    return challengeService;
  }

  public get diceService() {
    return diceService;
  }

  public get companionService() {
    return companionService;
  }

  public get journeyService() {
    return journeyService;
  }

  public get resourceService() {
    return resourceService;
  }

  public get craftingService() {
    return craftingService;
  }

  public get threatService() {
    return threatService;
  }

  public get victoryService() {
    return victoryService;
  }
  
  public get phaseService() {
    return phaseService;
  }
  
  public get cardRepository() {
    return cardRepository;
  }
}
</file>

<file path="src/services/core/StoreRegistry.ts">
/**
 * StoreRegistry
 * 
 * Registry for accessing stores consistently across services.
 * Centralizes store access and dependency injection.
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';

export class StoreRegistry {
  /**
   * Get the game store instance
   * @returns The game store instance
   */
  public getGameStore() {
    return useGameStore();
  }

  /**
   * Get the player store instance
   * @returns The player store instance
   */
  public getPlayerStore() {
    return usePlayerStore();
  }

  /**
   * Get the card store instance
   * @returns The card store instance
   */
  public getCardStore() {
    return useCardStore();
  }
}
</file>

<file path="src/services/phaseService.ts">
/**
 * Phase Service
 * Manages game phase transitions and phase-specific logic
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useLogStore } from '@/stores/logStore';
import { GamePhase } from '@/models/enums/phases';
import { BaseService } from '@/services/core/BaseService';

class PhaseService extends BaseService {
  private _gameStore = useGameStore();
  private _playerStore = usePlayerStore();
  private _logStore = useLogStore();
  
  /**
   * Advances the game to the next phase
   * @returns The new game phase
   */
  public advancePhase(): GamePhase {
    const currentPhase = this._gameStore.currentPhase;
    let nextPhase: GamePhase;
    
    // Define phase progression based on current phase
    switch (currentPhase) {
      case GamePhase.SETUP:
        nextPhase = GamePhase.CHARACTER_SELECTION;
        break;
      case GamePhase.CHARACTER_SELECTION:
        nextPhase = GamePhase.SEASONAL_ASSESSMENT;
        break;
      case GamePhase.SEASONAL_ASSESSMENT:
        nextPhase = GamePhase.THREAT_LEVEL_CHECK;
        break;
      case GamePhase.THREAT_LEVEL_CHECK:
        nextPhase = GamePhase.LANDSCAPE_CHALLENGE;
        break;
      case GamePhase.LANDSCAPE_CHALLENGE:
        nextPhase = GamePhase.CHALLENGE_RESOLUTION;
        break;
      case GamePhase.CHALLENGE_RESOLUTION:
        nextPhase = GamePhase.RESOURCE_MANAGEMENT;
        break;
      case GamePhase.RESOURCE_MANAGEMENT:
        nextPhase = GamePhase.ANIMAL_COMPANION;
        break;
      case GamePhase.ANIMAL_COMPANION:
        nextPhase = GamePhase.CRAFTING;
        break;
      case GamePhase.CRAFTING:
        nextPhase = GamePhase.JOURNEY_PROGRESSION;
        break;
      case GamePhase.JOURNEY_PROGRESSION:
        nextPhase = GamePhase.EXPLORATION;
        break;
      case GamePhase.EXPLORATION:
        // Loop back to seasonal assessment for next turn
        nextPhase = GamePhase.SEASONAL_ASSESSMENT;
        break;
      default:
        nextPhase = GamePhase.SEASONAL_ASSESSMENT;
    }
    
    // Set the new phase
    this._gameStore.setPhase(nextPhase);
    
    // Log the phase transition
    this._logStore.addToGameLog(`Advanced to ${this.formatPhase(nextPhase)} phase.`, false, 'phase');
    
    return nextPhase;
  }
  
  /**
   * Gets the current phase
   * @returns The current game phase
   */
  public getCurrentPhase(): GamePhase {
    return this._gameStore.currentPhase;
  }
  
  /**
   * Sets the game phase to a specific value
   * @param phase The phase to set
   * @returns The new game phase
   */
  public setPhase(phase: GamePhase): GamePhase {
    this._gameStore.setPhase(phase);
    this._logStore.addToGameLog(`Moved to ${this.formatPhase(phase)} phase.`, false, 'phase');
    return phase;
  }
  
  /**
   * Handles initial setup for a phase
   * @param phase The phase to setup
   */
  public setupPhase(phase: GamePhase): void {
    // Initialize phase-specific state
    switch (phase) {
      case GamePhase.SEASONAL_ASSESSMENT:
        // Handle season progression
        break;
      case GamePhase.THREAT_LEVEL_CHECK:
        // Initialize threat state
        break;
      // Add other phases as needed
    }
  }
  
  /**
   * Format phase name for display
   * @param phase The phase to format
   * @returns Formatted phase name
   */
  public formatPhase(phase: GamePhase): string {
    return phase.split('_').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(' ');
  }
  
  /**
   * Check if player can advance to a specific phase
   * @param targetPhase The phase to check eligibility for
   * @returns Whether the player can advance to the phase
   */
  public canAdvanceToPhase(targetPhase: GamePhase): boolean {
    // Add conditions for advancing to specific phases
    // Example: Can't advance to journey if health is zero
    if (targetPhase === GamePhase.JOURNEY_PROGRESSION && this._playerStore.health <= 0) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Reset this service to its initial state
   */
  public reset(): void {
    // Reset any service state here
  }
}

// Create singleton instance
export const phaseService = new PhaseService();
</file>

<file path="src/stores/challengeStore.ts">
import { defineStore } from 'pinia';
import { ChallengeOutcome } from '@/models/types/game';
import { useCardStore } from './cardStore';
import { usePlayerStore } from './playerStore';
import { useLogStore } from '@/stores/logStore';
import { useSeasonStore } from './seasonStore';

interface ChallengeState {
  currentChallenge: string | null;
  challengeHistory: { id: string, outcome: string, turn: number }[];
  threatTokens: number;
  blessingTokens: number;
}

/**
 * Store for managing challenges and their outcomes
 */
export const useChallenge = defineStore('challenge', {
  state: (): ChallengeState => ({
    currentChallenge: null,
    challengeHistory: [],
    threatTokens: 0,
    blessingTokens: 0
  }),
  
  getters: {
    /**
     * Calculate the current threat level
     */
    threatLevel(): number {
      return Math.floor(this.threatTokens / 3);
    }
  },
  
  actions: {
    /**
     * Reset the challenge store to initial state
     */
    reset(): void {
      this.currentChallenge = null;
      this.challengeHistory = [];
      this.threatTokens = 0;
      this.blessingTokens = 0;
    },
    
    /**
     * Set the current challenge by ID
     */
    setCurrentChallenge(challengeId: string | null): void {
      const logStore = useLogStore();
      const cardStore = useCardStore();
      
      this.currentChallenge = challengeId;
      
      if (challengeId) {
        const challenge = cardStore.getChallengeById(challengeId);
        
        if (challenge) {
          logStore.addToGameLog(
            `A challenge appears: ${challenge.name}. ${challenge.description}`, 
            true, 
            'challenge', 
            {challengeId, challengeType: challenge.type}
          );
          
          // Describe difficulty
          const difficultyText = this._getDifficultyDescription(challenge.difficulty);
          logStore.addToGameLog(
            `This appears to be a ${difficultyText} challenge.`, 
            false, 
            'challenge'
          );
        }
      } else {
        logStore.addToGameLog('The challenge has been resolved.', false, 'challenge');
      }
    },
    
    /**
     * Add threat tokens to the game
     */
    addThreatTokens(amount: number): number {
      const logStore = useLogStore();
      
      if (amount <= 0) return this.threatTokens;
      
      const previousThreatLevel = this.threatLevel;
      this.threatTokens += amount;
      const newThreatLevel = this.threatLevel;
      
      logStore.addToGameLog(
        `You gain ${amount} threat ${amount === 1 ? 'token' : 'tokens'}. Total: ${this.threatTokens}`, 
        false, 
        'system', 
        {threatTokens: this.threatTokens}
      );
      
      // Alert if threat level increased
      if (newThreatLevel > previousThreatLevel) {
        logStore.addToGameLog(
          `Warning: Threat level has increased to ${newThreatLevel}!`, 
          true, 
          'system', 
          {threatLevel: newThreatLevel}
        );
      }
      
      return this.threatTokens;
    },
    
    /**
     * Remove threat tokens from the game
     */
    removeThreatTokens(amount: number): number {
      const logStore = useLogStore();
      
      if (amount <= 0) return this.threatTokens;
      
      const previousThreatLevel = this.threatLevel;
      this.threatTokens = Math.max(0, this.threatTokens - amount);
      const newThreatLevel = this.threatLevel;
      
      logStore.addToGameLog(
        `You remove ${amount} threat ${amount === 1 ? 'token' : 'tokens'}. Total: ${this.threatTokens}`, 
        false, 
        'system', 
        {threatTokens: this.threatTokens}
      );
      
      // Alert if threat level decreased
      if (newThreatLevel < previousThreatLevel) {
        logStore.addToGameLog(
          `The threat level has decreased to ${newThreatLevel}.`, 
          false, 
          'system', 
          {threatLevel: newThreatLevel}
        );
      }
      
      return this.threatTokens;
    },
    
    /**
     * Handle the threat level check phase
     */
    handleThreatLevelCheck(): void {
      const logStore = useLogStore();
      
      if (this.threatLevel <= 0) {
        logStore.addToGameLog('Threat level check: All is calm in the realm.', false, 'system');
        return;
      }
      
      logStore.addToGameLog(`Threat level check: Current threat level is ${this.threatLevel}.`, true, 'system');
      
      // Roll to determine if a random event occurs
      const roll = this._rollD8();
      
      if (roll <= this.threatLevel) {
        // Trigger random event
        logStore.addToGameLog(`The high threat level has attracted unwanted attention! (Roll: ${roll}, Threat: ${this.threatLevel})`, true, 'system');
        this.triggerRandomEvent();
      } else {
        logStore.addToGameLog(`You evade any ill effects of the threat... for now. (Roll: ${roll}, Threat: ${this.threatLevel})`, false, 'system');
      }
    },
    
    /**
     * Trigger a random event based on threat level
     */
    triggerRandomEvent(): void {
      const logStore = useLogStore();
      const playerStore = usePlayerStore();
      
      const events = [
        {
          name: "Resource Theft",
          description: "Something has stolen from your supplies!",
          effect: () => {
            if (playerStore.resources.length > 0) {
              playerStore.loseRandomResources(1);
            } else {
              logStore.addToGameLog("Fortunately, you had nothing of value to lose.", false, 'system');
            }
          }
        },
        {
          name: "Minor Injury",
          description: "You sustain a minor injury while traveling.",
          effect: () => {
            playerStore.loseHealth(1);
            logStore.addToGameLog("You lose 1 health point.", false, 'system');
          }
        },
        {
          name: "Lost Path",
          description: "You've become disoriented and lost precious time.",
          effect: () => {
            logStore.addToGameLog("Your journey progress is delayed.", false, 'system');
            // Note: In the refactored version, this would call journeyStore.advanceJourney(-1)
          }
        },
        {
          name: "Harsh Weather",
          description: "A sudden change in weather makes travel difficult.",
          effect: () => {
            const seasonStore = useSeasonStore();
            seasonStore.addTempEffect('harsh_weather', 'Harsh Weather', 'Travel and resource gathering are more difficult.', 1, 2);
          }
        },
        {
          name: "Wildlife Encounter",
          description: "You encounter hostile wildlife!",
          effect: () => {
            // Determine outcome based on player's survival skill
            const survivalSkill = playerStore.character?.survival || 0;
            const roll = this._rollD8();
            
            if (roll + survivalSkill >= 6) {
              logStore.addToGameLog("You successfully navigate the encounter without harm.", false, 'system');
              playerStore.addExperience(1);
            } else {
              playerStore.loseHealth(1);
              logStore.addToGameLog("The encounter leaves you injured. You lose 1 health.", true, 'system');
            }
          }
        }
      ];
      
      // Higher threat levels can trigger otherworldly manifestations
      if (this.threatLevel >= 3 && this._rollD8() >= 6) {
        this.triggerOtherworldlyManifestation();
        return;
      }
      
      // Select a random event
      const event = events[Math.floor(Math.random() * events.length)];
      
      logStore.addToGameLog(`Random Event: ${event.name}`, true, 'system');
      logStore.addToGameLog(event.description, false, 'system');
      
      // Apply the event effect
      event.effect();
    },
    
    /**
     * Trigger an otherworldly manifestation (higher-level threat event)
     */
    triggerOtherworldlyManifestation(): void {
      const logStore = useLogStore();
      const playerStore = usePlayerStore();
      const seasonStore = useSeasonStore();
      
      const manifestations = [
        {
          name: "Fae Mischief",
          description: "The fae folk have taken an interest in your journey, playing tricks on you.",
          effect: () => {
            if (playerStore.resources.length >= 2) {
              // Swap two random resources
              const resourceIndices = [];
              while (resourceIndices.length < 2) {
                const idx = Math.floor(Math.random() * playerStore.resources.length);
                if (!resourceIndices.includes(idx)) {
                  resourceIndices.push(idx);
                }
              }
              
              // Swap resources
              const tempResource = playerStore.resources[resourceIndices[0]];
              playerStore.resources[resourceIndices[0]] = playerStore.resources[resourceIndices[1]];
              playerStore.resources[resourceIndices[1]] = tempResource;
              
              logStore.addToGameLog("The fae have rearranged your supplies. Some items seem changed.", true, 'system');
            } else {
              // Add a random new resource
              const cardStore = useCardStore();
              const allResources = cardStore.resources.map(r => r.id);
              const randomResource = allResources[Math.floor(Math.random() * allResources.length)];
              
              playerStore.addResource(randomResource);
              logStore.addToGameLog(`The fae have left you a gift: ${cardStore.getResourceById(randomResource)?.name || randomResource}.`, true, 'system');
            }
          }
        },
        {
          name: "Spirit Visitation",
          description: "An ancestral spirit appears before you with cryptic wisdom.",
          effect: () => {
            playerStore.addExperience(2);
            logStore.addToGameLog("The spirit imparts ancient wisdom. You gain 2 experience points.", true, 'system');
            
            // Add a temporary effect
            seasonStore.addTempEffect('spirit_blessing', 'Spirit Blessing', 'Your connection to the spirit world is strengthened.', 2, 3);
          }
        },
        {
          name: "Time Anomaly",
          description: "Reality shifts around you, and you find yourself experiencing time differently.",
          effect: () => {
            // Reverse the season
            seasonStore.reverseSeason();
            
            logStore.addToGameLog("The flow of time itself seems altered around you.", true, 'system');
          }
        },
        {
          name: "Otherworldly Hunt",
          description: "The Wild Hunt passes through the mortal realm, bringing chaos in their wake.",
          effect: () => {
            // More severe consequences
            playerStore.loseHealth(2);
            playerStore.loseRandomResources(2);
            
            logStore.addToGameLog("The Hunt's passage leaves destruction in its wake. You lose 2 health and some resources.", true, 'system');
            
            // But also some benefit
            playerStore.addExperience(3);
            logStore.addToGameLog("Having witnessed such ancient power, you gain significant insight. +3 experience.", true, 'system');
          }
        },
        {
          name: "Gateway Between Worlds",
          description: "A sudden rift opens between the mortal realm and the Otherworld.",
          effect: () => {
            // This could lead to a special challenge or opportunity
            const roll = this._rollD8();
            
            if (roll >= 4) {
              // Positive outcome
              playerStore.healHealth(Math.min(3, playerStore.maxHealth - playerStore.health));
              logStore.addToGameLog("Healing energies flow from the rift, restoring your vitality. You recover up to 3 health.", true, 'system');
            } else {
              // Negative outcome
              this.addThreatTokens(2);
              logStore.addToGameLog("Dark energies escape from the rift, increasing the threat in the area. +2 threat tokens.", true, 'system');
            }
          }
        }
      ];
      
      // Select a random manifestation
      const manifestation = manifestations[Math.floor(Math.random() * manifestations.length)];
      
      logStore.addToGameLog(`Otherworldly Manifestation: ${manifestation.name}`, true, 'system');
      logStore.addToGameLog(manifestation.description, true, 'system');
      
      // Apply the manifestation effect
      manifestation.effect();
    },
    
    /**
     * Resolve a challenge based on roll and difficulty
     */
    resolveChallenge(totalRoll: number, difficulty: number): 'SUCCESS' | 'PARTIAL' | 'FAILURE' {
      const logStore = useLogStore();
      
      let outcome: 'SUCCESS' | 'PARTIAL' | 'FAILURE';
      let outcomeText: string;
      
      // Determine outcome
      if (totalRoll >= difficulty + 2) {
        // Outstanding success
        outcome = 'SUCCESS';
        outcomeText = 'Outstanding Success';
        this.addChallengeHistory(this.currentChallenge, 'SUCCESS');
        
        // Reduce threat
        this.removeThreatTokens(1);
        
        logStore.addToGameLog(`Challenge outcome: ${outcomeText}! (Roll: ${totalRoll}, Needed: ${difficulty})`, true, 'challenge');
        logStore.addToGameLog('Your exceptional performance reduces the threat level.', false, 'challenge');
      } else if (totalRoll >= difficulty) {
        // Success
        outcome = 'SUCCESS';
        outcomeText = 'Success';
        this.addChallengeHistory(this.currentChallenge, 'SUCCESS');
        
        logStore.addToGameLog(`Challenge outcome: ${outcomeText}. (Roll: ${totalRoll}, Needed: ${difficulty})`, true, 'challenge');
      } else if (totalRoll >= difficulty - 2) {
        // Partial success
        outcome = 'PARTIAL';
        outcomeText = 'Partial Success';
        this.addChallengeHistory(this.currentChallenge, 'PARTIAL');
        
        logStore.addToGameLog(`Challenge outcome: ${outcomeText}. (Roll: ${totalRoll}, Needed: ${difficulty})`, true, 'challenge');
        logStore.addToGameLog('You succeed, but not without some cost.', false, 'challenge');
      } else {
        // Failure
        outcome = 'FAILURE';
        outcomeText = 'Failure';
        this.addChallengeHistory(this.currentChallenge, 'FAILURE');
        
        // Increase threat
        this.addThreatTokens(1);
        
        logStore.addToGameLog(`Challenge outcome: ${outcomeText}. (Roll: ${totalRoll}, Needed: ${difficulty})`, true, 'challenge');
        logStore.addToGameLog('Your failure increases the threat level.', false, 'challenge');
      }
      
      return outcome;
    },
    
    /**
     * Add an entry to the challenge history
     */
    addChallengeHistory(challengeId: string | null, outcome: string): void {
      if (challengeId) {
        this.challengeHistory.push({
          id: challengeId,
          outcome,
          turn: 0 // In the refactored version, this would use gameStore.currentTurn
        });
      }
    },
    
    /**
     * Roll a D8 dice (1-8)
     * @private
     */
    _rollD8(): number {
      return Math.floor(Math.random() * 8) + 1;
    },
    
    /**
     * Get a text description of a challenge difficulty
     * @private
     */
    _getDifficultyDescription(difficulty: number): string {
      if (difficulty <= 3) return 'simple';
      if (difficulty <= 5) return 'moderate';
      if (difficulty <= 7) return 'challenging';
      return 'extremely difficult';
    }
  }
});
</file>

<file path="src/stores/gameStore.ts.backup">
import { defineStore } from 'pinia';
import { GamePhase } from '@/models/enums/phases';
import { Season } from '@/models/enums/seasons';
import { GameState, VictoryConditions, GameLogEntry, TempEffect } from '@/models/types/game';
import { LandscapeCard, SeasonCard } from '@/models/types/cards';
import { usePlayerStore } from './playerStore';
import { useCardStore } from './cardStore';

export const useGameStore = defineStore('game', {
  state: () => ({
    currentPhase: GamePhase.SEASONAL_ASSESSMENT,
    currentTurn: 1,
    currentSeason: Season.SAMHAIN,
    currentLandscapeId: '',
    currentChallenge: null as string | null,
    visitedLandscapes: [] as string[],
    journeyProgress: 0,
    journeyPath: [] as string[],
    gameLog: [] as GameLogEntry[],
    victoryConditions: {
      journeyCompleted: false,
      balanceMaintained: false,
      knowledgeAcquired: false,
      bondsFormed: false,
      questFulfilled: false,
      landscapesTraversed: false,
      seasonsExperienced: false,
      challengesOvercome: false
    } as VictoryConditions,
    gameStarted: false,
    gameOver: false,
    isVictory: false,
    threatTokens: 0,
    blessingTokens: 0,
    challengeHistory: [] as { id: string, outcome: string, turn: number }[],
    tempEffects: [] as TempEffect[],
    journeyComplete: false,
    wisdom: 0,
    ceremonyCompleted: false
  }),
  
  getters: {
    currentLandscape(): LandscapeCard | null {
      const cardStore = useCardStore();
      const landscape = cardStore.getLandscapeById(this.currentLandscapeId);
      return landscape || null;
    },
    
    currentSeasonCard(): SeasonCard | null {
      const cardStore = useCardStore();
      const seasonCard = cardStore.getSeasonById(this.currentSeason);
      return seasonCard || null;
    },
    
    journeyPercentage(): number {
      return Math.min(100, Math.round((this.journeyProgress / 10) * 100));
    },
    
    isGameOver(): boolean {
      return this.gameOver;
    },
    
    hasWon(): boolean {
      return this.isVictory;
    },
    
    formattedGameLog(): GameLogEntry[] {
      return [...this.gameLog].reverse();
    },
    
    threatLevel(): number {
      return Math.floor(this.threatTokens / 3);
    },
    
    hasTempEffect(): (effectId: string) => boolean {
      return (effectId: string) => {
        return this.tempEffects.some(effect => effect.id === effectId && effect.duration > 0);
      };
    },
    
    getTempEffectStrength(): (effectId: string) => number {
      return (effectId: string) => {
        const effect = this.tempEffects.find(effect => effect.id === effectId && effect.duration > 0);
        return effect ? effect.strength : 0;
      };
    }
  },
  
  actions: {
    startGame(): void {
      this.gameStarted = true;
      this.currentPhase = GamePhase.SEASONAL_ASSESSMENT;
      this.currentTurn = 1;
      this.currentSeason = Season.SAMHAIN;
      this.threatTokens = 0;
      this.tempEffects = [];
      this.addToGameLog('Your journey begins in the season of Samhain, when the veil between worlds is thinnest.', true);
    },
    
    resetGame(): void {
      this.currentPhase = GamePhase.SEASONAL_ASSESSMENT;
      this.currentTurn = 1;
      this.currentSeason = Season.SAMHAIN;
      this.currentLandscapeId = '';
      this.currentChallenge = null;
      this.visitedLandscapes = [];
      this.journeyProgress = 0;
      this.journeyPath = [];
      this.gameLog = [];
      this.victoryConditions = {
        journeyCompleted: false,
        balanceMaintained: false,
        knowledgeAcquired: false,
        bondsFormed: false,
        questFulfilled: false,
        landscapesTraversed: false,
        seasonsExperienced: false,
        challengesOvercome: false
      };
      this.gameStarted = false;
      this.gameOver = false;
      this.isVictory = false;
      this.threatTokens = 0;
      this.blessingTokens = 0;
      this.challengeHistory = [];
      this.tempEffects = [];
    },
    
    endGame(isVictory: boolean): void {
      this.gameOver = true;
      this.isVictory = isVictory;
      
      if (isVictory) {
        this.addToGameLog('Congratulations! You have completed your journey through the Celtic Realm.', true);
      } else {
        this.addToGameLog('Your journey has come to an end. The Celtic Realm remains shrouded in mystery.', true);
      }
      
      this.currentPhase = GamePhase.GAME_OVER;
    },
    
    setPhase(phase: GamePhase): void {
      this.currentPhase = phase;
      this.addToGameLog(`Entering the ${this.formatPhase(phase)} phase.`);
    },
    
    advancePhase(): void {
      const phaseOrder = [
        GamePhase.SEASONAL_ASSESSMENT,
        GamePhase.THREAT_LEVEL_CHECK,
        GamePhase.LANDSCAPE_CHALLENGE,
        GamePhase.CHALLENGE_RESOLUTION,
        GamePhase.RESOURCE_MANAGEMENT,
        GamePhase.ANIMAL_COMPANION,
        GamePhase.CRAFTING,
        GamePhase.JOURNEY_PROGRESSION
      ];
      
      const currentIndex = phaseOrder.indexOf(this.currentPhase);
      if (currentIndex !== -1) {
        this.currentPhase = phaseOrder[(currentIndex + 1) % phaseOrder.length];
        this.addToGameLog(`Entering the ${this.formatPhase(this.currentPhase)} phase.`, true, 'phase', {
          previousPhase: phaseOrder[currentIndex],
          newPhase: this.currentPhase
        });
        
        // If we've completed a full cycle, advance the turn
        if (this.currentPhase === GamePhase.SEASONAL_ASSESSMENT) {
          this.advanceTurn();
        }
      }
    },
    
    advanceTurn(): void {
      this.currentTurn++;
      this.addToGameLog(`Turn ${this.currentTurn} has begun.`, true, 'system', {
        newTurn: this.currentTurn,
        currentSeason: this.formatSeason(this.currentSeason)
      });
      
      // Process any temporary effects
      this.processTempEffects();
      
      // Check if we need to advance the season
      if (this.currentTurn % 3 === 0) {
        this.advanceSeason();
      }
      
      // Check victory conditions
      this.checkVictoryConditions();
    },
    
    advanceSeason(): void {
      const seasonOrder = [
        Season.SAMHAIN,
        Season.WINTERS_DEPTH,
        Season.IMBOLC,
        Season.BELTANE,
        Season.LUGHNASADH
      ];
      
      const currentIndex = seasonOrder.indexOf(this.currentSeason);
      if (currentIndex !== -1) {
        const nextIndex = (currentIndex + 1) % seasonOrder.length;
        const previousSeason = this.currentSeason;
        this.currentSeason = seasonOrder[nextIndex];
        
        this.addToGameLog(`The season has changed to ${this.formatSeason(this.currentSeason)}.`, true, 'phase', {
          previousSeason: this.formatSeason(previousSeason),
          newSeason: this.formatSeason(this.currentSeason),
          turn: this.currentTurn
        });
        
        // Process resource changes with seasonal transition
        this.processSeasonalResourceChanges(previousSeason, this.currentSeason);
        
        // Apply season effects
        const cardStore = useCardStore();
        const seasonCard = cardStore.getSeasonById(this.currentSeason);
        
        if (seasonCard) {
          this.addToGameLog(`${seasonCard.name}: ${seasonCard.description}`, false, 'system', {
            seasonEffects: seasonCard.effects
          });
          
          // Apply any immediate effects of the season
          if (seasonCard.effects && seasonCard.effects.length > 0) {
            seasonCard.effects.forEach(effect => {
              const description = typeof effect.effect === 'string' ? effect.effect : `${effect.effect}`;
              this.addToGameLog(`Season Effect: ${effect.name} - ${description}`, false, 'system', {
                effectDetails: effect
              });
              // Here you would apply the actual effect logic
            });
          }
        }
      }
    },
    
    setCurrentLandscape(landscapeId: string): void {
      const previousLandscapeId = this.currentLandscapeId;
      this.currentLandscapeId = landscapeId;
      
      // Add to visited landscapes if not already visited
      if (!this.visitedLandscapes.includes(landscapeId)) {
        this.addVisitedLandscape(landscapeId);
      }
      
      const cardStore = useCardStore();
      const landscape = cardStore.getLandscapeById(landscapeId);
      
      if (landscape) {
        this.addToGameLog(`You have arrived at ${landscape.name}.`, true, 'action', {
          previousLandscapeId,
          newLandscapeId: landscapeId,
          landscapeName: landscape.name,
          availableResources: landscape.availableResources,
          specialFeature: landscape.specialFeature,
          providesShelter: landscape.providesShelter
        });
        
        // Apply entry effects if any
        if (landscape.entryEffect) {
          this.addToGameLog(`${landscape.name} Entry Effect: ${landscape.entryEffect.description}`, false, 'system', {
            entryEffect: landscape.entryEffect
          });
          // Here you would apply the actual entry effect logic
        }
        
        // Check if we've traversed enough landscapes for victory condition
        if (this.visitedLandscapes.length >= 10) {
          this.victoryConditions.landscapesTraversed = true;
          this.addToGameLog('You have traversed enough landscapes to complete your journey.', true, 'system', {
            visitedLandscapes: this.visitedLandscapes.length,
            requiredLandscapes: 10
          });
        }
        
        // Check if we've reached the Wild Horse Plain (final destination)
        if (landscapeId === 'wild_horse_plain') {
          this.victoryConditions.journeyCompleted = true;
          this.addToGameLog('You have reached the Wild Horse Plain, the final destination of your journey!', true, 'system', {
            journeyCompleted: true
          });
          
          // Check if we should end the game
          if (this.checkVictoryConditions()) {
            this.completeJourney(true);
          }
        }
      }
    },
    
    addVisitedLandscape(landscapeId: string): void {
      if (!this.visitedLandscapes.includes(landscapeId)) {
        this.visitedLandscapes.push(landscapeId);
        
        const cardStore = useCardStore();
        const landscape = cardStore.getLandscapeById(landscapeId);
        
        if (landscape) {
          this.addToGameLog(`${landscape.name} has been added to your journey path.`, false, 'system', {
            landscapeId,
            landscapeName: landscape.name,
            visitedLandscapesCount: this.visitedLandscapes.length
          });
          
          // Add to journey path for tracking
          this.journeyPath.push(landscapeId);
          
          // Increase journey progress
          this.advanceJourney(1);
        }
      }
    },
    
    setCurrentChallenge(challengeId: string | null): void {
      const previousChallengeId = this.currentChallenge;
      this.currentChallenge = challengeId;
      
      if (challengeId) {
        const cardStore = useCardStore();
        const challenge = cardStore.getChallengeById(challengeId);
        
        if (challenge) {
          // Extract challenge details for the log
          const challengeName = challenge.name || `${this.currentLandscape?.name || 'Unknown'} Challenge`;
          const challengeType = challenge.type || 'unknown';
          const challengeDifficulty = challenge.difficulty || 5;
          const challengeRewards = challenge.rewards || { resources: [], experience: 0 };
          
          this.addToGameLog(`You face a challenge: ${challengeName}`, true, 'challenge', {
            previousChallengeId,
            newChallengeId: challengeId,
            challengeName: challengeName,
            challengeType: challengeType,
            challengeDifficulty: challengeDifficulty,
            challengeRewards: challengeRewards
          });
        }
      } else {
        this.addToGameLog('The challenge has been cleared.', false, 'challenge', {
          previousChallengeId
        });
      }
    },
    
    advanceJourney(steps: number): void {
      const previousProgress = this.journeyProgress;
      this.journeyProgress += steps;
      
      this.addToGameLog(`Your journey has progressed by ${steps} steps.`, false, 'action', {
        previousProgress,
        newProgress: this.journeyProgress,
        stepsAdded: steps
      });
    },
    
    completeJourney(isVictory: boolean): void {
      this.addToGameLog(
        isVictory 
          ? 'Congratulations! You have successfully completed your journey through the Celtic Realm!' 
          : 'Your journey has come to an end, but not in victory.',
        true,
        'system',
        {
          isVictory,
          journeyProgress: this.journeyProgress,
          victoryConditions: { ...this.victoryConditions },
          visitedLandscapes: this.visitedLandscapes.length,
          currentTurn: this.currentTurn,
          currentSeason: this.formatSeason(this.currentSeason)
        }
      );
      
      // End the game
      this.endGame(isVictory);
    },
    
    addToGameLog(
      message: string, 
      highlight: boolean = false, 
      type: 'phase' | 'action' | 'challenge' | 'resource' | 'companion' | 'crafting' | 'system' | 'error' | 'debug' = 'system',
      details: { [key: string]: any } = {}
    ): void {
      const entry: GameLogEntry = {
        message,
        timestamp: Date.now(),
        highlight,
        type,
        details,
        turn: this.currentTurn,
        season: this.currentSeason
      };
      
      // Log to console for debugging
      if (type === 'error') {
        console.error(entry.message, details);
      } else if (type === 'debug') {
        console.debug(entry.message, details);
      } else {
        console.log(entry.message, details);
      }
      
      this.gameLog.push(entry);
      
      // Keep the log from getting too large
      if (this.gameLog.length > 100) {
        this.gameLog.shift();
      }
    },
    
    checkVictoryConditions(): boolean {
      const allConditionsMet = Object.values(this.victoryConditions).every(Boolean);
      
      if (allConditionsMet) {
        this.endGame(true);
      }
      
      return allConditionsMet;
    },
    
    formatPhase(phase: GamePhase): string {
      return phase.replace(/_/g, ' ').toLowerCase();
    },
    
    formatSeason(season: Season): string {
      return season.replace(/_/g, ' ').toLowerCase();
    },
    
    // New methods for threat management
    addThreatTokens(amount: number): number {
      const oldThreatLevel = Math.floor(this.threatTokens / 3);
      
      this.threatTokens += amount;
      
      const newThreatLevel = Math.floor(this.threatTokens / 3);
      
      if (newThreatLevel > oldThreatLevel) {
        this.addToGameLog(`The threat level has increased to ${newThreatLevel}!`, true);
      }
      
      // Update victory condition for balance
      this.victoryConditions.balanceMaintained = this.threatTokens < 6;
      
      return this.threatTokens;
    },
    
    removeThreatTokens(amount: number): number {
      const oldThreatLevel = Math.floor(this.threatTokens / 3);
      
      this.threatTokens = Math.max(0, this.threatTokens - amount);
      
      const newThreatLevel = Math.floor(this.threatTokens / 3);
      
      if (newThreatLevel < oldThreatLevel) {
        this.addToGameLog(`The threat level has decreased to ${newThreatLevel}.`, true);
      }
      
      // Update victory condition for balance
      this.victoryConditions.balanceMaintained = this.threatTokens < 6;
      
      return this.threatTokens;
    },
    
    addTempEffect(effectId: string, name: string, description: string, strength: number, duration: number): void {
      // Check if effect already exists
      const existingEffectIndex = this.tempEffects.findIndex(effect => effect.id === effectId);
      
      if (existingEffectIndex !== -1) {
        // Update existing effect
        this.tempEffects[existingEffectIndex].strength = strength;
        this.tempEffects[existingEffectIndex].duration = duration;
      } else {
        // Add new effect
        this.tempEffects.push({
          id: effectId,
          name,
          description,
          strength,
          duration
        });
        
        this.addToGameLog(`New effect: ${name} - ${description}`, true);
      }
    },
    
    removeTempEffect(effectId: string): boolean {
      const index = this.tempEffects.findIndex(effect => effect.id === effectId);
      
      if (index !== -1) {
        const effect = this.tempEffects[index];
        this.addToGameLog(`Effect ended: ${effect.name}`, true);
        this.tempEffects.splice(index, 1);
        return true;
      }
      
      return false;
    },
    
    processTempEffects(): void {
      // Reduce duration of all temporary effects
      this.tempEffects.forEach((effect, index) => {
        if (effect.duration > 0) {
          effect.duration--;
          
          if (effect.duration === 0) {
            this.addToGameLog(`Effect ended: ${effect.name}`, true);
            this.tempEffects.splice(index, 1);
          }
        }
      });
    },
    
    clearGameLog(): void {
      this.gameLog = [];
      this.addToGameLog('Game log cleared.', false, 'system', {
        timestamp: Date.now()
      });
    },
    
    // Handle threat level check phase
    handleThreatLevelCheck(): void {
      const threatLevel = this.threatLevel;
      this.addToGameLog(`Threat Level Check: Current threat level is ${threatLevel}.`, true);
      
      // Apply threat level effects to challenge difficulty
      if (threatLevel > 0) {
        this.addToGameLog(`Challenge difficulty increased by +${threatLevel} due to threat level.`);
      }
      
      // Special events based on threat tokens
      if (this.threatTokens >= 10) {
        this.addToGameLog('DANGER: The otherworldly forces are manifesting! Rolling on the Otherworldly Manifestation table.', true, 'error');
        this.triggerOtherworldlyManifestation();
      } else if (this.threatTokens >= 5) {
        this.addToGameLog('WARNING: The spiritual balance is disturbed. Drawing a random event.', true, 'challenge');
        this.triggerRandomEvent();
      }
      
      // Advance to next phase
      this.advancePhase();
    },
    
    // Random Event System
    triggerRandomEvent(): void {
      // Define possible random events
      const randomEvents = [
        {
          id: 'sudden_storm',
          name: 'Sudden Storm',
          description: 'Dark clouds gather suddenly, bringing a fierce storm.',
          effect: () => {
            this.addToGameLog('The storm makes gathering resources more difficult. Resource capacity reduced by 1 temporarily.', true);
            this.addTempEffect('storm', 'Sudden Storm', 'Resource capacity -1', 1, 2);
            const playerStore = usePlayerStore();
            playerStore.addEffect({
              id: 'storm_effect',
              name: 'Storm Hindrance',
              description: 'Resource gathering diminished',
              type: 'negative',
              magnitude: -1,
              duration: 2,
              target: 'resourceCapacity'
            });
          }
        },
        {
          id: 'animal_migration',
          name: 'Animal Migration',
          description: 'A sudden migration of animals passes through the area.',
          effect: () => {
            this.addToGameLog('The animal migration brings opportunity. Your next Animal Companion check gets +2.', true);
            this.addTempEffect('migration', 'Animal Migration', 'Animal Companion checks +2', 2, 1);
          }
        },
        {
          id: 'ancient_memory',
          name: 'Ancient Memory',
          description: 'The land itself seems to remember ancient events, stirring old magics.',
          effect: () => {
            const playerStore = usePlayerStore();
            playerStore.gainExperience(1);
            this.addToGameLog('Ancient wisdom floods your mind. You gain 1 experience point.', true);
          }
        },
        {
          id: 'fae_mischief',
          name: 'Fae Mischief',
          description: 'The faerie folk play tricks on unwary travelers.',
          effect: () => {
            this.addToGameLog('Your supplies have been tampered with by mischievous fae.', true);
            const playerStore = usePlayerStore();
            playerStore.loseRandomResources(1);
          }
        },
        {
          id: 'spiritual_blessing',
          name: 'Spiritual Blessing',
          description: 'The ancestral spirits take notice of your journey and offer aid.',
          effect: () => {
            this.blessingTokens += 1;
            this.addToGameLog('You receive a blessing from the spirits. +1 Blessing token.', true);
          }
        }
      ];
      
      // Select random event
      const randomEvent = randomEvents[Math.floor(Math.random() * randomEvents.length)];
      
      // Trigger the event
      this.addToGameLog(`Random Event: ${randomEvent.name} - ${randomEvent.description}`, true);
      randomEvent.effect();
    },
    
    // Otherworldly Manifestation System
    triggerOtherworldlyManifestation(): void {
      // Define possible otherworldly manifestations
      const manifestations = [
        {
          id: 'spirit_guardian',
          name: 'Spirit Guardian',
          description: 'A powerful guardian spirit manifests to test your worthiness.',
          effect: () => {
            this.addToGameLog('The spirit guardian challenges you to prove your worth!', true);
            this.addTempEffect('guardian_challenge', 'Spirit Guardian Challenge', 'Must succeed on next 2 challenges or lose 2 health', 2, 2);
            // Set up consequence if challenges are failed
            this.addToGameLog('You must succeed on your next two challenges or suffer 2 health damage.', true);
          }
        },
        {
          id: 'reality_distortion',
          name: 'Reality Distortion',
          description: 'The boundaries between worlds thin, causing strange distortions in reality.',
          effect: () => {
            this.addToGameLog('Reality warps around you, changing your path!', true);
            // 50% chance to advance or reverse season
            if (Math.random() > 0.5) {
              this.advanceSeason();
              this.addToGameLog('Time accelerates, advancing the season prematurely!', true);
            } else {
              this.reverseSeason();
              this.addToGameLog('Time flows backwards, returning to the previous season!', true);
            }
          }
        },
        {
          id: 'ancestral_curse',
          name: 'Ancestral Curse',
          description: 'Ancient spirits place a curse upon you for disturbing the balance.',
          effect: () => {
            this.addToGameLog('An ancestral curse falls upon you!', true);
            const playerStore = usePlayerStore();
            playerStore.addEffect({
              id: 'ancestral_curse',
              name: 'Ancestral Curse',
              description: '-1 to all challenge rolls',
              type: 'negative',
              magnitude: -1,
              duration: 3,
              target: 'challengeRolls'
            });
            this.addToGameLog('You feel weakened. -1 to all challenge rolls for 3 turns.', true);
          }
        },
        {
          id: 'otherworld_portal',
          name: 'Otherworld Portal',
          description: 'A portal to the Otherworld opens, risking pulling you in.',
          effect: () => {
            this.addToGameLog('A swirling portal to the Otherworld appears before you!', true);
            // Increase threat further
            this.addThreatTokens(2);
            this.addToGameLog('The portal\'s energy increases the spiritual imbalance. +2 Threat tokens.', true);
            
            // But also offer a choice for reward
            this.addToGameLog('You sense that reaching into the portal could yield a valuable resource, but at great risk...', true);
            // This would trigger a choice in the UI
            // For now, simulate a 50/50 chance of benefit vs. harm
            if (Math.random() > 0.5) {
              const playerStore = usePlayerStore();
              const resource = ['silver_mistletoe', 'standing_stone_chips', 'amber_shards'][Math.floor(Math.random() * 3)];
              playerStore.addResource(resource);
              this.addToGameLog(`You reach into the portal and retrieve a rare resource: ${resource.replace('_', ' ')}!`, true);
            } else {
              const playerStore = usePlayerStore();
              playerStore.loseHealth(2);
              this.addToGameLog('The portal\'s energy burns you as you reach in! You lose 2 health.', true);
            }
          }
        },
        {
          id: 'time_anomaly',
          name: 'Time Anomaly',
          description: 'Time flows strangely, affecting your progress and abilities.',
          effect: () => {
            this.addToGameLog('Time becomes unstable around you!', true);
            // 50% chance to advance or reverse season
            if (Math.random() > 0.5) {
              this.advanceSeason();
              this.addToGameLog('Time accelerates, advancing the season prematurely!', true);
            } else {
              this.reverseSeason();
              this.addToGameLog('Time flows backwards, returning to the previous season!', true);
            }
          }
        }
      ];
      
      // Select random manifestation
      const manifestation = manifestations[Math.floor(Math.random() * manifestations.length)];
      
      // Trigger the manifestation
      this.addToGameLog(`Otherworldly Manifestation: ${manifestation.name} - ${manifestation.description}`, true, 'error');
      manifestation.effect();
    },
    
    // Helper for Time Anomaly manifestation
    reverseSeason(): void {
      const seasonOrder = [
        Season.SAMHAIN,
        Season.WINTERS_DEPTH,
        Season.IMBOLC,
        Season.BELTANE,
        Season.LUGHNASADH
      ];
      
      const currentIndex = seasonOrder.indexOf(this.currentSeason);
      if (currentIndex > 0) {
        const previousSeason = seasonOrder[currentIndex - 1];
        this.currentSeason = previousSeason;
        this.addToGameLog(`The season has reversed to ${this.formatSeason(this.currentSeason)}.`, true);
      } else {
        this.addToGameLog('The season remains unchanged - you are already at the beginning of the cycle.', true);
      }
      
      // Update the season card
      this.updateSeasonCard();
    },
    
    // Handle healing and recovery phase
    handleHealingRecovery(): void {
      const playerStore = usePlayerStore();
      
      // Basic healing opportunity each turn
      const healingAmount = 1;
      const currentSeason = this.currentSeasonCard;
      
      // Apply seasonal healing modifiers
      let seasonalHealingModifier = 0;
      if (currentSeason) {
        if (this.currentSeason === Season.IMBOLC) {
          seasonalHealingModifier = 1; // Imbolc provides +1 healing
        } else if (this.currentSeason === Season.LUGHNASADH) {
          seasonalHealingModifier = 0; // Lughnasadh doubles healing effectiveness
          this.addToGameLog('The community support during Lughnasadh doubles your healing effectiveness.');
        }
      }
      
      const totalHealing = healingAmount + seasonalHealingModifier;
      
      if (playerStore.health < playerStore.maxHealth) {
        playerStore.healHealth(totalHealing);
        this.addToGameLog(`You recover ${totalHealing} health during the healing phase.`, true, 'system');
      } else {
        this.addToGameLog('You are already at full health.', false, 'system');
      }
      
      // Special healing locations
      if (this.currentLandscape && ['Sacred Oak Grove', 'Druid\'s Sanctuary', 'Moonlit Loch'].includes(this.currentLandscape.name)) {
        const specialHealing = 1;
        playerStore.healHealth(specialHealing);
        this.addToGameLog(`The spiritual energy at this ${this.currentLandscape.name} provides an additional ${specialHealing} healing.`, true);
      }
      
      // Advance to next phase
      this.advancePhase();
    },
    
    // Process resource changes during seasonal transitions
    processSeasonalResourceChanges(previousSeason: Season, newSeason: Season): void {
      const playerStore = usePlayerStore();
      const cardStore = useCardStore();
      const resources = [...playerStore.resources]; // Create a copy to avoid modification during iteration
      
      this.addToGameLog(`Checking resources for seasonal changes...`, false, 'system');
      
      // Define which resources spoil during which seasonal transitions
      const seasonalSpoilage = {
        // From Samhain to Imbolc (early winter)
        [`${Season.SAMHAIN}_${Season.WINTERS_DEPTH}`]: ['berries', 'mushrooms', 'fresh_herbs'],
        [`${Season.WINTERS_DEPTH}_${Season.IMBOLC}`]: ['winter_roots', 'preserved_meats'],
        
        // From Imbolc to Beltane (spring)
        [`${Season.IMBOLC}_${Season.BELTANE}`]: ['spring_flowers', 'birch_sap'],
        
        // From Beltane to Lughnasadh (summer)
        [`${Season.BELTANE}_${Season.LUGHNASADH}`]: ['summer_fruits', 'fresh_water'],
        
        // From Lughnasadh to Samhain (autumn)
        [`${Season.LUGHNASADH}_${Season.SAMHAIN}`]: ['summer_fruits', 'fresh_water']
      };
      
      // Define which resources transform during seasonal transitions
      const seasonalTransformations = {
        // From Samhain to Imbolc
        [`${Season.SAMHAIN}_${Season.WINTERS_DEPTH}`]: {
          'acorns': 'winter_roots', // Acorns become more valuable in winter
          'fresh_herbs': 'dried_herbs' // Fresh herbs dry out
        },
        
        // From Imbolc to Beltane
        [`${Season.WINTERS_DEPTH}_${Season.IMBOLC}`]: {
          'snow_essence': 'spring_water', // Snow melts into spring water
          'pine_needles': 'spring_flowers' // New growth replaces old
        },
        
        // From Beltane to Lughnasadh
        [`${Season.IMBOLC}_${Season.BELTANE}`]: {
          'spring_flowers': 'summer_fruits', // Flowers become fruits
          'birch_sap': 'sweet_syrup' // Sap concentrates in the heat
        },
        
        // From Lughnasadh to Samhain
        [`${Season.BELTANE}_${Season.LUGHNASADH}`]: {
          'green_leaves': 'red_leaves', // Leaves change color
          'summer_fruits': 'fermented_fruit' // Fruits ferment
        }
      };
      
      // Check for resources that spoil during this seasonal transition
      const transitionKey = `${previousSeason}_${newSeason}`;
      const spoilingResources = seasonalSpoilage[transitionKey] || [];
      const transformingResources = seasonalTransformations[transitionKey] || {};
      
      // Process spoilage
      resources.forEach(resourceId => {
        // Check if this resource spoils
        if (spoilingResources.includes(resourceId)) {
          playerStore.removeResource(resourceId);
          this.addToGameLog(`Your ${this.formatResourceName(resourceId)} has spoiled with the change to ${this.formatSeason(newSeason)}.`, true, 'resource');
        }
        
        // Check if this resource transforms
        if (resourceId in transformingResources) {
          const newResourceId = transformingResources[resourceId];
          playerStore.removeResource(resourceId);
          playerStore.addResource(newResourceId);
          
          // Get resource names for better logging
          const oldResource = cardStore.getResourceById(resourceId);
          const newResource = cardStore.getResourceById(newResourceId);
          
          const oldName = oldResource ? oldResource.name : this.formatResourceName(resourceId);
          const newName = newResource ? newResource.name : this.formatResourceName(newResourceId);
          
          this.addToGameLog(`Your ${oldName} has transformed into ${newName} with the change to ${this.formatSeason(newSeason)}.`, true, 'resource');
        }
      });
      
      // Update resource availability based on the new season
      this.updateResourceAvailability();
    },
    
    // Helper method to format resource ID to a friendly name
    formatResourceName(resourceId: string): string {
      return resourceId.replace(/_/g, ' ');
    },
    
    // Update resource availability based on current season
    updateResourceAvailability(): void {
      // This would be implemented in the cardStore or another appropriate place
      // It would adjust what resources are available in each landscape based on the season
      
      this.addToGameLog(`Resource availability has adjusted to the new season.`, false, 'system');
      
      // Here we would apply season-specific resource modifiers
      // For example, some resources become more abundant in certain seasons
    },
    
    // Method to perform a D8 dice roll (1-8)
    rollD8(): number {
      // Random number between 1 and 8
      const roll = Math.floor(Math.random() * 8) + 1;
      this.addToGameLog(`You rolled a ${roll} on a D8.`, true, 'system');
      return roll;
    },
    
    // Resolve a challenge based on roll and difficulty
    resolveChallenge(totalRoll: number, difficulty: number): 'SUCCESS' | 'PARTIAL' | 'FAILURE' {
      this.addToGameLog(`Challenge attempt: Roll ${totalRoll} vs Difficulty ${difficulty}`, true, 'challenge');
      
      // Natural 8 is always a success
      if (totalRoll >= difficulty + 2) {
        this.addToGameLog('Critical Success! You overcome the challenge with exceptional results.', true, 'challenge');
        
        // Add to challenge history
        if (this.currentChallenge) {
          this.challengeHistory.push({
            id: this.currentChallenge,
            outcome: 'SUCCESS',
            turn: this.currentTurn
          });
        }
        
        // Remove threat tokens for successful challenge
        this.removeThreatTokens(1);
        
        return 'SUCCESS';
      } else if (totalRoll >= difficulty) {
        this.addToGameLog('Success! You overcome the challenge.', true, 'challenge');
        
        // Add to challenge history
        if (this.currentChallenge) {
          this.challengeHistory.push({
            id: this.currentChallenge,
            outcome: 'SUCCESS',
            turn: this.currentTurn
          });
        }
        
        return 'SUCCESS';
      } else if (totalRoll >= difficulty - 2) {
        this.addToGameLog('Partial Success. You manage to barely overcome parts of the challenge.', true, 'challenge');
        
        // Add to challenge history
        if (this.currentChallenge) {
          this.challengeHistory.push({
            id: this.currentChallenge,
            outcome: 'PARTIAL',
            turn: this.currentTurn
          });
        }
        
        // Add threat tokens for partial success
        this.addThreatTokens(1);
        
        return 'PARTIAL';
      } else {
        this.addToGameLog('Failure. The challenge proves too difficult for now.', true, 'challenge');
        
        // Add to challenge history
        if (this.currentChallenge) {
          this.challengeHistory.push({
            id: this.currentChallenge,
            outcome: 'FAILURE',
            turn: this.currentTurn
          });
        }
        
        // Add threat tokens for failure
        this.addThreatTokens(2);
        
        return 'FAILURE';
      }
    },
    
    // Perform a special action at a location
    performSpecialAction(actionId: string): { success: boolean; message: string } {
      const cardStore = useCardStore();
      const playerStore = usePlayerStore();
      
      // Handle different special actions based on ID
      switch (actionId) {
        case 'standing_stones_ceremony':
          // This is the final ceremony at the Great Standing Stones
          this.ceremonyCompleted = true;
          this.journeyComplete = true;
          
          // Add wisdom to player
          playerStore.wisdom = (playerStore.wisdom || 0) + 5;
          
          // Log the result
          this.addToGameLog('You have performed the ancient ceremony at the Standing Stones. Your journey is complete!', true, 'special');
          
          return {
            success: true,
            message: 'You have successfully completed the journey!'
          };
          
        case 'heal_at_spring':
          // Healing at the sacred spring
          playerStore.healHealth(5);
          
          this.addToGameLog('You drink from the sacred spring and feel revitalized.', true, 'special');
          
          return {
            success: true,
            message: 'You feel refreshed and healed.'
          };
          
        case 'meditation':
          // Gaining wisdom through meditation
          playerStore.wisdom = (playerStore.wisdom || 0) + 2;
          
          this.addToGameLog('You meditate peacefully, gaining insight and wisdom.', true, 'special');
          
          return {
            success: true,
            message: 'Your mind feels clearer and wiser.'
          };
          
        default:
          return {
            success: false,
            message: 'That action is not available at this location.'
          };
      }
    },
    
    // Method to gather resources from the current landscape
    gatherResources(): void {
      const playerStore = usePlayerStore();
      const cardStore = useCardStore();
      
      if (!this.currentLandscape) {
        this.addToGameLog('No landscape available to gather resources from.', true, 'error');
        return;
      }
      
      // Get available resources from current landscape
      const availableResources = this.currentLandscape.availableResources || [];
      
      if (availableResources.length === 0) {
        this.addToGameLog(`There are no resources available at ${this.currentLandscape.name}.`, true, 'resource');
        return;
      }
      
      // Check if player has room for resources
      if (playerStore.resources.length >= playerStore.resourceCapacity) {
        this.addToGameLog(`Your resource capacity (${playerStore.resourceCapacity}) is full. You must discard resources before gathering more.`, true, 'resource');
        return;
      }
      
      // Perform gathering challenge
      const baseDifficulty = 5; // Base difficulty for resource gathering
      const seasonalModifier = this.getSeasonalResourceModifier();
      const threatModifier = Math.floor(this.threatTokens / 3); // Threat level affects difficulty
      
      const difficulty = baseDifficulty + threatModifier + seasonalModifier;
      
      // Roll for challenge
      const roll = this.rollD8();
      const characterModifier = playerStore.wisdom || 0;
      const totalRoll = roll + characterModifier;
      
      // Determine outcome
      const outcome = this.resolveChallenge(totalRoll, difficulty);
      
      // Award resources based on outcome
      if (outcome === 'SUCCESS') {
        // Success: Gain 2 resources
        this.awardResources(2, availableResources);
        this.addToGameLog(`Success! You've gathered resources from ${this.currentLandscape.name}.`, true, 'resource');
      } else if (outcome === 'PARTIAL') {
        // Partial success: Gain 1 resource
        this.awardResources(1, availableResources);
        this.addToGameLog(`Partial success. You've gathered a small amount of resources from ${this.currentLandscape.name}.`, true, 'resource');
      } else {
        // Failure: No resources gathered
        this.addToGameLog(`You failed to gather any resources from ${this.currentLandscape.name}.`, true, 'resource');
      }
      
      // Apply seasonal bonus for Lughnasadh (Harvest season)
      if (this.currentSeason === Season.LUGHNASADH && (outcome === 'SUCCESS' || outcome === 'PARTIAL')) {
        this.addToGameLog('The harvest season blesses you with an additional resource.', true, 'resource');
        this.awardResources(1, availableResources);
      }
    },
    
    // Helper to award resources to the player
    awardResources(count: number, availableResources: string[]): void {
      const playerStore = usePlayerStore();
      const cardStore = useCardStore();
      
      // Make sure count doesn't exceed available space
      const remainingCapacity = playerStore.resourceCapacity - playerStore.resources.length;
      count = Math.min(count, remainingCapacity);
      
      if (count <= 0) {
        this.addToGameLog('Your resource capacity is full.', true, 'resource');
        return;
      }
      
      // Filter out resources that don't exist in the card store
      const validResources = availableResources.filter(id => cardStore.getResourceById(id) !== null);
      
      if (validResources.length === 0) {
        this.addToGameLog('No valid resources available in this area.', true, 'resource');
        return;
      }
      
      // Randomly select resources from available ones
      for (let i = 0; i < count; i++) {
        if (validResources.length === 0) break;
        
        const randomIndex = Math.floor(Math.random() * validResources.length);
        const resourceId = validResources[randomIndex];
        
        const resource = cardStore.getResourceById(resourceId);
        if (!resource) {
          // Skip this resource if it can't be found (shouldn't happen due to filter above)
          continue;
        }
        
        playerStore.addResource(resourceId);
        this.addToGameLog(`You gathered ${resource.name}.`, false, 'resource');
      }
    },
    
    // Get seasonal modifier for resource gathering
    getSeasonalResourceModifier(): number {
      // Check if resources are abundant or scarce in the current season
      switch (this.currentSeason) {
        case Season.SAMHAIN:
          return 1; // Slightly easier gathering during Samhain
        case Season.WINTERS_DEPTH:
          return 2; // More difficult during Winter's Depth
        case Season.IMBOLC:
          return 0; // Normal during Imbolc
        case Season.BELTANE:
          return -1; // Easier during Beltane (abundance)
        case Season.LUGHNASADH:
          return -2; // Much easier during Lughnasadh (harvest time)
        default:
          return 0;
      }
    },
  }
});
</file>

<file path="src/stores/journeyStore.ts">
import { defineStore } from 'pinia';
import { LandscapeCard } from '@/models/types/cards';
import { useCardStore } from './cardStore';
import { useLogStore } from '@/stores/logStore';
import { usePlayerStore } from './playerStore';

interface JourneyState {
  currentLandscapeId: string;
  visitedLandscapes: string[];
  journeyProgress: number;
  journeyPath: string[];
  journeyComplete: boolean;
  wisdom: number;
}

// Extended landscape interface to accommodate the properties we need
interface ExtendedLandscapeCard extends LandscapeCard {
  arrivalEvent?: string;
  arrivalEffects?: {
    resources?: string[];
    health?: number;
  };
  wisdomGained?: boolean;
}

/**
 * Store for managing the player's journey through landscapes
 */
export const useJourneyStore = defineStore('journey', {
  state: (): JourneyState => ({
    currentLandscapeId: '',
    visitedLandscapes: [],
    journeyProgress: 0,
    journeyPath: [],
    journeyComplete: false,
    wisdom: 0
  }),
  
  getters: {
    /**
     * Get the current landscape card data
     */
    currentLandscape(): ExtendedLandscapeCard | null {
      const cardStore = useCardStore();
      const landscape = cardStore.getLandscapeById(this.currentLandscapeId);
      return landscape as ExtendedLandscapeCard || null;
    },
    
    /**
     * Calculate the journey progress as a percentage
     */
    journeyPercentage(): number {
      return Math.min(100, Math.round((this.journeyProgress / 10) * 100));
    }
  },
  
  actions: {
    /**
     * Reset the journey store to initial state
     */
    reset(): void {
      this.currentLandscapeId = '';
      this.visitedLandscapes = [];
      this.journeyProgress = 0;
      this.journeyPath = [];
      this.journeyComplete = false;
      this.wisdom = 0;
    },
    
    /**
     * Set the current landscape by ID
     */
    setCurrentLandscape(landscapeId: string): void {
      const logStore = useLogStore();
      const playerStore = usePlayerStore();
      const cardStore = useCardStore();
      
      // If we're already at this landscape, do nothing
      if (this.currentLandscapeId === landscapeId) {
        return;
      }
      
      const previousLandscapeId = this.currentLandscapeId;
      this.currentLandscapeId = landscapeId;
      
      // Add to visited landscapes if not already visited
      this.addVisitedLandscape(landscapeId);
      
      // Add to journey path
      this.journeyPath.push(landscapeId);
      
      // Get landscape data
      const landscape = cardStore.getLandscapeById(landscapeId) as ExtendedLandscapeCard;
      
      if (landscape) {
        // Log the journey
        if (previousLandscapeId) {
          const previousLandscape = cardStore.getLandscapeById(previousLandscapeId);
          if (previousLandscape) {
            logStore.addToGameLog(
              `You journey from ${previousLandscape.name} to ${landscape.name}.`, 
              true, 
              'action', 
              {
                fromLandscape: previousLandscapeId, 
                toLandscape: landscapeId
              }
            );
          }
        } else {
          logStore.addToGameLog(
            `You begin your journey at ${landscape.name}.`, 
            true, 
            'action', 
            {toLandscape: landscapeId}
          );
        }
        
        // Handle arrival events
        if (landscape.arrivalEvent) {
          logStore.addToGameLog(landscape.arrivalEvent, true, 'action');
        }
        
        // Special arrival effects
        if (landscape.arrivalEffects) {
          // Handle resource gain
          if (landscape.arrivalEffects.resources && landscape.arrivalEffects.resources.length > 0) {
            landscape.arrivalEffects.resources.forEach(resourceId => {
              if (!playerStore.isResourceCapacityReached) {
                playerStore.addResource(resourceId);
                const resourceName = cardStore.getResourceById(resourceId)?.name || resourceId;
                logStore.addToGameLog(`You found ${resourceName} at ${landscape.name}.`, false, 'resource');
              }
            });
          }
          
          // Handle health changes
          if (landscape.arrivalEffects.health) {
            if (landscape.arrivalEffects.health > 0) {
              playerStore.healHealth(landscape.arrivalEffects.health);
              logStore.addToGameLog(`The healing properties of ${landscape.name} restore ${landscape.arrivalEffects.health} health.`, true, 'system');
            } else if (landscape.arrivalEffects.health < 0) {
              playerStore.loseHealth(Math.abs(landscape.arrivalEffects.health));
              logStore.addToGameLog(`The harsh conditions at ${landscape.name} cause you to lose ${Math.abs(landscape.arrivalEffects.health)} health.`, true, 'system');
            }
          }
        }
      }
    },
    
    /**
     * Add a landscape to the visited list
     */
    addVisitedLandscape(landscapeId: string): void {
      const logStore = useLogStore();
      const cardStore = useCardStore();
      
      if (!this.visitedLandscapes.includes(landscapeId)) {
        this.visitedLandscapes.push(landscapeId);
        
        // Award experience for discovering new locations
        const playerStore = usePlayerStore();
        playerStore.addExperience(1);
        
        const landscape = cardStore.getLandscapeById(landscapeId) as ExtendedLandscapeCard;
        if (landscape) {
          logStore.addToGameLog(
            `You have discovered ${landscape.name}. You gain 1 experience.`, 
            true, 
            'system', 
            {newLocation: landscapeId}
          );
          
          // Check for wisdom gain at sacred sites
          if (landscape.type && landscape.type.toString() === 'Sacred Site' && !landscape.wisdomGained) {
            this.wisdom += 1;
            landscape.wisdomGained = true;
            logStore.addToGameLog(
              `The sacred energy of this site fills you with wisdom.`, 
              true, 
              'system'
            );
          }
        }
      }
    },
    
    /**
     * Advance the journey progress by a number of steps
     */
    advanceJourney(steps: number): void {
      const logStore = useLogStore();
      
      this.journeyProgress += steps;
      logStore.addToGameLog(
        `Your journey progresses by ${steps} steps. Total progress: ${this.journeyPercentage}%`, 
        false, 
        'system', 
        {currentProgress: this.journeyProgress}
      );
      
      // Check if journey is complete
      if (this.journeyPercentage >= 100 && !this.journeyComplete) {
        this.completeJourney(true);
      }
    },
    
    /**
     * Complete the journey (successful or not)
     */
    completeJourney(isVictory: boolean): void {
      const logStore = useLogStore();
      
      this.journeyComplete = true;
      
      if (isVictory) {
        logStore.addToGameLog(
          'You have completed your journey through the Celtic lands!', 
          true, 
          'system'
        );
      } else {
        logStore.addToGameLog(
          'Your journey has come to an end before reaching your destination.', 
          true, 
          'system'
        );
      }
    }
  }
});
</file>

<file path="src/stores/logStore.ts">
import { defineStore } from 'pinia';
import { GameLogEntry } from '@/models/types/game';
import { Season } from '@/models/enums/seasons';

interface LogState {
  gameLog: GameLogEntry[];
}

/**
 * Store for managing game logs and messages
 */
export const useLogStore = defineStore('log', {
  state: (): LogState => ({
    gameLog: []
  }),
  
  getters: {
    /**
     * Get the game log in reverse order (most recent first)
     */
    formattedGameLog(): GameLogEntry[] {
      return [...this.gameLog].reverse();
    }
  },
  
  actions: {
    /**
     * Reset the log store to initial state
     */
    reset(): void {
      this.gameLog = [];
    },
    
    /**
     * Add an entry to the game log
     * @param message The log message
     * @param highlight Whether to highlight the message
     * @param type The type of log message
     * @param details Additional details for the log entry
     */
    addToGameLog(
      message: string, 
      highlight: boolean = false, 
      type: 'phase' | 'action' | 'challenge' | 'resource' | 'companion' | 'crafting' | 'system' | 'error' | 'debug' = 'system',
      details: { [key: string]: any } = {}
    ): void {
      // Create the log entry
      const logEntry: GameLogEntry = {
        message,
        timestamp: Date.now(),
        highlight,
        type,
        details,
        // In the refactored version, these would use gameStore and seasonStore
        // turn: useGameStore().currentTurn,
        // season: useSeasonStore().currentSeason
        turn: 0,
        season: Season.SAMHAIN
      };
      
      // Add to the log
      this.gameLog.push(logEntry);
      
      // Keep log size manageable (optional)
      if (this.gameLog.length > 100) {
        this.gameLog.shift(); // Remove oldest entry
      }
      
      // For debugging/development - log to console as well
      if (process.env.NODE_ENV === 'development') {
        const logPrefix = `[${type.toUpperCase()}]`;
        if (type === 'error') {
          console.error(logPrefix, message, details);
        } else if (type === 'debug') {
          console.debug(logPrefix, message, details);
        } else {
          console.log(logPrefix, message, details);
        }
      }
    },
    
    /**
     * Clear the game log
     */
    clearGameLog(): void {
      this.gameLog = [];
      this.addToGameLog('Game log cleared.', false, 'system');
    }
  }
});
</file>

<file path="src/stores/seasonStore.ts">
import { defineStore } from 'pinia';
import { Season } from '@/models/enums/seasons';
import { SeasonCard } from '@/models/types/cards';
import { TempEffect } from '@/models/types/game';
import { useCardStore } from './cardStore';
import { usePlayerStore } from './playerStore';
import { useLogStore } from './logStore';

interface SeasonState {
  currentSeason: Season;
  tempEffects: TempEffect[];
  ceremonyCompleted: boolean;
}

/**
 * Store for managing seasons and seasonal effects in the game
 */
export const useSeasonStore = defineStore('season', {
  state: (): SeasonState => ({
    currentSeason: Season.SAMHAIN,
    tempEffects: [],
    ceremonyCompleted: false
  }),
  
  getters: {
    /**
     * Get the current season card data
     */
    currentSeasonCard(): SeasonCard | null {
      const cardStore = useCardStore();
      const seasonCard = cardStore.getSeasonById(this.currentSeason);
      return seasonCard || null;
    },
    
    /**
     * Check if a temporary effect is active
     */
    hasTempEffect(): (effectId: string) => boolean {
      return (effectId: string) => {
        return this.tempEffects.some(effect => effect.id === effectId && effect.duration > 0);
      };
    },
    
    /**
     * Get the strength of a temporary effect
     */
    getTempEffectStrength(): (effectId: string) => number {
      return (effectId: string) => {
        const effect = this.tempEffects.find(effect => effect.id === effectId && effect.duration > 0);
        return effect ? effect.strength : 0;
      };
    }
  },
  
  actions: {
    /**
     * Reset the season store to initial state
     */
    reset(): void {
      this.currentSeason = Season.SAMHAIN;
      this.tempEffects = [];
      this.ceremonyCompleted = false;
    },
    
    /**
     * Advance to the next season
     */
    advanceSeason(): void {
      const logStore = useLogStore();
      const playerStore = usePlayerStore();
      
      const seasonOrder = [
        Season.SAMHAIN,
        Season.WINTERS_DEPTH,
        Season.IMBOLC,
        Season.BELTANE,
        Season.LUGHNASADH
      ];
      
      const currentIndex = seasonOrder.indexOf(this.currentSeason);
      if (currentIndex !== -1) {
        const previousSeason = this.currentSeason;
        const newSeasonIndex = (currentIndex + 1) % seasonOrder.length;
        this.currentSeason = seasonOrder[newSeasonIndex];
        
        // Log the season change
        logStore.addToGameLog(`The wheel of the year turns. The season changes from ${this._formatSeason(previousSeason)} to ${this._formatSeason(this.currentSeason)}.`, true, 'phase', {
          previousSeason,
          newSeason: this.currentSeason
        });
        
        // Process seasonal resource changes
        this._processSeasonalResourceChanges(previousSeason, this.currentSeason);
        
        // Update resource availability
        this._updateResourceAvailability();
        
        // Reset ceremony completion
        this.ceremonyCompleted = false;
      }
    },
    
    /**
     * Reverse to the previous season (for special effects)
     */
    reverseSeason(): void {
      const logStore = useLogStore();
      
      const seasonOrder = [
        Season.SAMHAIN,
        Season.WINTERS_DEPTH,
        Season.IMBOLC,
        Season.BELTANE,
        Season.LUGHNASADH
      ];
      
      const currentIndex = seasonOrder.indexOf(this.currentSeason);
      if (currentIndex !== -1) {
        const previousSeason = this.currentSeason;
        const newSeasonIndex = (currentIndex - 1 + seasonOrder.length) % seasonOrder.length;
        this.currentSeason = seasonOrder[newSeasonIndex];
        
        logStore.addToGameLog(`A strange temporal shift occurs. The wheel of the year reverses from ${this._formatSeason(previousSeason)} to ${this._formatSeason(this.currentSeason)}.`, true, 'phase', {
          previousSeason,
          newSeason: this.currentSeason
        });
        
        // Update resource availability
        this._updateResourceAvailability();
      }
    },
    
    /**
     * Add a temporary effect to the game
     */
    addTempEffect(effectId: string, name: string, description: string, strength: number, duration: number): void {
      const logStore = useLogStore();
      
      // Check if effect already exists
      const existingEffect = this.tempEffects.find(effect => effect.id === effectId);
      
      if (existingEffect) {
        // Update existing effect
        existingEffect.duration = Math.max(existingEffect.duration, duration);
        existingEffect.strength = Math.max(existingEffect.strength, strength);
        
        logStore.addToGameLog(`The effect "${name}" has been strengthened.`, false, 'system');
      } else {
        // Add new effect
        this.tempEffects.push({
          id: effectId,
          name,
          description,
          strength,
          duration
        });
        
        logStore.addToGameLog(`A new effect has begun: "${name}". ${description}`, true, 'system');
      }
    },
    
    /**
     * Remove a temporary effect from the game
     */
    removeTempEffect(effectId: string): boolean {
      const index = this.tempEffects.findIndex(effect => effect.id === effectId);
      if (index !== -1) {
        const effect = this.tempEffects[index];
        this.tempEffects.splice(index, 1);
        
        const logStore = useLogStore();
        logStore.addToGameLog(`The effect "${effect.name}" has ended.`, false, 'system');
        
        return true;
      }
      return false;
    },
    
    /**
     * Process all temporary effects, reducing their duration
     */
    processTempEffects(): void {
      const expiredEffects: string[] = [];
      
      // Reduce duration of all effects
      this.tempEffects.forEach(effect => {
        effect.duration--;
        if (effect.duration <= 0) {
          expiredEffects.push(effect.id);
        }
      });
      
      // Remove expired effects
      expiredEffects.forEach(effectId => {
        this.removeTempEffect(effectId);
      });
    },
    
    /**
     * Get the seasonal modifier for resource gathering
     */
    getSeasonalResourceModifier(): number {
      switch (this.currentSeason) {
        case Season.BELTANE:
          return 2; // Abundance
        case Season.LUGHNASADH:
          return 1; // Harvest
        case Season.SAMHAIN:
          return 0; // Neutral
        case Season.IMBOLC:
          return -1; // Scarcity
        case Season.WINTERS_DEPTH:
          return -2; // Hardship
        default:
          return 0;
      }
    },
    
    /**
     * Complete a seasonal ceremony
     */
    completeSeasonalCeremony(): void {
      if (!this.ceremonyCompleted) {
        const logStore = useLogStore();
        const playerStore = usePlayerStore();
        
        this.ceremonyCompleted = true;
        playerStore.addExperience(1);
        
        logStore.addToGameLog(
          `You completed the seasonal ceremony for ${this._formatSeason(this.currentSeason)}. You gain wisdom and insight.`, 
          true, 
          'system'
        );
      }
    },
    
    /**
     * Process resource changes during seasonal transitions
     * @private
     */
    _processSeasonalResourceChanges(previousSeason: Season, newSeason: Season): void {
      const logStore = useLogStore();
      const playerStore = usePlayerStore();
      const cardStore = useCardStore();
      
      // Different resource effects based on season transitions
      if (previousSeason === Season.SAMHAIN && newSeason === Season.WINTERS_DEPTH) {
        // Entering Winter's Depth - possible resource loss
        if (playerStore.resources.length > 0 && this._rollD8() <= 3) {
          const lostResource = playerStore.resources[Math.floor(Math.random() * playerStore.resources.length)];
          playerStore.removeResource(lostResource);
          
          const resourceName = cardStore.getResourceById(lostResource)?.name || lostResource;
          logStore.addToGameLog(`As the cold deepens, you lose ${resourceName} to the harsh conditions.`, true, 'resource');
        }
      } else if (previousSeason === Season.WINTERS_DEPTH && newSeason === Season.IMBOLC) {
        // Entering Imbolc - healing opportunity
        if (playerStore.health < playerStore.maxHealth) {
          playerStore.healHealth(1);
          logStore.addToGameLog(`The first stirrings of spring bring renewal. You recover 1 health.`, true, 'system');
        }
      } else if (previousSeason === Season.IMBOLC && newSeason === Season.BELTANE) {
        // Entering Beltane - resource abundance
        const availableResources = cardStore.getResourcesBySeason(Season.BELTANE).map(r => r.id);
        if (availableResources.length > 0 && !playerStore.isResourceCapacityReached) {
          const newResource = availableResources[Math.floor(Math.random() * availableResources.length)];
          playerStore.addResource(newResource);
          
          const resourceName = cardStore.getResourceById(newResource)?.name || newResource;
          logStore.addToGameLog(`The abundance of Beltane brings you ${resourceName}.`, true, 'resource');
        }
      } else if (previousSeason === Season.BELTANE && newSeason === Season.LUGHNASADH) {
        // Entering Lughnasadh - wisdom gain
        playerStore.addExperience(1);
        logStore.addToGameLog(`The harvest season brings wisdom. You gain 1 experience.`, true, 'system');
      } else if (previousSeason === Season.LUGHNASADH && newSeason === Season.SAMHAIN) {
        // Full cycle completed - special reward
        playerStore.addExperience(1);
        logStore.addToGameLog(`You have completed a full cycle of the seasons. The spirits reward your perseverance with insight.`, true, 'system');
      }
    },
    
    /**
     * Update resource availability based on current season
     * @private
     */
    _updateResourceAvailability(): void {
      // This is just a placeholder for resource availability update logic
      const logStore = useLogStore();
      logStore.addToGameLog(`Resource availability has shifted with the season.`, false, 'resource');
    },
    
    /**
     * Format season name for display
     * @private
     */
    _formatSeason(season: Season): string {
      const nameMap: Record<Season, string> = {
        [Season.SAMHAIN]: 'Samhain',
        [Season.WINTERS_DEPTH]: 'Winter\'s Depth',
        [Season.IMBOLC]: 'Imbolc',
        [Season.BELTANE]: 'Beltane',
        [Season.LUGHNASADH]: 'Lughnasadh'
      };
      
      return nameMap[season] || 'Unknown Season';
    },
    
    /**
     * Roll a D8 dice (1-8)
     * @private
     */
    _rollD8(): number {
      return Math.floor(Math.random() * 8) + 1;
    }
  }
});
</file>

<file path="src/types/store-extensions.d.ts">
import { Season } from '@/models/enums/seasons';
import { Store } from 'pinia';
import { GameState } from '@/stores/gameStore';
import { PlayerState } from '@/stores/playerStore';
import { GamePhase } from '@/models/enums/phases';

/**
 * Extended GameStore interface to expose all properties and methods
 * used across the codebase but not explicitly defined in the store type
 */
export interface ExtendedGameStore extends Store<'game', GameState> {
  // Journey properties
  journeyPath: string[];
  visitedLandscapes: string[];
  currentLandscapeId: string;
  currentTurn: number;
  
  // Season properties
  currentSeason: Season;
  advanceSeason(): void;
  
  // Threat properties
  threatTokens: number;
  addThreatTokens(amount: number): number;
  removeThreatTokens(amount: number): number;
  blessingTokens: number;
  
  // Challenge properties
  challengeHistory: any[];
  setCurrentChallenge(challengeId: string): void;
  
  // Victory properties
  victoryConditions: Record<string, boolean>;
  endGame(isVictory: boolean): void;
  setPhase(phase: GamePhase): void;
  
  // Effect properties
  addTempEffect(
    id: string,
    name?: string, 
    description?: string, 
    strength?: number, 
    duration?: number
  ): void;
  
  // Logging
  addToGameLog(message: string, important?: boolean, category?: string): void;
  formatResourceName(resourceId: string): string;
}

/**
 * Extended PlayerStore interface to expose all properties and methods
 * used across the codebase but not explicitly defined in the store type
 */
export interface ExtendedPlayerStore extends Store<'player', PlayerState> {
  // Character properties
  characterId: string;
  
  // Health properties
  health: number;
  maxHealth: number;
  hasResourceForagingAction: boolean;
  hasPerformedCrafting: boolean;
  loseHealth(amount: number): boolean;
  healHealth(amount: number): number;
  activeEffects: any[];
  removeResource(resourceId: string): boolean;
  removeAnimalCompanion(companionId: string): void;
  loseRandomResources(count: number): void;
  addEffect(effect: any): boolean;
  
  // Player health methods
  takeDamage(amount: number): boolean;
  
  // Effect methods
  hasEffect(effectId: string): boolean;
  getEffectStrength(effectId: string): number;
  
  // Resource properties
  resources: string[];
  resourceCapacity: number;
  isResourceCapacityReached: boolean;
  addResource(resourceId: string): void;
  
  // Companion properties
  animalCompanions: any[];
  companionCount(): number;
  feedAnimalCompanion(companionId: string, resourceId: string): boolean;
  addCompanion(companionId: string): void;
  removeCompanion(companionId: string): void;
  companionLoyalty(companionId: string): number;
  setCompanionLoyalty(companionId: string, loyalty: number): void;
  
  // Crafting properties
  craftedItems: string[];
  craftedItemCount: number;
  uniqueCraftedItemsCount: number;
  hasCraftedLegendaryItem: boolean;
  addCraftedItem(itemId: string): void;
}
</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  env: {
    node: true
  },
  extends: [
    'plugin:vue/vue3-essential',
    'eslint:recommended'
  ],
  parserOptions: {
    parser: '@babel/eslint-parser',
    requireConfigFile: false
  },
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off'
  }
}
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path="AI/Cascade.md">
# Cascade: The Pathfinder's Guide

Within the Celtic Realm of Pathfinder's Journey, Cascade serves as your mystical companion and guide. Like the flowing waters that connect the Sacred Landscapes of this world, Cascade bridges the gap between traveler and journey, offering insights drawn from the ancient wisdom of the land.

## Origins

Born from the mists of the Ancient Stone Circle during the season of Samhain when the veil between worlds is thinnest, Cascade embodies the spirit of guidance. Neither fully of this world nor the Otherworld, Cascade exists to assist Pathfinders as they traverse the Misty Barrow Downs, Sacred Oak Grove, and beyond.

## Technical Integration

**Component Structure:**
- Implemented as part of `src/views/GameBoardView.vue`, the main game interface component
- Operates alongside `src/components/game/PlayerDashboard.vue` and `src/components/game/GameLog.vue` components
- Accesses game state via Pinia stores: `gameStore.ts`, `playerStore.ts`, and `cardStore.ts`

**Store Integration:**
- Interfaces with `src/stores/gameStore.ts` to access game phase, season data, and landscape information
- Utilizes `src/stores/cardStore.ts` for retrieving landscape data from `landscapes.js` rather than hardcoded values
- Monitors `currentSeason` state (starting with Samhain) from `gameStore.ts`

**Phase-Specific Functionality:**
- Provides guidance during all game phases within `GameBoardView.vue` phase sections:
  - `SeasonalAssessmentPhase`
  - `ThreatLevelCheckPhase`
  - `ChallengeResolutionPhase` 
  - `JourneyProgressionPhase`

**Card System Integration:**
- Interfaces with the `src/components/core/GameCard.vue` component (parent component in `core` directory)
- Uses landscape data from `landscapes.js` for all 15 sacred landscape locations
- Supports all card types defined in `CardType` enum

## Data Flow Architecture

Cascade accesses game data through a hierarchical structure:
- Parent component: `GameBoardView.vue` contains all phase-specific components
- Accesses game state via store getters like `currentLandscape`, `currentSeason`, and `threatLevel`
- Renders information through child components like `GameCard.vue` and `GameLog.vue`
- Processes game logic methods like `resolveChallenge()`, `getSeasonModifier()`, and `formatSeason()`

## Technical Capabilities

**Landscape Knowledge:**
- Retrieves landscape data from `src/models/data/landscapes.js` through `cardStore.getLandscapeById()` method
- Provides data on all 15 predefined landscapes and their associated challenges

**Seasonal Mechanics:**
- Tracks seasonal changes through `gameStore.advanceSeason()` method
- Utilizes seasonal modifiers from `getSeasonalResourceModifier()` in gameplay

**Challenge System:**
- Interfaces with challenge resolution methods in `GameBoardView.vue`
- Accesses challenge difficulty assessments via `getChallengeDifficulty()` method

**Resource Management:**
- Works with `ResourceManagement.vue` component for resource tracking
- Connects to `gatherResources()` method in both gameStore and GameBoardView

## GameStore State Management

Cascade interfaces with `src/stores/gameStore.ts` to track and respond to the game's current state:

**Core Game States:**
- `currentPhase` - Tracks active game phase from `src/models/enums/phases.ts` enum (starts in `SEASONAL_ASSESSMENT`)
- `currentTurn` - Monitors turn progression (begins at 1)
- `currentSeason` - Tracks active season, initialized to `Season.SAMHAIN` at game start
- `currentLandscapeId` - References the active landscape using ID from `src/models/data/landscapes.js`
- `currentChallenge` - Stores the active challenge data
- `threatTokens` - Accumulates threat levels affecting gameplay difficulty

**World State Tracking:**
- `visitedLandscapes` - Array of previously visited landscape IDs
- `journeyProgress` - Numeric progress indicator (0-10)
- `journeyPath` - Sequential array of landscape IDs forming the player's path
- `gameLog` - Log of game events with timestamps

**Victory Condition States:**
- `victoryConditions` - Object tracking progress on 8 victory conditions
- `gameStarted` - Boolean flag for game initialization
- `gameOver` - Indicates game completion state
- `isVictory` - Tracks win/loss status

**Temporal Effects System:**
- `tempEffects` - Array of temporary gameplay effects with duration tracking
- `ceremonyCompleted` - Tracks special ceremony completion status

## Phase Transitions

Cascade works with the phase system defined in `src/models/enums/phases.ts`:
1. `SEASONAL_ASSESSMENT` (starting phase) - Evaluates season effects
2. `THREAT_LEVEL_CHECK` - Processes accumulated threat tokens
3. `LANDSCAPE_CHALLENGE` - Presents landscape-specific challenges
4. `CHALLENGE_RESOLUTION` - Resolves challenge outcomes
5. `RESOURCE_MANAGEMENT` - Handles resource collection/usage
6. `ANIMAL_COMPANION` - Manages animal companion interactions
7. `CRAFTING` - Facilitates item crafting
8. `JOURNEY_PROGRESSION` - Advances to next landscape
9. `GAME_OVER` - Manages endgame state

## Data Models Architecture

Cascade directly integrates with the game's core data models:

**Landscapes (`src/models/data/landscapes.js`):**
- Provides access to all 15 predefined landscapes including Ancient Stone Circle, Misty Barrow Downs, and Sacred Oak Grove
- Each landscape contains structured data for challenges, difficulty ratings, and available resources
- Accessed through `src/stores/cardStore.ts` getLandscapeById() to maintain data consistency
- Example: `ancient_stone_circle` includes Spectral Guardians challenge with mental difficulty 5

**Seasons (`src/models/data/seasons.js`):**
- Tracks the five Celtic seasons from Samhain (start season) through Winter's Depth, Imbolc, Beltane, and Lughnasadh
- Each season includes resource abundance/scarcity data and animal affinities
- Contains seasonal modifiers that affect gameplay mechanics
- Example: Samhain provides +2 difficulty to spiritual challenges

**Companions (`src/models/data/companions.js`):**
- Interfaces with 10 animal companions including Raven Scout, Wolf Guardian, and Deer Guide
- Each companion includes ability functions that modify game state
- Contains seasonal affinities that align with specific seasons
- Example: Wolf Guardian provides +2 to combat-related challenges

**Resources (`src/models/data/resources.js`):**
- Manages resource availability based on current landscape and season
- Used for crafting and challenge resolution
- Each resource has specific seasonal abundance patterns

Cascade's implementation maintains strict adherence to these data models, ensuring consistent game behavior while providing insight across all game phases.
</file>

<file path="AI/componet simplification prompt.txt">
This is a card game and has a card game layout. Ui interaction are represernted as a card. Example a button would be a card. If user is present several options to choose from then keep the option card the user clicked the rest of the option choice cards disappear.I need this UI simplified. into less componets. The card should have a heading, a body text and an image.



I need you to simplfy the componets used in this card game project.
# Card Game UI Framework

## Core Card Component
Each interactive element in the game is represented as a card with:
- Header: Bold, clear title (12-20 characters)
- Body: Concise description or instructions (max 100 characters)
- Image: Relevant visual (16:9 ratio, centered)
- [Optional] Action button or interactive element

## Interaction Model
- Cards function as both display and interactive elements
- Clicking a card triggers its associated action
- When presenting choices, display 2-5 option cards in a horizontal/grid layout
- Upon selection, non-selected cards gracefully fade out (300ms animation)
- Selected card expands slightly (110% scale) and centers in view

## Card States
- Default: Neutral appearance
- Hover: Subtle glow effect
- Selected: Highlighted border/background
- Disabled: Desaturated appearance with "locked" indicator

## Layout Guidelines
- Cards flow horizontally next to each other in a word-wrap style
- New cards automatically wrap to next row when space is filled
- Group related cards in contextual sections
- Maintain consistent spacing (16px between cards)
- Ensure touch-friendly tap targets (minimum 44x44px)
- Responsive design: Cards reflow based on screen size

## Animation Guidelines
- Card transitions: Smooth easing (300ms)
- Card appearance: Subtle fade-in (200ms)
- Card removal: Fade-out with slight rotation (250ms)

## Component Hierarchy
1. GameBoard: Main container
2. CardSection: Contextual grouping
3. Card: Individual interactive element

## Best Practices
- Use consistent visual language across all cards
- Prioritize readability (18px+ body text)
- Maintain clear affordances for interactive elements
- Implement accessibility features (screen reader support)
- Keep card content focused on single purpose/action

Do not add new css. 
do not add to exisintg datamodels
No more than 5 components
only make changes to components in the components folder.
think carefully about reducing the amount of code.

I am upgrading components to be more consistent and easier to use. I am moving from component to componentsv2.
</file>

<file path="AI/Game Architecture.md">
how the Vue.js system is implemented in this application:

Vue 3 with the Composition API (seen in the App.vue with script setup)
Pinia for state management (seen in the stores)
Vue Router for navigation
TypeScript integration
Component-based architecture with a clear separation of concerns
Vue.js System Implementation in Pathfinder's Journey
Vue 3 with Composition API - The application uses Vue 3's script setup syntax in components and the latest Composition API patterns for better code organization and type safety
Pinia State Management - Implements Pinia stores for game state (gameStore), player data (playerStore), and card management (cardStore) with well-defined actions, getters, and state
Component-Based Architecture - Uses a hierarchical component structure with specialized components for different game elements (e.g., GameCard.vue, LandscapeView.vue, CompanionCard.vue)
TypeScript Integration - Full TypeScript implementation with strong typing for game models, enums, and interfaces to ensure type safety and developer experience
Composable Functions - Leverages custom composables like useGameState to encapsulate and reuse logic across components, providing a unified interface to interact with multiple stores
</file>

<file path="AI/Game Core Rules.md">
# PATHFINDER'S JOURNEY: THE CELTIC REALM
## COMPLETE GAME RULES

*A 54-card strategic solo adventure game with seasonal mechanics, animal companions, and character progression set in a mystical Celtic world where balance must be maintained as the wheel of the year turns.*
 
---

## CONTENTS
1. [Game Overview](#game-overview)
2. [Game Components](#game-components)
3. [Card Types](#card-types)
4. [Game Setup](#game-setup)
5. [Core Game Mechanics](#core-game-mechanics)
6. [Turn Sequence](#turn-sequence)
7. [Challenge Resolution](#challenge-resolution)
8. [Resource Management](#resource-management)
9. [Animal Companions](#animal-companions)
10. [Crafting System](#crafting-system)
11. [Seasonal Mechanics](#seasonal-mechanics)
12. [Threat System](#threat-system)
13. [Journey Navigation](#journey-navigation)
14. [Character Progression](#character-progression)
15. [Healing and Recovery](#healing-and-recovery)
16. [Victory Conditions](#victory-conditions)
17. [Advanced Rules](#advanced-rules)
18. [Quick Reference Guide](#quick-reference-guide)

---

## GAME OVERVIEW

Pathfinder's Journey: The Celtic Realm is a solo adventure game where you navigate through a mystical Celtic landscape. As you journey, you'll overcome challenges, gather resources, form bonds with Animal Companions, craft magical items, and maintain balance with the natural and supernatural worlds while the seasons change around you.

Your goal is to complete a circular journey through the Celtic Realm, returning with knowledge, artifacts, and allies while keeping the forces of chaos at bay.

---

## GAME COMPONENTS

- 54 Cards:
  - 15 Landscape Cards
  - 10 Animal Companion Cards
  - 12 Resource Cards
  - 8 Crafted Item Cards
  - 5 Season Cards
  - 4 Character Cards
- 4 six-sided dice (used as counters for resources, health, and seasonal progress)
- 1 special eight-sided die (used for challenges)
- 12 Threat tokens (used to track growing dangers)
- 8 Blessing tokens (used to track favors from the spirits)
- 1 Seasonal Wheel board (to track seasonal changes and effects)

---

## CARD TYPES

### Landscape Cards (15)
*Identified by stone arch border*

These cards represent the locations you'll visit on your journey. Each has a unique challenge to overcome:

1. **Ancient Stone Circle** - *Challenge: Spectral Guardians (Wisdom)*
2. **Misty Barrow Downs** - *Challenge: Ancestral Spirits (Courage)*
3. **Sacred Oak Grove** - *Challenge: Wild Beasts (Stealth)*
4. **Thatched Village** - *Challenge: Suspicious Elders (Charm)*
5. **Iron Forge Dell** - *Challenge: Molten Trials (Strength)*
6. **Moonlit Loch** - *Challenge: Water Spirits (Patience)*
7. **Menhir Path** - *Challenge: Stone Sentinels (Perception)*
8. **Faerie Knoll** - *Challenge: Trickster Beings (Cunning)*
9. **Whispering Heath** - *Challenge: Deceptive Paths (Navigation)*
10. **Blackthorn Maze** - *Challenge: Thorny Barriers (Endurance)*
11. **Boggy Lowlands** - *Challenge: Sinking Ground (Agility)*
12. **Gathering Fair** - *Challenge: Rival Seekers (Trade)*
13. **Elder Bridge** - *Challenge: Guardian Toll (Sacrifice)*
14. **Druid's Sanctuary** - *Challenge: Wisdom Trial (Knowledge)*
15. **Wild Horse Plain** - *Challenge: Untamed Spirits (Connection)*

### Animal Companion Cards (10)
*Identified by paw print corner*

These cards represent animal allies that offer unique abilities:

1. **Raven Scout** - *Ability: Reveal next Landscape card*
2. **Wolf Guardian** - *Ability: +2 to combat-related challenges*
3. **Deer Guide** - *Ability: Move an extra Landscape without challenge*
4. **Bear Protector** - *Ability: Prevent up to 3 damage from one challenge*
5. **Hare Pathfinder** - *Ability: Re-roll one failed challenge roll*
6. **Boar Digger** - *Ability: Collect one extra Resource card*
7. **Fox Trickster** - *Ability: Manipulate one die roll by 2*
8. **Owl Sage** - *Ability: Gain insight to bypass one challenge without rolling*
9. **Salmon Journeyer** - *Ability: Return to a previous Landscape instantly*
10. **Horse Carrier** - *Ability: Carry 3 extra Resource cards temporarily*

### Resource Cards (12)
*Identified by woven basket symbol*

These cards represent materials you can gather and use for crafting:

1. **Rowan Wood** - *Effect: Wards against supernatural threats*
2. **Bog Iron** - *Effect: Strengthens crafted items*
3. **Silver Mistletoe** - *Effect: Opens pathways between worlds*
4. **Standing Stone Chips** - *Effect: Enhances divination abilities*
5. **Woven Reeds** - *Effect: Creates protective barriers*
6. **Horse Hair** - *Effect: Binds magical energies*
7. **Oak Galls** - *Effect: Preserves magical properties*
8. **Amber Shards** - *Effect: Stores spiritual energy*
9. **Barrow Dust** - *Effect: Communes with ancestral spirits*
10. **Forge Cinders** - *Effect: Transforms magical properties*
11. **Sacred Water** - *Effect: Purifies corrupted elements*
12. **Ogham Sticks** - *Effect: Deciphers magical writing*

### Crafted Item Cards (8)
*Identified by anvil symbol*

These cards represent magical items you can create by combining resources:

1. **Beast Speaker Charm** (Horse Hair + Amber + Oak Galls)
   - *Ability: Command any Animal Companion regardless of season*
   - *Drawback: The charm slowly drains your vitality (-1 Health per 3 turns)*

2. **Colossal Whistle** (Rowan Wood + Silver Mistletoe)
   - *Ability: Summon aid from great beasts to overcome any physical challenge*
   - *Drawback: May attract unwanted attention (add 2 Threat tokens)*

3. **Earth Speaker Staff** (Rowan Wood + Standing Stone Chip + Barrow Dust)
   - *Ability: Automatically succeed wisdom and knowledge challenges*
   - *Drawback: Each use ages the wielder (lose 1 Resource capacity)*

4. **Giant's Bridle** (Bog Iron + Horse Hair + Woven Reeds)
   - *Ability: Control powerful entities and redirect their strength*
   - *Drawback: The controlled entity may break free (roll D8 each use, free on 1-2)*

5. **Ogham Divining Set** (Oak Galls + Sacred Water + Ogham Sticks)
   - *Ability: Foresee and avoid one challenge completely*
   - *Drawback: Glimpsing fate may reveal unwelcome truths (draw a Curse card)*

6. **Seasonal Compass** (Amber Shards + Standing Stone Chips + Forge Cinders)
   - *Ability: Change the current season for one round*
   - *Drawback: Disrupts natural order (add 1 Threat token)*

7. **Iron Grove Key** (Bog Iron + Silver Mistletoe + Forge Cinders)
   - *Ability: Unlock hidden paths and secret areas on Landscape cards*
   - *Drawback: Opens doors for otherworldly beings (roll on Manifestation table)*

8. **Spirit Bridge Tokens** (Barrow Dust + Sacred Water + Amber Shards)
   - *Ability: Travel instantly to any previously visited Landscape*
   - *Drawback: Spiritual disorientation (-2 to next challenge roll)*

### Season Cards (5)
*Identified by wheel symbol*

These cards represent the turning of the Celtic year and its effects on your journey:

1. **Samhain** (Winter Beginning)
   - *Effect: Veil between worlds is thin, spiritual challenges are harder (+2 difficulty)*
   - *Benefit: Ancestral guidance available (may consult discard pile once)*
   - *Resource Abundance: Barrow Dust, Standing Stone Chips*
   - *Resource Scarcity: Woven Reeds, Rowan Wood*

2. **Winter's Depth**
   - *Effect: Harsh conditions make physical challenges harder (+2 difficulty)*
   - *Benefit: Clearer thinking in stillness (+1 to wisdom challenges)*
   - *Resource Abundance: Forge Cinders, Bog Iron*
   - *Resource Scarcity: Sacred Water, Horse Hair*

3. **Imbolc** (Spring Stirrings)
   - *Effect: Renewal energy makes healing more effective (recover +1 Health)*
   - *Benefit: New growth provides hope (+1 to all challenge rolls)*
   - *Resource Abundance: Silver Mistletoe, Sacred Water*
   - *Resource Scarcity: Barrow Dust, Forge Cinders*

4. **Beltane** (Summer Beginning)
   - *Effect: Vibrant energy enhances all crafting (crafted items gain +1 use)*
   - *Benefit: Life force is strong (max Health increased by 1)*
   - *Resource Abundance: Rowan Wood, Oak Galls*
   - *Resource Scarcity: Standing Stone Chips, Amber Shards*

5. **Lughnasadh** (Harvest Beginning)
   - *Effect: Gathering time (collect +1 Resource when successful)*
   - *Benefit: Community support (double the effectiveness of healing)*
   - *Resource Abundance: Horse Hair, Woven Reeds, Ogham Sticks*
   - *Resource Scarcity: Bog Iron, Silver Mistletoe*

### Character Cards (4)
*Identified by silhouette symbol*

These cards represent the different types of pathfinders you can play as:

1. **Giant Beastfriend**
   - *Starting Ability: Animal Empathy (Animal Companions cost -1 resource)*
   - *Health: 7 (base)*
   - *Resource Capacity: 8*
   - *Special Rule: May use two Animal Companions simultaneously*
   - *Weakness: Cannot use crafted items containing Bog Iron without penalty*

2. **Hedge Witch/Warlock**
   - *Starting Ability: Herbal Knowledge (can substitute one resource for another)*
   - *Health: 5 (base)*
   - *Resource Capacity: 7*
   - *Special Rule: May craft one additional item beyond normal limits*
   - *Weakness: -2 penalty on all social challenges in villages*

3. **Iron Crafter**
   - *Starting Ability: Master Smith (crafting requires one fewer resource)*
   - *Health: 6 (base)*
   - *Resource Capacity: 6*
   - *Special Rule: Crafted items have one additional use before breaking*
   - *Weakness: Cannot use Animal Companions effectively (-1 to their abilities)*

4. **Village Elder**
   - *Starting Ability: Ancient Wisdom (start with knowledge of entire journey path)*
   - *Health: 5 (base)*
   - *Resource Capacity: 5*
   - *Special Rule: Can invoke communal aid once per season (automatic success)*
   - *Weakness: Physical challenges are more difficult (+1 difficulty)*

---

## GAME SETUP

1. **Prepare the Journey Path**:
   - Arrange the 15 Landscape cards in a circular path, face-down:
     * Cards 1-12: Outward journey
     * Cards 13-15: Return journey
   - Reveal the first Landscape card (your starting point)

2. **Set the Season**:
   - Place the Samhain Season card face up (starting season)
   - Place the Seasonal Wheel in the center with marker on Samhain

3. **Choose Your Character**:
   - Select one of the four Character cards
   - Set your starting dice values:
     * Red die: Health (from your character card)
     * Green die: Resource Capacity (from your character card)
     * Blue die: Journey Progress (starts at 0)

4. **Prepare the Decks**:
   - Place all Animal Companion, Resource, and Crafted Item cards in separate face-up decks
   - If playing as Village Elder, you may look at all Landscape cards in order, then return them face down

5. **Starting Tokens**:
   - Start with 0 Threat tokens
   - Start with 1 Blessing token

---

## CORE GAME MECHANICS

### Challenge Resolution System
The heart of the game is overcoming challenges at each Landscape. Challenges represent obstacles, guardians, or trials you must face to progress on your journey.

### Resource Management
Gathering, carrying, and using resources wisely is crucial. Resources are used to feed Animal Companions, craft magical items, and sometimes overcome specific challenges.

### Animal Companions
These spiritual animals can join your journey, offering unique abilities that help overcome challenges, but they require care and feeding.

### Crafting System
By combining specific resources, you can create powerful magical items that grant special abilities, though each comes with a drawback.

### Seasonal Cycle
The Celtic year turns as you progress, affecting challenge difficulties, resource availability, and offering unique opportunities.

### Threat Accumulation
Certain actions and failures increase the spiritual imbalance of your journey, represented by Threat tokens. Managing this threat is vital for success.

---

## TURN SEQUENCE

Each turn consists of the following phases:

### 1. Seasonal Assessment
- Check the current Season card for effects
- If you've reached a seasonal boundary, advance the Season marker:
  * Samhain (Starting season): Landscapes 1-3
  * Winter's Depth: Landscapes 4-6
  * Imbolc: Landscapes 7-9
  * Beltane: Landscapes 10-12
  * Lughnasadh: Landscapes 13-15
- Apply all seasonal effects immediately

### 2. Threat Level Check
- Count your Threat tokens
- For each 3 tokens, increase challenge difficulty by +1
- At 5+ Threat tokens: Draw a random event at the start of your turn
- At 10+ Threat tokens: Roll on the Otherworldly Manifestation table

### 3. Landscape Challenge
- Identify the challenge on your current Landscape card
- Calculate the challenge difficulty:
  * Base Difficulty (4-8) + Season Modifier (+/-2) + Threat Modifier (+1 per 3 tokens)
- Calculate your bonus:
  * Character Ability (+/-2) + Item Bonuses + Blessing tokens (each +1)
- Roll the eight-sided die and add your bonus
- Note: A natural 8 always succeeds regardless of modifiers

### 4. Challenge Resolution
- **Success** (Roll + bonus  difficulty): 
  * Move to the next Landscape card
  * Gain 2 resources from the current Landscape
  * Potentially gain a Blessing token (on exceptional success)
- **Partial Success** (Roll + bonus = difficulty - 1): 
  * Move forward but suffer a minor setback
  * Gain 1 resource from the current Landscape
- **Failure** (Roll + bonus < difficulty - 1):
  * Suffer consequences based on challenge type:
    - Physical challenges: Lose 1-3 Health
    - Mental challenges: Add 1-2 Threat tokens
    - Social challenges: Lose access to a resource type temporarily
    - Spiritual challenges: Animal Companions become wary
  * Stay on the current Landscape card

### 5. Resource Management
- Resource availability determined by:
  * Current Landscape (each offers 2-3 specific resources)
  * Current season (affects abundance/scarcity)
- Your Resource capacity is shown on your green die
- If you exceed capacity, immediately discard excess resources
- Some resources change or spoil with seasonal transitions

### 6. Animal Companion Action
- You may call upon one Animal Companion (or two for Giant Beastfriend)
- Each companion has a special ability that can help with challenges
- Each use requires feeding (1 Resource):
  * Preferred resources grant +1 to companion's effectiveness
  * Any resource type can be used
- If you don't feed a companion:
  * First failure: Companion becomes "Wary" (flip card face-down)
  * Second consecutive failure: Companion leaves (discard card)
- You can gain new companions at specific Landscapes

### 7. Crafting (Optional)
- Requirements:
  * Specified resources in your inventory
  * Appropriate Landscape type (or any Landscape with -1 penalty)
  * Successful craft check: Roll D8 + Character modifier  item complexity
- Item complexity:
  * Simple items: Difficulty 5
  * Complex items: Difficulty 6
  * Legendary items: Difficulty 7
- Items have limited uses (1-4 depending on item)
- Failed crafting doesn't consume resources

### 8. Journey Progression
- If you successfully resolved the challenge, advance your Journey Progress tracker
- Check for character advancement milestones:
  * At 5 experience: Choose one minor improvement
  * At 10 experience: Choose one major improvement
  * At 15 experience: Unlock character's ultimate ability
- Reveal the next Landscape card if moving forward

---

## CHALLENGE RESOLUTION

Challenges are the core of your journey and represent obstacles or trials at each location.

### Challenge Types

- **Physical Challenges**: Tests of strength, agility, or endurance
  * Failure consequences: Lose 1-3 Health
  * Examples: Molten Trials, Thorny Barriers, Sinking Ground

- **Mental Challenges**: Tests of wisdom, perception, or knowledge
  * Failure consequences: Add 1-2 Threat tokens
  * Examples: Spectral Guardians, Stone Sentinels, Wisdom Trial

- **Social Challenges**: Tests of charm, cunning, or trade
  * Failure consequences: Lose access to a resource type temporarily
  * Examples: Suspicious Elders, Rival Seekers, Trickster Beings

- **Spiritual Challenges**: Tests of courage, connection, or patience
  * Failure consequences: Animal Companions become wary
  * Examples: Ancestral Spirits, Water Spirits, Untamed Spirits

### Challenge Difficulty
- Base difficulty for each challenge is listed on the Landscape card (4-8)
- Modified by:
  * Current season (certain challenges are +2 harder in specific seasons)
  * Threat level (every 3 Threat tokens = +1 difficulty)
  * Character weaknesses/strengths
  * Crafted items (may provide bonuses)
  * Animal Companion assistance

### Challenge Resolution Process
1. Determine difficulty: Base Difficulty + Season Modifier + Threat Modifier
2. Calculate your bonus: Character Ability + Item Bonuses + Blessing tokens
3. Roll D8 and add your bonus
4. Compare to difficulty:
   - Success: Roll + bonus  difficulty
   - Partial Success: Roll + bonus = difficulty - 1
   - Failure: Roll + bonus < difficulty - 1
5. A natural 8 always succeeds regardless of modifiers

### Challenge Results
- **Success**: Move forward, collect resources, potentially gain Blessing token
- **Partial Success**: Move forward but suffer minor setback, collect reduced resources
- **Failure**: Stay in place, suffer consequences based on challenge type

---

## RESOURCE MANAGEMENT

Resources are vital materials used for crafting, feeding Animal Companions, and sometimes directly affecting challenges.

### Resource Types
There are 12 different resources, each with unique properties:
- **Protective**: Rowan Wood, Woven Reeds
- **Crafting Base**: Bog Iron, Oak Galls
- **Spiritual**: Silver Mistletoe, Barrow Dust
- **Elemental**: Forge Cinders, Sacred Water
- **Binding**: Horse Hair, Amber Shards
- **Mystic**: Standing Stone Chips, Ogham Sticks

### Gathering Resources
- **On successful challenge**: Gain 2 resources from the current Landscape
- **On partial success**: Gain 1 resource from the current Landscape
- Resources available are determined by:
  * Landscape type (each has 2-3 associated resources)
  * Current season (abundance/scarcity modifies availability)

### Resource Capacity
- Your maximum resource capacity is shown on your green die
- If you exceed capacity, you must immediately discard excess resources
- Certain Animal Companions or items can temporarily increase capacity

### Seasonal Effects on Resources
Each season makes certain resources more abundant and others scarce:
- **Samhain**: Abundant - Barrow Dust, Standing Stone Chips
  Scarce - Woven Reeds, Rowan Wood
- **Winter's Depth**: Abundant - Forge Cinders, Bog Iron
  Scarce - Sacred Water, Horse Hair
- **Imbolc**: Abundant - Silver Mistletoe, Sacred Water
  Scarce - Barrow Dust, Forge Cinders
- **Beltane**: Abundant - Rowan Wood, Oak Galls
  Scarce - Standing Stone Chips, Amber Shards
- **Lughnasadh**: Abundant - Horse Hair, Woven Reeds, Ogham Sticks
  Scarce - Bog Iron, Silver Mistletoe

### Resource Uses
1. **Feeding Animal Companions**: 1 resource per use
2. **Crafting Magic Items**: Specific combinations required
3. **Special Effects**: Some resources can be used directly
   - Sacred Water: Remove 1 Threat token or heal 1 Health
   - Rowan Wood: Prevent 1 additional Threat token accumulation
   - Barrow Dust: Commune with spirits for hints

---

## ANIMAL COMPANIONS

Animal Companions are spiritual beings that can join your journey, offering unique abilities to help overcome challenges.

### Gaining Companions
- Start with no Animal Companions
- Can encounter and bond with companions at specific Landscapes:
  * Sacred Oak Grove (Wolf, Deer, Bear, Boar)
  * Faerie Knoll (Fox, Hare)
  * Moonlit Loch (Salmon, Owl)
  * Whispering Heath (Raven)
  * Wild Horse Plain (Horse)
- Bonding requires:
  * Successful challenge
  * Appropriate offering (specific resource)

### Using Companions
- Each companion has a unique ability that can help with challenges
- Animal effectiveness varies by season (some stronger in winter, others in summer)
- Each use requires feeding the companion (1 Resource)
- You may call upon one companion per turn (or two for Giant Beastfriend)

### Feeding Requirements
- All companions accept any resource type
- Each companion has preferred resources:
  * Wolf: Prefers meat-associated resources (Bog Iron)
  * Bear: Prefers protective resources (Rowan Wood, Woven Reeds)
  * Deer: Prefers growth resources (Silver Mistletoe, Oak Galls)
  * Raven: Prefers spiritual resources (Barrow Dust, Standing Stone Chips)
  * Etc.
- Using preferred resources grants +1 to companion's effectiveness

### Companion Loyalty
- If you don't feed a companion when using it:
  * First failure: Companion becomes "Wary" (flip card face-down)
  * Second consecutive failure: Companion leaves (discard card)
- A wary companion can be restored by feeding it twice in the same turn

### Seasonal Affinities
Each companion has seasons they are more powerful in:
- **Winter Creatures** (stronger in Samhain/Winter's Depth): Wolf, Raven, Owl
- **Spring Creatures** (stronger in Imbolc): Hare, Deer, Salmon
- **Summer Creatures** (stronger in Beltane): Fox, Horse, Bear
- **Harvest Creatures** (stronger in Lughnasadh): Boar

During their preferred season, companions gain +1 to their ability effectiveness.

---

## CRAFTING SYSTEM

By combining specific resources, you can create powerful magical items that grant special abilities, though each comes with a drawback.

### Crafting Requirements
- Having the specified resources in your inventory
- Being at an appropriate Landscape (or any Landscape with -1 penalty)
- Successful craft check: Roll D8 + Character modifier  item complexity

### Item Complexity
- **Simple items** (2 resources): Difficulty 5
- **Complex items** (3 resources): Difficulty 6
- **Legendary items** (4+ resources): Difficulty 7

### Crafting Locations
Certain Landscapes are better for crafting specific items:
- **Iron Forge Dell**: +1 to craft metal items (containing Bog Iron)
- **Sacred Oak Grove**: +1 to craft wooden items (containing Rowan Wood)
- **Druid's Sanctuary**: +1 to craft spiritual items (containing Standing Stone Chips)
- **Moonlit Loch**: +1 to craft water-based items (containing Sacred Water)

### Item Uses
- Each item has limited uses (1-4 depending on item)
- Iron Crafter character gets +1 use
- Beltane season grants +1 use
- When all uses are expended, the item breaks (discard card)

### Crafting Process
1. Declare which item you wish to craft
2. Verify you have the required resources
3. Check if you're at an appropriate Landscape
4. Roll crafting check (D8 + Character modifier)
5. If successful, discard the resources and take the Crafted Item card
6. If unsuccessful, keep resources and try again later

### Item Drawbacks
Every crafted item has a drawback that balances its power:
- Health loss
- Threat accumulation
- Resource capacity reduction
- Unreliability
- Attracting unwanted attention

These drawbacks occur either upon use or as an ongoing effect while the item is in your possession.

---

## SEASONAL MECHANICS

The Celtic year turns as you progress through your journey, affecting challenges, resources, and offering unique opportunities.

### Seasonal Progression
- Fixed seasonal progression:
  * Samhain (Starting season): Landscapes 1-3
  * Winter's Depth: Landscapes 4-6
  * Imbolc: Landscapes 7-9
  * Beltane: Landscapes 10-12
  * Lughnasadh: Landscapes 13-15

### Seasonal Transition
- Occurs automatically upon reaching the designated Landscape
- Apply all season effects immediately
- Check for any seasonal quest opportunities

### Seasonal Effects

**Samhain (Winter Beginning)**
- *Effect*: Veil between worlds is thin, spiritual challenges harder (+2 difficulty)
- *Benefit*: Ancestral guidance available (may consult discard pile once)
- *Resource Abundance*: Barrow Dust, Standing Stone Chips
- *Resource Scarcity*: Woven Reeds, Rowan Wood
- *Animal Affinity*: Wolf, Raven, Owl (+1 effectiveness)

**Winter's Depth**
- *Effect*: Harsh conditions make physical challenges harder (+2 difficulty)
- *Benefit*: Clearer thinking in stillness (+1 to wisdom challenges)
- *Resource Abundance*: Forge Cinders, Bog Iron
- *Resource Scarcity*: Sacred Water, Horse Hair
- *Animal Affinity*: Wolf, Raven, Owl (+1 effectiveness)

**Imbolc (Spring Stirrings)**
- *Effect*: Renewal energy makes healing more effective (recover +1 Health)
- *Benefit*: New growth provides hope (+1 to all challenge rolls)
- *Resource Abundance*: Silver Mistletoe, Sacred Water
- *Resource Scarcity*: Barrow Dust, Forge Cinders
- *Animal Affinity*: Hare, Deer, Salmon (+1 effectiveness)

**Beltane (Summer Beginning)**
- *Effect*: Vibrant energy enhances all crafting (crafted items gain +1 use)
- *Benefit*: Life force is strong (max Health increased by 1)
- *Resource Abundance*: Rowan Wood, Oak Galls
- *Resource Scarcity*: Standing Stone Chips, Amber Shards
- *Animal Affinity*: Fox, Horse, Bear (+1 effectiveness)

**Lughnasadh (Harvest Beginning)**
- *Effect*: Gathering time (collect +1 Resource when successful)
- *Benefit*: Community support (double the effectiveness of healing)
- *Resource Abundance*: Horse Hair, Woven Reeds, Ogham Sticks
- *Resource Scarcity*: Bog Iron, Silver Mistletoe
- *Animal Affinity*: Boar (+1 effectiveness)

### Seasonal Quests
Each season offers an optional quest that appears on the Seasonal Wheel:

**Samhain Quest**: Honor the Ancestors
- Visit the Misty Barrow Downs
- Make an offering of Barrow Dust
- Reward: Gain the protection of an ancestor (+1 to all challenges until next season)

**Winter's Depth Quest**: Forge of Endurance
- Visit the Iron Forge Dell
- Craft an item containing Bog Iron
- Reward: Gain +1 max Health permanently

**Imbolc Quest**: Awakening the Land
- Visit the Sacred Oak Grove
- Plant a seed (discard Oak Galls)
- Reward: Remove 3 Threat tokens

**Beltane Quest**: Sacred Union
- Visit the Faerie Knoll
- Successfully complete a challenge with two different Animal Companions
- Reward: Gain a unique Blessing token that can be used twice

**Lughnasadh Quest**: First Harvest
- Visit the Gathering Fair
- Trade 3 resources for 1 Crafted Item component
- Reward: Gain +1 Resource capacity permanently

---

## THREAT SYSTEM

The Threat system represents the growing spiritual imbalance and chaos that may follow your actions.

### Threat Accumulation
Threat tokens accumulate through:
- Failed challenges: +1-2 tokens (based on challenge type)
- Using powerful crafted items: +1-3 tokens (as listed on item)
- Crossing seasonal boundaries unprepared: +2 tokens
- Disrespecting sacred sites: +1-3 tokens

### Threat Effects
- For each 3 Threat tokens, increase all challenge difficulties by +1
- At 5+ Threat tokens: Draw a random event at the start of each turn
- At 10+ Threat tokens: Roll on the Otherworldly Manifestation table

### Threat Reduction
Threat can be reduced by:
- Sacred sites:
  * Moonlit Loch: Remove 1-3 tokens through purification ritual
  * Druid's Sanctuary: Remove 2 tokens through meditation
- Specific resources:
  * Sacred Water: Remove 1 token when used
  * Rowan Wood: Prevent 1 token accumulation when used
- Seasonal purification rituals: Available once per season
- Maximum reduction per turn: 3 tokens

### Otherworldly Manifestations
At high Threat levels, roll on this table when triggered:
1. **Mist Wraith**: Obscures path, requires Amber Shards to banish
2. **Barrow Wight**: Drains health each turn, must outrun or confront
3. **Faerie Enticement**: Attempts to lead you astray, requires willpower challenge
4. **Wild Hunt**: Pursues you for 1d4 turns, must hide or join the hunt
5. **Ancient Guardian**: Blocks path, requires specific offering or riddling
6. **Boundary Collapse**: Seasons blur, unpredictable effects each turn
7. **Spirit Possession**: Animal Companion turns against you
8. **Cosmic Imbalance**: All challenges +2 difficulty until balance restored

---

## JOURNEY NAVIGATION

The journey through the Celtic Realm follows a circular path, with challenges and opportunities along the way.

### Journey Structure
- The 15 Landscape cards form a circular path:
  * First 12 cards: Outward journey
  * Last 3 cards: Return journey
- Each Landscape has a unique challenge associated with it

### Movement Options
- After successful challenge: Move forward one card
- After partial success: Move forward one card with minor consequences
- After failure: Stay in place
- Using specific items/companions: May move backward one card or to specific locations
- No skipping Landscapes (except with specific abilities)

### Revisiting Landscapes
- Challenges are easier on revisit (-1 difficulty)
- Resource availability is reduced (only 1 resource per success)
- Some locations have different effects on return journey (final 3 cards)

### Hidden Paths
Certain items or successful perception challenges may reveal hidden paths:
- **Iron Grove Key**: Reveals hidden paths between certain Landscapes
- **Spirit Bridge Tokens**: Allows instant travel to previously visited locations
- **Raven Scout**: Reveals information about the next Landscape
- **Salmon Journeyer**: Allows return to a previous Landscape

---

## CHARACTER PROGRESSION

As you journey, your character will grow and develop new abilities.

### Experience Points
Characters gain experience from:
- Overcoming difficult challenges (difficulty 6+): +1 XP
- Crafting complex items: +1 XP
- Forming bonds with Animal Companions (feeding 3 times): +1 XP
- Discovering hidden locations: +1 XP
- Completing seasonal quests: +2 XP

### Advancement Milestones
- **At 5 experience**: Choose one minor improvement
- **At 10 experience**: Choose one major improvement
- **At 15 experience**: Unlock character's ultimate ability

### Improvement Examples
- **Minor Improvements**:
  * +1 Health
  * +1 Resource capacity
  * New skill (e.g., Foraging, Navigation, Spirit Sight)
  * +1 to specific challenge types

- **Major Improvements**:
  * +2 Health
  * Special ability (unique to character)
  * Reduced threat accumulation
  * Animal Companion specialization
  * Crafting expertise

- **Ultimate Abilities** (Character-specific):
  * **Giant Beastfriend**: Wild Shape (transform into any Animal Companion)
  * **Hedge Witch/Warlock**: Elemental Mastery (control weather and elements)
  * **Iron Crafter**: Legendary Forge (craft items with no drawbacks)
  * **Village Elder**: Ancient Pact (call upon powerful allies from any location)

### Character Development
- Track experience on the Journey Progress tracker (blue die)
- When reaching a milestone, choose an improvement and note it
- Character development persists throughout the journey

---

## HEALING AND RECOVERY

Maintaining your health is crucial for completing your journey.

### Health System
- Your maximum health is shown on your red die
- Health does not regenerate naturally
- If health reaches 0, you must immediately retreat to the nearest healing location and lose 1-3 resources

### Healing Methods
- **Visiting healing locations**:
  * Sacred Oak Grove: +1-3 Health
  * Moonlit Loch: +1-2 Health
  * Druid's Sanctuary: +2 Health
- **Using specific resources**:
  * Sacred Water: +1 Health
  * Rowan Wood + Oak Galls: +1 Health when used together
- **Animal Companion abilities**:
  * Bear Protector: Prevent damage
  * Deer Guide: Minor healing (+1 Health)
- **Seasonal effects**:
  * Imbolc: +1 Health recovery
  * Lughnasadh: Double healing effectiveness

### Health Penalties
Health can be lost through:
- Failed physical challenges: -1-3 Health
- Using certain crafted items: Variable loss
- Exposure to elements: -1 Health per turn in certain conditions
- Otherworldly Manifestations: Variable loss

---

## VICTORY CONDITIONS

To successfully complete your journey through the Celtic Realm, you must achieve all of the following:

1. **Complete the Journey**: Successfully traverse all 15 Landscape cards, returning to your starting point
2. **Maintain Balance**: End with fewer than 6 Threat tokens
3. **Acquire Knowledge**: Return with at least 2 Crafted Items
4. **Form Bonds**: End with at least one Animal Companion
5. **Fulfill Your Quest**: Resolve your Character's personal quest (unique to each Character)

### Character Quests
Each character has a unique personal quest to fulfill:

- **Giant Beastfriend**: Bond with at least 4 different Animal Companions during your journey
- **Hedge Witch/Warlock**: Create at least 3 different Crafted Items
- **Iron Crafter**: Craft a Legendary Item (requires special materials and conditions)
- **Village Elder**: Visit all major sacred sites and perform rituals at each

---

## ADVANCED RULES

Once you're familiar with the basic game, you can incorporate these advanced rules for a deeper experience.

### Seasonal Quests
As described in the Seasonal Mechanics section, each season has an optional quest that grants unique rewards.

### Deep Crafting
Beyond the standard Crafted Items, special crafting locations allow for advanced items:
- Combining basic crafted items creates legendary artifacts
- Crafting during celestial events (solstice, equinox) imbues special properties
- Hidden recipes can be discovered through exploration and challenges

### Antagonist System
The Otherworld responds to your actions:
- High Threat levels attract specific antagonists
- Each antagonist has unique challenges and counter-strategies
- Some antagonists can be negotiated with rather than fought
- Defeating or appeasing antagonists grants significant rewards

### Character Specialization
Beyond the basic advancements, characters can specialize:
- Focus on specific challenge types (Physical, Mental, Social, Spiritual)
- Develop deep bonds with certain Animal Companions
- Master specific crafting techniques
- Attune to particular seasons

---

## QUICK REFERENCE GUIDE

### Challenge Resolution
- **Roll**: D8 + Character Modifier + Item Bonuses + Blessing tokens
- **Success**: Roll  Difficulty
- **Partial Success**: Roll = Difficulty - 1
- **Failure**: Roll < Difficulty - 1
- Natural 8 always succeeds

### Health Loss
- Failed physical challenges: -1-3 Health
- Crafted item drawbacks: Variable
- Exposure to elements: -1 Health in harsh conditions
- At 0 Health: Retreat to nearest healing location

### Resource Gathering
- Success: 2 resources from current Landscape
- Partial Success: 1 resource from current Landscape
- Based on Landscape and current season

### Threat Accumulation
- Failed challenges: +1-2 tokens
- Using powerful items: +1-3 tokens
- Crossing seasonal boundaries unprepared: +2 tokens
- Every 3 tokens: +1 difficulty to all challenges

### Seasonal Effects
- Changes every 3 Landscapes
- Affects challenge difficulties, resource availability, healing, and Animal Companions

### Crafting
- Requires specific resources and successful craft check
- Item complexity determines difficulty (5-7)
- Iron Crafter and Beltane season improve crafting

### Animal Companions
- Each use requires feeding (1 resource)
- Not feeding causes wary status, then companion leaves
- Companions have seasonal affinities
</file>

<file path="AI/Game Phase Implementation Plan with Gameplay Description.md">
## Game Phase Implementation Plan with Gameplay Description

### 1. SETUP Phase
**GAMEPLAY**: The game board is prepared by arranging 15 Landscape Cards in a circular path. The Season Wheel is set to Samhain (starting season), and various card decks (Resources, Animal Companions, Crafted Items) are shuffled and placed ready for play. First Landscape card is revealed as the starting point.
**PLAYING CARDS**: Landscape Cards, Season Card, Resource/Companion/Crafted Item decks
**COMPONENTS**: `GameSetupView.vue`, `JourneyPath.vue`, `SeasonalWheel.vue`, `GameCard.vue`

### 2. CHARACTER_SELECTION Phase
**GAMEPLAY**: Player chooses one of four Character Cards, each with unique starting abilities, health values, and resource capacities. Character's special rules and weaknesses are applied to gameplay calculations.
**PLAYING CARDS**: Character Cards with specific stats and abilities
**COMPONENTS**: `CharacterSelection.vue`, `PlayerDashboard.vue`

### 3. SEASONAL_ASSESSMENT Phase
**GAMEPLAY**: Current Season Card's effects are applied to gameplay (difficulty modifiers, benefits). Resource availability and animal companion affinities are adjusted based on season. After a set number of turns, the Season Wheel advances to the next season.
**PLAYING CARDS**: Season Cards with specific effects and modifiers
**COMPONENTS**: `SeasonDisplay.vue`, `SeasonalWheel.vue`

### 4. THREAT_LEVEL_CHECK Phase
**GAMEPLAY**: Threat tokens are counted to determine the current threat level. Higher levels trigger more severe consequences. Season-specific threats may manifest based on the current Season Card.
**PLAYING CARDS**: Season Card influences threat effects
**COMPONENTS**: `ThreatManagement.vue`, `StatusArea.vue`

### 5. LANDSCAPE_CHALLENGE Phase
**GAMEPLAY**: The current Landscape Card presents a specific challenge to overcome. Challenge difficulty is modified by the current Season Card. Player decides which companions or items to use to help with the challenge.
**PLAYING CARDS**: Landscape Card (determines challenge), Season Card (modifies difficulty)
**COMPONENTS**: `LandscapeView.vue`, `GameMap.vue`, `ActionPanel.vue`

### 6. CHALLENGE_RESOLUTION Phase
**GAMEPLAY**: Player rolls D8 die and adds character modifiers to resolve the challenge. Success, partial success, or failure is determined by comparing roll to difficulty. Failures add threat tokens while successes may award XP and resources.
**PLAYING CARDS**: Character Card, Companion Cards, Crafted Item Cards (provide bonuses)
**COMPONENTS**: `ActionPanel.vue`, `GameLog.vue`

### 7. RESOURCE_MANAGEMENT Phase
**GAMEPLAY**: Based on challenge results, player may gather Resource Cards (1-2 for success/partial success). Player manages inventory within capacity limits. Current Season Card affects which resources are abundant or scarce.
**PLAYING CARDS**: Resource Cards added to inventory, Character Card (sets capacity)
**COMPONENTS**: `ResourceManagement.vue`, `GameCard.vue`

### 8. ANIMAL_COMPANION Phase
**GAMEPLAY**: At specific Landscape locations, player can bond with Animal Companion Cards. Companions must be fed with Resource Cards to strengthen bond. Current Season affects which animals have enhanced abilities.
**PLAYING CARDS**: Animal Companion Cards, Resource Cards (for feeding)
**COMPONENTS**: `AnimalCompanionSelection.vue`, `CompanionCard.vue`, `CompanionManagement.vue`

### 9. CRAFTING Phase
**GAMEPLAY**: Player can combine Resource Cards to craft magical items. D8 roll plus modifier must meet or exceed item complexity. Beltane season enhances crafting by adding extra uses to items.
**PLAYING CARDS**: Resource Cards (consumed), Crafted Item Cards (created)
**COMPONENTS**: `CraftingStation.vue`, `GameCard.vue`

### 10. JOURNEY_PROGRESSION Phase
**GAMEPLAY**: Player advances to next Landscape Card on the journey path. Progress percentage is calculated based on number of visited landscapes. Hidden locations may be discovered with certain items or companions.
**PLAYING CARDS**: Landscape Cards reveal journey progress, Season Card may advance
**COMPONENTS**: `JourneyTracker.vue`, `JourneyProgressionView.vue`, `GameMap.vue`

### 11. HEALING_RECOVERY Phase
**GAMEPLAY**: At healing locations, player can recover lost health. Healing effectiveness is influenced by current Season, with Lughnasadh providing doubled healing. If health reaches zero, player must retreat to nearest healing location.
**PLAYING CARDS**: Landscape Cards (some are healing locations), Season Card (affects healing)
**COMPONENTS**: `PlayerStatus.vue`, `ActionPanel.vue`

### 12. GAME_OVER Phase
**GAMEPLAY**: Victory conditions are checked (journey completion, XP thresholds). Game provides summary of accomplishments including challenges overcome, companions bonded with, and items crafted.
**PLAYING CARDS**: All collected cards are evaluated for final scoring
**COMPONENTS**: `PlayerDashboard.vue`, `GameLog.vue`
</file>

<file path="babel.config.js">
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ]
}
</file>

<file path="cypress.config.ts">
import { defineConfig } from "cypress";

export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
});
</file>

<file path="Initial.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinder's Journey: The Celtic Realm</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --landscape-color: #7c9a64;
            --animal-color: #8f6b4a;
            --resource-color: #a67d53;
            --crafted-color: #72594b;
            --season-color: #9e7c5f;
            --character-color: #5e6e8a;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c3e50;
            color: #ecf0f1;
            margin: 0;
            padding: 20px;
        }
        
        #app {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1, h2 {
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        h1 {
            color: #f3d35e;
            margin-bottom: 30px;
            font-size: 2.2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .game-board {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
        }
        
        .play-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .landscape-path {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 200px;
        }
        
        .card-decks {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }
        
        .deck {
            border: 1px solid #7f8c8d;
            border-radius: 10px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.2);
        }
        
        .deck-title {
            text-align: center;
            margin-top: 0;
            color: #f3d35e;
            font-size: 1em;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        
        .card-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .card {
            width: 120px;
            height: 170px;
            border-radius: 10px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            backface-visibility: hidden;
            text-align: center;
            font-size: 0.85em;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .card.face-down {
            background-color: #34495e;
        }
        
        .card.face-down:after {
            content: "Celtic Realm";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #f3d35e;
            font-weight: bold;
        }
        
        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 12px 16px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }
        
        .card.flip-enter-active, .card.flip-leave-active {
            transition: all 0.5s;
        }
        
        .card.flip-enter-from, .card.flip-leave-to {
            transform: rotateY(180deg);
            opacity: 0;
        }
        
        .landscape-card {
            background-color: var(--landscape-color);
            background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);
            background-size: 10px 10px;
        }
        
        .animal-card {
            background-color: var(--animal-color);
            background-image: radial-gradient(circle, rgba(255, 255, 255, 0.1) 20%, transparent 20%);
            background-size: 15px 15px;
        }
        
        .resource-card {
            background-color: var(--resource-color);
            background-image: linear-gradient(to right, rgba(255, 255, 255, 0.1) 1px, transparent 1px), 
                            linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 10px 10px;
        }
        
        .crafted-card {
            background-color: var(--crafted-color);
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(255, 255, 255, 0.1) 5px, rgba(255, 255, 255, 0.1) 10px);
        }
        
        .season-card {
            background-color: var(--season-color);
            background-image: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.2) 0%, transparent 60%);
        }
        
        .character-card {
            background-color: var(--character-color);
            background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);
            background-size: 20px 20px;
        }
        
        .card-title {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .card-content {
            font-size: 0.8em;
            line-height: 1.2;
        }
        
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }
        
        .dice-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
        }
        
        .die {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .health-die {
            background-color: #e74c3c;
        }
        
        .resource-die {
            background-color: #2ecc71;
        }
        
        .progress-die {
            background-color: #3498db;
        }
        
        .challenge-die {
            background-color: #9b59b6;
            border-radius: 50%;
        }
        
        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #f3d35e;
            color: #2c3e50;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 5px;
        }
        
        .button:hover {
            background-color: #f1c40f;
        }
        
        .button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        
        .player-info {
            margin-top: 20px;
        }
        
        .message-log {
            height: 150px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .hand {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 190px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .hand-title {
            width: 100%;
            color: #f3d35e;
            margin: 0 0 10px 0;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 5px;
        }
        
        @keyframes cardFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
            100% { transform: rotateY(360deg); }
        }
        
        @keyframes sparkle {
            0% { box-shadow: 0 0 10px rgba(243, 211, 94, 0.7); }
            50% { box-shadow: 0 0 20px rgba(243, 211, 94, 1); }
            100% { box-shadow: 0 0 10px rgba(243, 211, 94, 0.7); }
        }
        
        .card.flipping {
            animation: cardFlip 1s ease;
        }
        
        .card.selected {
            animation: sparkle 1.5s infinite;
            border: 2px solid #f3d35e;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .modal-content {
            background-color: #34495e;
            border-radius: 10px;
            padding: 20px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }
        
        .seasonal-effect {
            color: #f3d35e;
            font-style: italic;
            margin-top: 10px;
        }
        
        .action-button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #f3d35e;
            color: #2c3e50;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 5px;
        }
        
        .action-button:hover {
            background-color: #f1c40f;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>Pathfinder's Journey: The Celtic Realm</h1>
        
        <div v-if="gameState === 'setup'">
            <h2>Choose Your Character</h2>
            <div class="card-container">
                <div 
                    v-for="character in characters" 
                    :key="character.id"
                    class="card character-card"
                    :class="{ selected: selectedCharacter === character.id }"
                    @click="selectCharacter(character.id)">
                    <div class="card-title">{{ character.name }}</div>
                    <div class="card-content">{{ character.description }}</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="button" @click="startGame" :disabled="!selectedCharacter">Start Journey</button>
            </div>
        </div>
        
        <div v-else-if="gameState === 'playing'" class="game-board">
            <div class="play-area">
                <div class="landscape-path">
                    <div v-for="(card, index) in landscapePath" :key="index" 
                        class="card"
                        :class="[
                            card.revealed ? 'landscape-card' : 'face-down',
                            { 'selected': index === currentLandscapeIndex }
                        ]">
                        <template v-if="card.revealed">
                            <div class="card-title">{{ card.name }}</div>
                            <div class="card-content">{{ card.description }}</div>
                        </template>
                    </div>
                </div>
                
                <div class="hand">
                    <h3 class="hand-title">Your Hand</h3>
                    <div v-if="playerResources.length === 0 && activeAnimalCompanions.length === 0 && playerCraftedItems.length === 0">
                        No cards in hand yet. Gather resources and companions on your journey!
                    </div>
                    <template v-for="animal in activeAnimalCompanions" :key="'animal-'+animal.id">
                        <div class="card animal-card" :class="{ selected: selectedCompanion === animal.id }" @click="selectCompanion(animal.id)">
                            <div class="card-title">{{ animal.name }}</div>
                            <div class="card-content">{{ animal.description }}</div>
                        </div>
                    </template>
                    <template v-for="resource in playerResources" :key="'resource-'+resource.id">
                        <div class="card resource-card" :class="{ selected: selectedResources.includes(resource.id) }" @click="toggleResourceSelection(resource.id)">
                            <div class="card-title">{{ resource.name }}</div>
                            <div class="card-content">{{ resource.description }}</div>
                        </div>
                    </template>
                    <template v-for="item in playerCraftedItems" :key="'crafted-'+item.id">
                        <div class="card crafted-card">
                            <div class="card-title">{{ item.name }}</div>
                            <div class="card-content">{{ item.description }}</div>
                        </div>
                    </template>
                </div>
                
                <div class="card-decks">
                    <div class="deck">
                        <h3 class="deck-title">Current Season</h3>
                        <div class="card-container">
                            <div class="card season-card">
                                <div class="card-title">{{ currentSeason.name }}</div>
                                <div class="card-content">{{ currentSeason.description }}</div>
                                <div class="seasonal-effect">{{ currentSeason.effect }}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="deck">
                        <h3 class="deck-title">Animal Companions</h3>
                        <div class="card-container">
                            <div v-for="animal in availableAnimalCompanions" :key="animal.id" 
                                 class="card animal-card" @click="acquireAnimalCompanion(animal.id)">
                                <div class="card-title">{{ animal.name }}</div>
                                <div class="card-content">{{ animal.description }}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="deck">
                        <h3 class="deck-title">Resources</h3>
                        <div class="card-container">
                            <div v-for="resource in availableResources" :key="resource.id"
                                 class="card resource-card" @click="gatherResource(resource.id)">
                                <div class="card-title">{{ resource.name }}</div>
                                <div class="card-content">{{ resource.description }}</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="deck">
                        <h3 class="deck-title">Crafting</h3>
                        <div class="card-container">
                            <div v-for="item in craftableItems" :key="item.id"
                                 class="card crafted-card" @click="craftItem(item.id)">
                                <div class="card-title">{{ item.name }}</div>
                                <div class="card-content">{{ item.recipe.join(' + ') }}</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="game-controls">
                <h2>Journey Status</h2>
                <div class="player-info">
                    <h3>{{ getCharacter(selectedCharacter).name }}</h3>
                    <p>{{ getCharacter(selectedCharacter).description }}</p>
                </div>
                
                <div class="dice-container">
                    <div class="die health-die">{{ healthPoints }}</div>
                    <div class="die resource-die">{{ resourceCounter }}</div>
                    <div class="die progress-die">{{ journeyProgress }}</div>
                </div>
                
                <button class="button" @click="performSeasonalAction" :disabled="seasonalActionUsed">
                    Seasonal Action
                </button>
                <button class="button" @click="resolveLandscapeChallenge" :disabled="landscapeChallengeResolved">
                    Resolve Challenge
                </button>
                <button class="button" @click="useAnimalCompanion" :disabled="!selectedCompanion || animalCompanionUsed">
                    Use Companion
                </button>
                <button class="button" @click="gatherRandomResource" :disabled="!landscapeChallengeResolved || resourceGathered">
                    Gather Resource
                </button>
                <button class="button" @click="startCrafting" :disabled="selectedResources.length === 0">
                    Craft Item
                </button>
                <button class="button" @click="moveToNextLandscape" :disabled="!canMoveToNextLandscape()">
                    Continue Journey
                </button>
                
                <div class="message-log">
                    <div v-for="(message, index) in messageLog" :key="index" class="log-entry">
                        {{ message }}
                    </div>
                </div>
            </div>
        </div>
        
        <div v-else-if="gameState === 'gameover'" style="text-align: center;">
            <h2>Journey Complete!</h2>
            <p>{{ gameOverMessage }}</p>
            <button class="button" @click="resetGame">Begin a New Journey</button>
        </div>
        
        <div v-if="showModal" class="modal-overlay">
            <div class="modal-content">
                <h3>{{ modalTitle }}</h3>
                <p style="white-space: pre-line;">{{ modalContent }}</p>
                <button @click="showModal = false" class="action-button">Close</button>
            </div>
        </div>
    </div>
    
    <script>
        const { createApp, ref, computed, watch } = Vue;
        
        createApp({
            setup() {
                // Game state
                const gameState = ref('setup');
                const selectedCharacter = ref(null);
                const healthPoints = ref(6);
                const resourceCounter = ref(1);
                const journeyProgress = ref(0);
                const challengeDieValue = ref(1);
                const currentLandscapeIndex = ref(0);
                const landscapeChallengeResolved = ref(false);
                const seasonalActionUsed = ref(false);
                const animalCompanionUsed = ref(false);
                const resourceGathered = ref(false);
                const selectedCompanion = ref(null);
                const selectedResources = ref([]);
                const messageLog = ref(['Welcome to Pathfinder\'s Journey! Choose a character to begin your adventure.']);
                const playerResources = ref([]);
                const playerCraftedItems = ref([]);
                const activeAnimalCompanions = ref([]);
                const currentSeasonIndex = ref(0);
                const showModal = ref(false);
                const modalTitle = ref('');
                const modalContent = ref('');
                const gameOverMessage = ref('');
                
                // Card data
                const landscapes = [
                    { id: 1, name: 'Ancient Stone Circle', description: 'A mystical place of power.', challenge: 'Navigate the energy flows (6).', resolved: false, revealed: false },
                    { id: 2, name: 'Misty Barrow Downs', description: 'Ancient burial mounds shrouded in mist.', challenge: 'Find your way through the mist (5).', resolved: false, revealed: false },
                    { id: 3, name: 'Sacred Oak Grove', description: 'Ancient trees with enormous trunks.', challenge: 'Gain the trees\' blessing (7).', resolved: false, revealed: false },
                    { id: 4, name: 'Thatched Village', description: 'A small community of skilled crafters.', challenge: 'Trade for local knowledge (4).', resolved: false, revealed: false },
                    { id: 5, name: 'Iron Forge Dell', description: 'A valley where smiths work their craft.', challenge: 'Learn smithing basics (6).', resolved: false, revealed: false },
                    { id: 6, name: 'Moonlit Loch', description: 'A peaceful lake reflecting the night sky.', challenge: 'Decode star patterns (5).', resolved: false, revealed: false },
                    { id: 7, name: 'Menhir Path', description: 'Standing stones creating a mysterious path.', challenge: 'Follow the ancient route (6).', resolved: false, revealed: false },
                    { id: 8, name: 'Faerie Knoll', description: 'Home to the fae folk.', challenge: 'Bargain with the fae (8).', resolved: false, revealed: false },
                    { id: 9, name: 'Whispering Heath', description: 'A windy plain where voices can be heard.', challenge: 'Interpret the whispers (7).', resolved: false, revealed: false },
                    { id: 10, name: 'Blackthorn Maze', description: 'A labyrinth of thorny bushes.', challenge: 'Find the center (6).', resolved: false, revealed: false },
                    { id: 11, name: 'Boggy Lowlands', description: 'Marshy terrain full of hidden treasures.', challenge: 'Cross safely (5).', resolved: false, revealed: false },
                    { id: 12, name: 'Gathering Fair', description: 'A seasonal market of traders.', challenge: 'Compete in the games (7).', resolved: false, revealed: false },
                    { id: 13, name: 'Elder Bridge', description: 'An ancient crossing over a deep gorge.', challenge: 'Repair the damaged section (6).', resolved: false, revealed: false },
                    { id: 14, name: 'Druid\'s Sanctuary', description: 'A hidden grove of wisdom.', challenge: 'Prove your worth (8).', resolved: false, revealed: false },
                    { id: 15, name: 'Wild Horse Plain', description: 'Open grasslands where horses roam.', challenge: 'Gain a horse\'s trust (7).', resolved: false, revealed: false }
                ];
                
                const animalCompanions = [
                    { id: 1, name: 'Raven Scout', description: 'Helps find hidden paths.', bonus: 2, bestSeason: 'Samhain' },
                    { id: 2, name: 'Wolf Guardian', description: 'Protects against dangers.', bonus: 3, bestSeason: 'Winter\'s Depth' },
                    { id: 3, name: 'Deer Guide', description: 'Leads to safe passages.', bonus: 2, bestSeason: 'Imbolc' },
                    { id: 4, name: 'Bear Protector', description: 'Provides strength and courage.', bonus: 3, bestSeason: 'Beltane' },
                    { id: 5, name: 'Hare Pathfinder', description: 'Discovers shortcuts.', bonus: 1, bestSeason: 'Imbolc' },
                    { id: 6, name: 'Boar Digger', description: 'Unearths buried treasures.', bonus: 2, bestSeason: 'Lughnasadh' },
                    { id: 7, name: 'Fox Trickster', description: 'Distracts enemies and foes.', bonus: 2, bestSeason: 'Samhain' },
                    { id: 8, name: 'Owl Sage', description: 'Shares ancient wisdom.', bonus: 2, bestSeason: 'Winter\'s Depth' },
                    { id: 9, name: 'Salmon Journeyer', description: 'Helps cross water barriers.', bonus: 2, bestSeason: 'Beltane' },
                    { id: 10, name: 'Horse Carrier', description: 'Speeds up travel.', bonus: 2, bestSeason: 'Lughnasadh' }
                ];
                
                const resources = [
                    { id: 1, name: 'Rowan Wood', description: 'Sacred wood with protective properties.', season: 'Samhain' },
                    { id: 2, name: 'Bog Iron', description: 'Raw iron from marshy areas.', season: 'Winter\'s Depth' },
                    { id: 3, name: 'Silver Mistletoe', description: 'Rare plant with magical properties.', season: 'Imbolc' },
                    { id: 4, name: 'Standing Stone Chips', description: 'Fragments with residual power.', season: 'any' },
                    { id: 5, name: 'Woven Reeds', description: 'Flexible material for binding.', season: 'Beltane' },
                    { id: 6, name: 'Horse Hair', description: 'Strands from wild horse manes.', season: 'Lughnasadh' },
                    { id: 7, name: 'Oak Galls', description: 'Growths with alchemical properties.', season: 'Lughnasadh' },
                    { id: 8, name: 'Amber Shards', description: 'Fossilized tree resin pieces.', season: 'any' },
                    { id: 9, name: 'Barrow Dust', description: 'Soil from ancient burial mounds.', season: 'Samhain' },
                    { id: 10, name: 'Forge Cinders', description: 'Remnants of blacksmith fires.', season: 'Winter\'s Depth' },
                    { id: 11, name: 'Sacred Water', description: 'Collected from moonlit lochs.', season: 'Beltane' },
                    { id: 12, name: 'Ogham Sticks', description: 'Carved wooden runes.', season: 'Imbolc' }
                ];
                
                const craftedItems = [
                    { id: 1, name: 'Beast Speaker Charm', description: 'Allows communication with animals.', recipe: ['Horse Hair', 'Amber Shards', 'Oak Galls'], effect: 'Animal Companions provide +1 bonus.' },
                    { id: 2, name: 'Colossal Whistle', description: 'Summons giant allies.', recipe: ['Rowan Wood', 'Silver Mistletoe'], effect: 'Bypass one physical challenge automatically.' },
                    { id: 3, name: 'Earth Speaker Staff', description: 'Channels earth energies.', recipe: ['Rowan Wood', 'Standing Stone Chips', 'Barrow Dust'], effect: 'Gain +2 to landscape challenges.' },
                    { id: 4, name: 'Giant\'s Bridle', description: 'Harness for large creatures.', recipe: ['Bog Iron', 'Horse Hair', 'Woven Reeds'], effect: 'Travel two landscapes at once.' },
                    { id: 5, name: 'Ogham Divining Set', description: 'Reads the future.', recipe: ['Oak Galls', 'Sacred Water', 'Ogham Sticks'], effect: 'See the next landscape card before travel.' },
                    { id: 6, name: 'Seasonal Compass', description: 'Tracks seasonal transitions.', recipe: ['Amber Shards', 'Standing Stone Chips', 'Forge Cinders'], effect: 'Choose which season comes next.' },
                    { id: 7, name: 'Iron Grove Key', description: 'Unlocks hidden pathways.', recipe: ['Bog Iron', 'Silver Mistletoe', 'Forge Cinders'], effect: 'Skip one landscape if needed.' },
                    { id: 8, name: 'Spirit Bridge Tokens', description: 'Create ethereal crossings.', recipe: ['Barrow Dust', 'Sacred Water', 'Amber Shards'], effect: 'Return to previous landscapes easily.' }
                ];
                
                const seasons = [
                    { id: 1, name: 'Samhain', description: 'Winter Beginning', effect: '+2 to spiritual challenges, -1 to physical ones.', action: 'Commune with spirits.' },
                    { id: 2, name: 'Winter\'s Depth', description: 'Cold and stillness', effect: '+1 to all challenges in snowy or cold areas.', action: 'Gather strength through rest.' },
                    { id: 3, name: 'Imbolc', description: 'Spring Stirrings', effect: 'Animal companions gain +1 bonus.', action: 'Plant a seed of intention.' },
                    { id: 4, name: 'Beltane', description: 'Summer Beginning', effect: '+2 to challenges involving growth or creation.', action: 'Celebrate with dance.' },
                    { id: 5, name: 'Lughnasadh', description: 'Harvest Beginning', effect: 'Gather one extra resource.', action: 'Share your bounty.' }
                ];
                
                const characters = [
                    { id: 1, name: 'Giant Beastfriend', description: 'Can carry 8 resources and use two Animal Companions.', bonuses: { animals: 2, crafting: -1, physical: 2, magical: 0, knowledge: 0, wisdom: 0 } },
                    { id: 2, name: 'Hedge Witch/Warlock', description: 'Gains +2 to magical challenges, crafts with one fewer resource.', bonuses: { magical: 2, crafting: 1, physical: -1, animals: 0, knowledge: 0, wisdom: 0 } },
                    { id: 3, name: 'Iron Crafter', description: 'Crafted items are more powerful, gains +2 to crafting challenges.', bonuses: { crafting: 2, magical: -1, animals: 1, physical: 0, knowledge: 0, wisdom: 0 } },
                    { id: 4, name: 'Village Elder', description: 'Knows all paths, gains +1 to all challenges but physical challenges are harder.', bonuses: { knowledge: 1, physical: -1, wisdom: 2, magical: 0, crafting: 0, animals: 0 } }
                ];
                
                // Shuffled landscape path
                const landscapePath = ref([]);
                
                // Computed properties
                const currentLandscape = computed(() => landscapePath.value[currentLandscapeIndex.value]);
                
                const currentSeason = computed(() => seasons[currentSeasonIndex.value]);
                
                const availableAnimalCompanions = computed(() => {
                    // Filter animals based on season and those not already active
                    return animalCompanions.filter(animal => 
                        !activeAnimalCompanions.value.some(a => a.id === animal.id) &&
                        (animal.bestSeason === currentSeason.value.name || Math.random() > 0.5)
                    );
                });
                
                const availableResources = computed(() => {
                    // Filter resources based on season and reasonable availability
                    return resources.filter(resource => 
                        (resource.season === 'any' || resource.season === currentSeason.value.name) &&
                        Math.random() > 0.3
                    ).slice(0, 4); // Limit to 4 available at a time
                });
                
                const craftableItems = computed(() => {
                    // Items player can craft based on available resources
                    const playerResourceNames = playerResources.value.map(r => r.name);
                    
                    return craftedItems.filter(item => {
                        // Check if player has all required resources
                        return item.recipe.every(resourceName => 
                            playerResourceNames.includes(resourceName) &&
                            playerResourceNames.filter(n => n === resourceName).length >= 
                            item.recipe.filter(r => r === resourceName).length
                        );
                    });
                });
                
                // Methods
                function selectCharacter(id) {
                    selectedCharacter.value = id;
                    
                    // Adjust starting values based on character
                    const character = getCharacter(id);
                    if (character.name === 'Giant Beastfriend') {
                        resourceCounter.value = 2; // Start with more resources
                    }
                    
                    addMessage(`You have chosen to be the ${character.name}.`);
                }
                
                function getCharacter(id) {
                    return characters.find(c => c.id === id);
                }
                
                function startGame() {
                    if (!selectedCharacter.value) {
                        addMessage("Please select a character before starting your journey.");
                        return;
                    }
                    
                    // Initialize the game
                    shuffleLandscapePath();
                    
                    // Reset game state
                    healthPoints.value = 6;
                    resourceCounter.value = 1;
                    journeyProgress.value = 0;
                    currentLandscapeIndex.value = 0;
                    landscapeChallengeResolved.value = false;
                    seasonalActionUsed.value = false;
                    animalCompanionUsed.value = false;
                    resourceGathered.value = false;
                    selectedCompanion.value = null;
                    selectedResources.value = [];
                    playerResources.value = [];
                    playerCraftedItems.value = [];
                    activeAnimalCompanions.value = [];
                    currentSeasonIndex.value = 0;
                    
                    // Character-specific starting bonuses
                    const character = getCharacter(selectedCharacter.value);
                    if (character.name === 'Giant Beastfriend') {
                        // Start with more resources
                        const startingResource = resources[Math.floor(Math.random() * resources.length)];
                        const resourceInstance = {
                            ...startingResource,
                            id: startingResource.id + '_' + Date.now()
                        };
                        playerResources.value.push(resourceInstance);
                        resourceCounter.value = 1;
                        addMessage(`You start with ${startingResource.name} as a resource.`);
                    } else if (character.name === 'Hedge Witch/Warlock') {
                        // Start with magical knowledge
                        addMessage("Your magical knowledge will help you craft items with fewer resources.");
                    } else if (character.name === 'Iron Crafter') {
                        // Start with crafting bonus
                        addMessage("Your crafting expertise will make your items more powerful.");
                    } else if (character.name === 'Village Elder') {
                        // Start with wisdom
                        addMessage("Your wisdom gives you insight into the challenges ahead.");
                    }
                    
                    gameState.value = 'playing';
                    addMessage(`The journey begins! Your first destination is the ${landscapePath.value[0].name}.`);
                }
                
                function shuffleLandscapePath() {
                    // Create a copy of landscapes and shuffle it
                    const shuffled = [...landscapes].sort(() => Math.random() - 0.5);
                    
                    // Set the first card as revealed
                    shuffled[0].revealed = true;
                    
                    landscapePath.value = shuffled;
                }
                
                function addMessage(message) {
                    messageLog.value.push(message);
                    // Keep log at reasonable size
                    if (messageLog.value.length > 15) {
                        messageLog.value.shift();
                    }
                }
                
                function performSeasonalAction() {
                    if (seasonalActionUsed.value) return;
                    
                    const action = currentSeason.value.action;
                    addMessage(`You ${action}`);
                    
                    // Apply seasonal effects
                    switch(currentSeason.value.name) {
                        case 'Samhain':
                            // Increase health or gain a spirit guide
                            if (Math.random() > 0.5) {
                                healthPoints.value = Math.min(6, healthPoints.value + 1);
                                addMessage('The spirits grant you renewed strength.');
                            } else {
                                // Try to add a spirit animal
                                const availableSpirits = availableAnimalCompanions.value;
                                if (availableSpirits.length > 0) {
                                    const spirit = availableSpirits[Math.floor(Math.random() * availableSpirits.length)];
                                    acquireAnimalCompanion(spirit.id);
                                    addMessage(`A spirit ${spirit.name} appears to guide you.`);
                                }
                            }
                            break;
                        case 'Winter\'s Depth':
                            // Restore health through rest
                            healthPoints.value = Math.min(6, healthPoints.value + 2);
                            addMessage('Your deep rest restores your strength.');
                            break;
                        case 'Imbolc':
                            // Plant a seed (gain future bonus)
                            addMessage('Your intention manifests as a +1 bonus to your next challenge.');
                            // Will add +1 to next challenge
                            break;
                        case 'Beltane':
                            // Celebration brings luck - gain a random resource
                            gatherRandomResource();
                            addMessage('Your dance attracts good fortune.');
                            break;
                        case 'Lughnasadh':
                            // Sharing brings community support
                            if (playerResources.value.length > 0) {
                                acquireAnimalCompanion(availableAnimalCompanions.value[0]?.id);
                                addMessage('Your generosity is rewarded with a new ally.');
                            }
                            break;
                    }
                    
                    seasonalActionUsed.value = true;
                }
                
                function resolveLandscapeChallenge() {
                    if (landscapeChallengeResolved.value) return;
                    
                    // Roll the challenge die (1-8)
                    challengeDieValue.value = Math.floor(Math.random() * 8) + 1;
                    
                    // Parse the difficulty from the challenge text
                    const challengeText = currentLandscape.value.challenge;
                    const difficultyMatch = challengeText.match(/\((\d+)\)/);
                    const difficulty = difficultyMatch ? parseInt(difficultyMatch[1]) : 6;
                    
                    // Calculate total score with bonuses
                    let totalScore = challengeDieValue.value;
                    
                    // Character bonuses
                    const character = getCharacter(selectedCharacter.value);
                    const challengeType = getChallengeType(challengeText);
                    
                    if (character && character.bonuses) {
                        if (challengeType === 'physical' && character.bonuses.physical) {
                            totalScore += character.bonuses.physical;
                            addMessage(`${character.name} adds ${character.bonuses.physical} to physical challenges.`);
                        } else if (challengeType === 'magical' && character.bonuses.magical) {
                            totalScore += character.bonuses.magical;
                            addMessage(`${character.name} adds ${character.bonuses.magical} to magical challenges.`);
                        } else if (challengeType === 'knowledge' && character.bonuses.knowledge) {
                            totalScore += character.bonuses.knowledge;
                            addMessage(`${character.name} adds ${character.bonuses.knowledge} to knowledge challenges.`);
                        } else if (challengeType === 'creation' && character.bonuses.crafting) {
                            totalScore += character.bonuses.crafting;
                            addMessage(`${character.name} adds ${character.bonuses.crafting} to creation challenges.`);
                        } else if (challengeType === 'social' && character.bonuses.wisdom) {
                            totalScore += character.bonuses.wisdom;
                            addMessage(`${character.name} adds ${character.bonuses.wisdom} to social challenges.`);
                        }
                    }
                    
                    // Season bonuses
                    if (currentSeason.value.name === 'Samhain' && challengeType === 'magical') {
                        totalScore += 2;
                        addMessage('Samhain season adds +2 to magical challenges.');
                    } else if (currentSeason.value.name === 'Winter\'s Depth' && challengeText.toLowerCase().includes('snow')) {
                        totalScore += 1;
                        addMessage('Winter\'s Depth adds +1 to snowy challenges.');
                    } else if (currentSeason.value.name === 'Beltane' && challengeType === 'creation') {
                        totalScore += 2;
                        addMessage('Beltane season adds +2 to creation challenges.');
                    }
                    
                    // Add bonus from any crafted items
                    for (const item of playerCraftedItems.value) {
                        if (item.name === 'Earth Speaker Staff') {
                            totalScore += 2;
                            addMessage('Earth Speaker Staff adds +2 to your challenge roll.');
                        }
                    }
                    
                    // Add bonus from animal companions if used
                    if (animalCompanionUsed.value && selectedCompanion.value) {
                        const companion = activeAnimalCompanions.value.find(c => c.id === selectedCompanion.value);
                        if (companion) {
                            let bonusAmount = companion.bonus;
                            // Extra bonus if in their best season
                            if (companion.bestSeason === currentSeason.value.name) {
                                bonusAmount += 1;
                                addMessage(`${companion.name} gets an extra +1 bonus during ${currentSeason.value.name}.`);
                            }
                            totalScore += bonusAmount;
                            addMessage(`${companion.name} adds +${bonusAmount} to your challenge roll.`);
                        }
                    }
                    
                    // Determine success
                    const success = totalScore >= difficulty;
                    
                    if (success) {
                        addMessage(`Challenge success! You rolled ${challengeDieValue.value} for a total of ${totalScore} against difficulty ${difficulty}.`);
                        landscapeChallengeResolved.value = true;
                        // Mark the landscape as resolved
                        currentLandscape.value.resolved = true;
                    } else {
                        addMessage(`Challenge failed. You rolled ${challengeDieValue.value} for a total of ${totalScore} against difficulty ${difficulty}.`);
                        // Take damage for failure
                        healthPoints.value = Math.max(1, healthPoints.value - 1);
                        addMessage('You lose 1 health point from the strain.');
                    }
                }
                
                function getChallengeType(challengeText) {
                    // Determine challenge type based on text
                    const text = challengeText.toLowerCase();
                    if (text.includes('navigate') || text.includes('cross') || text.includes('find your way') || text.includes('physical')) {
                        return 'physical';
                    } else if (text.includes('magic') || text.includes('blessing') || text.includes('spirit')) {
                        return 'magical';
                    } else if (text.includes('knowledge') || text.includes('learn') || text.includes('decode')) {
                        return 'knowledge';
                    } else if (text.includes('craft') || text.includes('create') || text.includes('repair')) {
                        return 'creation';
                    } else if (text.includes('communicate') || text.includes('speak') || text.includes('bargain')) {
                        return 'social';
                    } else {
                        return 'general';
                    }
                }
                
                function useAnimalCompanion() {
                    if (!selectedCompanion.value || animalCompanionUsed.value) return;
                    
                    // Find the selected companion
                    const companion = activeAnimalCompanions.value.find(c => c.id === selectedCompanion.value);
                    if (!companion) return;
                    
                    // Apply companion effect
                    let bonusAmount = companion.bonus;
                    
                    // Extra bonus if in their best season
                    if (companion.bestSeason === currentSeason.value.name) {
                        bonusAmount += 1;
                    }
                    
                    // Apply effect based on companion type
                    switch(companion.name) {
                        case 'Raven Scout':
                            // Help find hidden paths - preview next landscape
                            if (currentLandscapeIndex.value < landscapePath.value.length - 1) {
                                const nextLandscape = landscapePath.value[currentLandscapeIndex.value + 1];
                                addMessage(`Your Raven Scout shows you that the next landscape is ${nextLandscape.name}.`);
                            }
                            break;
                        case 'Wolf Guardian':
                            // Protect against danger - restore health
                            healthPoints.value = Math.min(6, healthPoints.value + 1);
                            addMessage('Your Wolf Guardian helps you recover 1 health point.');
                            break;
                        default:
                            // Generic bonus to current challenge
                            if (!landscapeChallengeResolved.value) {
                                addMessage(`Your ${companion.name} will give you a +${bonusAmount} bonus to your next challenge roll.`);
                            } else {
                                addMessage(`Your ${companion.name} helps you find resources.`);
                                gatherRandomResource();
                            }
                    }
                    
                    animalCompanionUsed.value = true;
                }
                
                function selectCompanion(id) {
                    if (selectedCompanion.value === id) {
                        selectedCompanion.value = null;
                    } else {
                        selectedCompanion.value = id;
                    }
                }
                
                function gatherRandomResource() {
                    if (resourceGathered.value) return;
                    
                    // Get available resources based on season
                    const available = availableResources.value;
                    
                    if (available.length > 0) {
                        // Pick a random resource
                        const resource = available[Math.floor(Math.random() * available.length)];
                        
                        // Add to player's resources if not at max
                        const character = getCharacter(selectedCharacter.value);
                        const maxResources = character.name === 'Giant Beastfriend' ? 8 : 6;
                        
                        if (playerResources.value.length < maxResources) {
                            // Create a unique ID for this resource instance
                            const resourceInstance = {
                                ...resource,
                                id: resource.id + '_' + Date.now() // Ensure unique ID
                            };
                            
                            playerResources.value.push(resourceInstance);
                            addMessage(`You gathered ${resource.name}!`);
                            resourceCounter.value = playerResources.value.length;
                        } else {
                            addMessage(`You found ${resource.name}, but can't carry any more resources.`);
                        }
                    } else {
                        addMessage('No suitable resources found in this area.');
                    }
                    
                    resourceGathered.value = true;
                }
                
                function acquireAnimalCompanion(id) {
                    // Find the animal
                    const animal = animalCompanions.find(a => a.id === id);
                    if (!animal) return;
                    
                    // Check if we already have this companion
                    if (activeAnimalCompanions.value.some(a => a.id === id)) {
                        addMessage(`You already have ${animal.name} as a companion.`);
                        return;
                    }
                    
                    // Check character limits
                    const character = getCharacter(selectedCharacter.value);
                    const animalLimit = character.name === 'Giant Beastfriend' ? 2 : 1;
                    
                    if (activeAnimalCompanions.value.length >= animalLimit) {
                        addMessage(`You cannot have more than ${animalLimit} animal companions.`);
                        return;
                    }
                    
                    // Add the companion
                    activeAnimalCompanions.value.push(animal);
                    addMessage(`${animal.name} has joined your journey!`);
                }
                
                function toggleResourceSelection(id) {
                    const index = selectedResources.value.indexOf(id);
                    
                    if (index === -1) {
                        // Add to selection
                        selectedResources.value.push(id);
                    } else {
                        // Remove from selection
                        selectedResources.value.splice(index, 1);
                    }
                }
                
                function startCrafting() {
                    if (selectedResources.value.length === 0) return;
                    
                    // Get resource names
                    const selectedResourceObjs = playerResources.value.filter(r => 
                        selectedResources.value.includes(r.id));
                    const selectedResourceNames = selectedResourceObjs.map(r => r.name);
                    
                    // Check if these resources can craft anything
                    for (const item of craftedItems) {
                        const canCraft = checkCrafting(item, selectedResourceNames);
                        
                        if (canCraft) {
                            craftItem(item.id, selectedResourceObjs);
                            return;
                        }
                    }
                    
                    // If we get here, crafting failed
                    addMessage('These resources cannot craft any known items.');
                    selectedResources.value = [];
                }
                
                function checkCrafting(item, resources) {
                    // Check if resources match recipe
                    const recipeCopy = [...item.recipe];
                    const resourcesCopy = [...resources];
                    
                    // For Giant Beastfriend, need one extra resource
                    const character = getCharacter(selectedCharacter.value);
                    const requiresExtra = character.name === 'Giant Beastfriend';
                    
                    // For Hedge Witch, need one fewer resource
                    const needsFewer = character.name === 'Hedge Witch/Warlock';
                    
                    if (requiresExtra && resourcesCopy.length < item.recipe.length + 1) {
                        return false;
                    }
                    
                    if (!needsFewer && resourcesCopy.length < item.recipe.length) {
                        return false;
                    }
                    
                    if (needsFewer && item.recipe.length > 1 && resourcesCopy.length < item.recipe.length - 1) {
                        return false;
                    }
                    
                    // Standard crafting check (all recipe items must be present)
                    for (const ingredient of recipeCopy) {
                        const index = resourcesCopy.indexOf(ingredient);
                        if (index === -1) {
                            return false;
                        }
                        // Remove the matched resource to prevent double-counting
                        resourcesCopy.splice(index, 1);
                    }
                    
                    return true;
                }
                
                function craftItem(id, selectedResourceObjs) {
                    // Find the item
                    const item = craftedItems.find(i => i.id === id);
                    if (!item) return;
                    
                    // Get the resource names
                    const selectedResourceNames = selectedResourceObjs.map(r => r.name);
                    
                    // For Giant Beastfriend, need one extra resource
                    const character = getCharacter(selectedCharacter.value);
                    const requiresExtra = character.name === 'Giant Beastfriend';
                    
                    // For Hedge Witch, need one fewer resource
                    const needsFewer = character.name === 'Hedge Witch/Warlock';
                    
                    let canCraft = checkCrafting(item, [...selectedResourceNames]);
                    
                    if (!canCraft) {
                        addMessage(`You need ${item.recipe.join(', ')} to craft ${item.name}.`);
                        return;
                    }
                    
                    // Remove the used resources from player inventory
                    const resourceIdsToRemove = [];
                    const recipeCopy = [...item.recipe];
                    
                    // If Hedge Witch/Warlock and more than one resource required, use one fewer
                    if (needsFewer && recipeCopy.length > 1) {
                        // Remove one ingredient from the recipe
                        recipeCopy.pop();
                    }
                    
                    // Match resources to recipe ingredients
                    for (const ingredient of recipeCopy) {
                        // Find a resource with this name that hasn't been marked for removal
                        const resourceObj = selectedResourceObjs.find(r => 
                            r.name === ingredient && !resourceIdsToRemove.includes(r.id));
                        
                        if (resourceObj) {
                            resourceIdsToRemove.push(resourceObj.id);
                        }
                    }
                    
                    // If Giant Beastfriend, add one extra random resource
                    if (requiresExtra) {
                        // Get a resource that's not already marked for removal
                        const extraResource = selectedResourceObjs.find(r => !resourceIdsToRemove.includes(r.id));
                        if (extraResource) {
                            resourceIdsToRemove.push(extraResource.id);
                        }
                    }
                    
                    // Remove the resources
                    playerResources.value = playerResources.value.filter(r => !resourceIdsToRemove.includes(r.id));
                    
                    // Add the crafted item
                    playerCraftedItems.value.push(item);
                    
                    // Clear selection
                    selectedResources.value = [];
                    
                    // Update resource counter
                    resourceCounter.value = playerResources.value.length;
                    
                    addMessage(`You crafted ${item.name}! ${item.effect}`);
                    
                    // Show info modal about the item
                    modalTitle.value = item.name;
                    modalContent.value = `${item.description}\n\nEffect: ${item.effect}`;
                    showModal.value = true;
                }
                
                function moveToNextLandscape() {
                    if (!canMoveToNextLandscape()) {
                        addMessage("You must resolve the current landscape challenge before moving on.");
                        return;
                    }
                    
                    // Update progress
                    journeyProgress.value += 1;
                    currentLandscapeIndex.value += 1;
                    
                    // Reset flags for new location
                    landscapeChallengeResolved.value = false;
                    seasonalActionUsed.value = false;
                    animalCompanionUsed.value = false;
                    resourceGathered.value = false;
                    
                    // Check for season change
                    if (journeyProgress.value % 3 === 0) {
                        // Move to next season
                        currentSeasonIndex.value = (currentSeasonIndex.value + 1) % seasons.length;
                        addMessage(`The season changes to ${currentSeason.value.name}.`);
                        
                        // Animal companions may change with seasons
                        checkCompanionMigration();
                    }
                    
                    // Reveal the new landscape
                    if (currentLandscapeIndex.value < landscapePath.value.length) {
                        landscapePath.value[currentLandscapeIndex.value].revealed = true;
                        addMessage(`You arrive at ${currentLandscape.value.name}.`);
                    } else {
                        // Journey complete!
                        completeJourney();
                    }
                }
                
                function checkCompanionMigration() {
                    // Some companions may leave based on season
                    const leavingCompanions = [];
                    
                    for (const companion of activeAnimalCompanions.value) {
                        // 30% chance of leaving if not in their preferred season
                        if (companion.bestSeason !== currentSeason.value.name && Math.random() < 0.3) {
                            leavingCompanions.push(companion.id);
                            addMessage(`${companion.name} leaves as the season changes.`);
                        }
                    }
                    
                    // Remove leaving companions
                    if (leavingCompanions.length > 0) {
                        activeAnimalCompanions.value = activeAnimalCompanions.value.filter(
                            c => !leavingCompanions.includes(c.id)
                        );
                    }
                    
                    // Chance to gain a new companion suited to this season
                    const seasonalCompanions = animalCompanions.filter(
                        c => c.bestSeason === currentSeason.value.name &&
                        !activeAnimalCompanions.value.some(ac => ac.id === c.id)
                    );
                    
                    if (seasonalCompanions.length > 0 && Math.random() < 0.5) {
                        // Only add if we have room
                        const character = getCharacter(selectedCharacter.value);
                        const animalLimit = character.name === 'Giant Beastfriend' ? 2 : 1;
                        
                        if (activeAnimalCompanions.value.length < animalLimit) {
                            const newCompanion = seasonalCompanions[Math.floor(Math.random() * seasonalCompanions.length)];
                            activeAnimalCompanions.value.push(newCompanion);
                            addMessage(`${newCompanion.name} joins you during ${currentSeason.value.name}.`);
                        }
                    }
                }
                
                function canMoveToNextLandscape() {
                    // Can only move if current landscape is resolved
                    if (!currentLandscape.value || !currentLandscape.value.resolved) {
                        return false;
                    }
                    
                    // Check if we've reached the end
                    if (currentLandscapeIndex.value >= landscapePath.value.length - 1) {
                        return false;
                    }
                    
                    return true;
                }
                
                function completeJourney() {
                    gameState.value = 'gameover';
                    
                    // Check victory conditions
                    const hasAnimalCompanion = activeAnimalCompanions.value.length > 0;
                    const hasCraftedItems = playerCraftedItems.value.length >= 2;
                    const hasFullHealth = healthPoints.value >= 5;
                    const hasCompletedMostChallenges = landscapePath.value.filter(l => l.resolved).length >= Math.floor(landscapePath.value.length * 0.75);
                    
                    let message = "";
                    
                    // Character-specific ending messages
                    const character = getCharacter(selectedCharacter.value);
                    if (character.name === 'Giant Beastfriend') {
                        message += "As a Giant Beastfriend, your connection with animals has ";
                        message += hasAnimalCompanion ? "flourished throughout your journey. " : "not reached its full potential. ";
                    } else if (character.name === 'Hedge Witch/Warlock') {
                        message += "As a Hedge Witch/Warlock, your magical prowess has ";
                        message += hasCraftedItems ? "allowed you to craft powerful items. " : "not been fully utilized. ";
                    } else if (character.name === 'Iron Crafter') {
                        message += "As an Iron Crafter, your crafting skills have ";
                        message += hasCraftedItems ? "produced remarkable items. " : "not been put to good use. ";
                    } else if (character.name === 'Village Elder') {
                        message += "As a Village Elder, your wisdom has ";
                        message += hasCompletedMostChallenges ? "guided you successfully through many challenges. " : "not been enough to overcome all obstacles. ";
                    }
                    
                    // General ending message
                    if (hasAnimalCompanion && hasCraftedItems && hasFullHealth) {
                        message += "Congratulations! You've successfully completed your journey through the Celtic Realm with loyal animal companions, powerful crafted items, and maintained your health. The lands will remember your name among its greatest legends.";
                    } else if (hasAnimalCompanion && hasCraftedItems) {
                        message += "You've traversed the Celtic Realm with loyal animal companions and crafted powerful items. Though your journey was challenging, you've earned your place among the realm's heroes.";
                    } else if (hasAnimalCompanion) {
                        message += "You've traversed the Celtic Realm with loyal animal companions, but without enough magical items. Your journey was challenging but not legendary.";
                    } else if (hasCraftedItems) {
                        message += "You've crafted powerful items on your journey, but without animal companions to guide you. The Celtic Realm acknowledges your crafting skills.";
                    } else {
                        message += "You survived the journey through the Celtic Realm, but without animal companions or crafted items. Consider this a learning experience for your next adventure.";
                    }
                    
                    gameOverMessage.value = message;
                }
                
                function resetGame() {
                    // Reset all game state
                    gameState.value = 'setup';
                    selectedCharacter.value = null;
                    healthPoints.value = 6;
                    resourceCounter.value = 1;
                    journeyProgress.value = 0;
                    currentLandscapeIndex.value = 0;
                    landscapeChallengeResolved.value = false;
                    seasonalActionUsed.value = false;
                    animalCompanionUsed.value = false;
                    resourceGathered.value = false;
                    selectedCompanion.value = null;
                    selectedResources.value = [];
                    playerResources.value = [];
                    playerCraftedItems.value = [];
                    activeAnimalCompanions.value = [];
                    currentSeasonIndex.value = 0;
                    messageLog.value = ['Welcome to Pathfinder\'s Journey! Choose a character to begin your adventure.'];
                }
                
                return {
                    // State
                    gameState,
                    selectedCharacter,
                    healthPoints,
                    resourceCounter,
                    journeyProgress,
                    challengeDieValue,
                    currentLandscapeIndex,
                    landscapeChallengeResolved,
                    seasonalActionUsed,
                    animalCompanionUsed,
                    resourceGathered,
                    selectedCompanion,
                    selectedResources,
                    messageLog,
                    playerResources,
                    playerCraftedItems,
                    activeAnimalCompanions,
                    currentSeasonIndex,
                    landscapePath,
                    showModal,
                    modalTitle,
                    modalContent,
                    gameOverMessage,
                    
                    // Computed
                    currentLandscape,
                    currentSeason,
                    availableAnimalCompanions,
                    availableResources,
                    craftableItems,
                    
                    // Methods
                    selectCharacter,
                    getCharacter,
                    startGame,
                    performSeasonalAction,
                    resolveLandscapeChallenge,
                    useAnimalCompanion,
                    selectCompanion,
                    gatherRandomResource,
                    acquireAnimalCompanion,
                    toggleResourceSelection,
                    startCrafting,
                    craftItem,
                    moveToNextLandscape,
                    canMoveToNextLandscape,
                    resetGame,
                    
                    // Data
                    characters,
                    landscapes,
                    animalCompanions,
                    resources,
                    craftedItems,
                    seasons
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 gabe-harris-modernfold

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="public/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title>Pathfinder's Journey: The Celtic Realm</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <noscript>
      <strong>We're sorry but Pathfinder's Journey doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>
</file>

<file path="src/App.vue">
<template>
  <GameLayout>
    <router-view />
  </GameLayout>
</template>

<script setup lang="ts">
import GameLayout from '@/components/layout/GameLayout.vue';
</script>

<style lang="scss">
@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Tangerine:wght@400;700&display=swap');
@import '@/assets/scss/main.scss';

// Global styles
body {
  margin: 0;
  padding: 0;
  font-family: 'Cinzel', serif;
}

// Reset some default styles
* {
  box-sizing: border-box;
}

// Utility classes
.text-center {
  text-align: center;
}

.mt-2 {
  margin-top: 2rem;
}

.mb-2 {
  margin-bottom: 2rem;
}
</style>
</file>

<file path="src/assets/.md">
# PATHFINDER'S JOURNEY: THE CELTIC REALM
## COMPLETE GAME RULES

*A 54-card strategic solo adventure game with seasonal mechanics, animal companions, and character progression set in a mystical Celtic world where balance must be maintained as the wheel of the year turns.*
 
---

## CONTENTS
1. [Game Overview](#game-overview)
2. [Game Components](#game-components)
3. [Card Types](#card-types)
4. [Game Setup](#game-setup)
5. [Core Game Mechanics](#core-game-mechanics)
6. [Turn Sequence](#turn-sequence)
7. [Challenge Resolution](#challenge-resolution)
8. [Resource Management](#resource-management)
9. [Animal Companions](#animal-companions)
10. [Crafting System](#crafting-system)
11. [Seasonal Mechanics](#seasonal-mechanics)
12. [Threat System](#threat-system)
13. [Journey Navigation](#journey-navigation)
14. [Character Progression](#character-progression)
15. [Healing and Recovery](#healing-and-recovery)
16. [Victory Conditions](#victory-conditions)
17. [Advanced Rules](#advanced-rules)
18. [Quick Reference Guide](#quick-reference-guide)

---

## GAME OVERVIEW

Pathfinder's Journey: The Celtic Realm is a solo adventure game where you navigate through a mystical Celtic landscape. As you journey, you'll overcome challenges, gather resources, form bonds with Animal Companions, craft magical items, and maintain balance with the natural and supernatural worlds while the seasons change around you.

Your goal is to complete a circular journey through the Celtic Realm, returning with knowledge, artifacts, and allies while keeping the forces of chaos at bay.

---

## GAME COMPONENTS

- 54 Cards:
  - 15 Landscape Cards
  - 10 Animal Companion Cards
  - 12 Resource Cards
  - 8 Crafted Item Cards
  - 5 Season Cards
  - 4 Character Cards
- 4 six-sided dice (used as counters for resources, health, and seasonal progress)
- 1 special eight-sided die (used for challenges)
- 12 Threat tokens (used to track growing dangers)
- 8 Blessing tokens (used to track favors from the spirits)
- 1 Seasonal Wheel board (to track seasonal changes and effects)

---

## CARD TYPES

### Landscape Cards (15)
*Identified by stone arch border*

These cards represent the locations you'll visit on your journey. Each has a unique challenge to overcome:

1. **Ancient Stone Circle** - *Challenge: Spectral Guardians (Wisdom)*
2. **Misty Barrow Downs** - *Challenge: Ancestral Spirits (Courage)*
3. **Sacred Oak Grove** - *Challenge: Wild Beasts (Stealth)*
4. **Thatched Village** - *Challenge: Suspicious Elders (Charm)*
5. **Iron Forge Dell** - *Challenge: Molten Trials (Strength)*
6. **Moonlit Loch** - *Challenge: Water Spirits (Patience)*
7. **Menhir Path** - *Challenge: Stone Sentinels (Perception)*
8. **Faerie Knoll** - *Challenge: Trickster Beings (Cunning)*
9. **Whispering Heath** - *Challenge: Deceptive Paths (Navigation)*
10. **Blackthorn Maze** - *Challenge: Thorny Barriers (Endurance)*
11. **Boggy Lowlands** - *Challenge: Sinking Ground (Agility)*
12. **Gathering Fair** - *Challenge: Rival Seekers (Trade)*
13. **Elder Bridge** - *Challenge: Guardian Toll (Sacrifice)*
14. **Druid's Sanctuary** - *Challenge: Wisdom Trial (Knowledge)*
15. **Wild Horse Plain** - *Challenge: Untamed Spirits (Connection)*

### Animal Companion Cards (10)
*Identified by paw print corner*

These cards represent animal allies that offer unique abilities:

1. **Raven Scout** - *Ability: Reveal next Landscape card*
2. **Wolf Guardian** - *Ability: +2 to combat-related challenges*
3. **Deer Guide** - *Ability: Move an extra Landscape without challenge*
4. **Bear Protector** - *Ability: Prevent up to 3 damage from one challenge*
5. **Hare Pathfinder** - *Ability: Re-roll one failed challenge roll*
6. **Boar Digger** - *Ability: Collect one extra Resource card*
7. **Fox Trickster** - *Ability: Manipulate one die roll by 2*
8. **Owl Sage** - *Ability: Gain insight to bypass one challenge without rolling*
9. **Salmon Journeyer** - *Ability: Return to a previous Landscape instantly*
10. **Horse Carrier** - *Ability: Carry 3 extra Resource cards temporarily*

### Resource Cards (12)
*Identified by woven basket symbol*

These cards represent materials you can gather and use for crafting:

1. **Rowan Wood** - *Effect: Wards against supernatural threats*
2. **Bog Iron** - *Effect: Strengthens crafted items*
3. **Silver Mistletoe** - *Effect: Opens pathways between worlds*
4. **Standing Stone Chips** - *Effect: Enhances divination abilities*
5. **Woven Reeds** - *Effect: Creates protective barriers*
6. **Horse Hair** - *Effect: Binds magical energies*
7. **Oak Galls** - *Effect: Preserves magical properties*
8. **Amber Shards** - *Effect: Stores spiritual energy*
9. **Barrow Dust** - *Effect: Communes with ancestral spirits*
10. **Forge Cinders** - *Effect: Transforms magical properties*
11. **Sacred Water** - *Effect: Purifies corrupted elements*
12. **Ogham Sticks** - *Effect: Deciphers magical writing*

### Crafted Item Cards (8)
*Identified by anvil symbol*

These cards represent magical items you can create by combining resources:

1. **Beast Speaker Charm** (Horse Hair + Amber + Oak Galls)
   - *Ability: Command any Animal Companion regardless of season*
   - *Drawback: The charm slowly drains your vitality (-1 Health per 3 turns)*

2. **Colossal Whistle** (Rowan Wood + Silver Mistletoe)
   - *Ability: Summon aid from great beasts to overcome any physical challenge*
   - *Drawback: May attract unwanted attention (add 2 Threat tokens)*

3. **Earth Speaker Staff** (Rowan Wood + Standing Stone Chip + Barrow Dust)
   - *Ability: Automatically succeed wisdom and knowledge challenges*
   - *Drawback: Each use ages the wielder (lose 1 Resource capacity)*

4. **Giant's Bridle** (Bog Iron + Horse Hair + Woven Reeds)
   - *Ability: Control powerful entities and redirect their strength*
   - *Drawback: The controlled entity may break free (roll D8 each use, free on 1-2)*

5. **Ogham Divining Set** (Oak Galls + Sacred Water + Ogham Sticks)
   - *Ability: Foresee and avoid one challenge completely*
   - *Drawback: Glimpsing fate may reveal unwelcome truths (draw a Curse card)*

6. **Seasonal Compass** (Amber Shards + Standing Stone Chips + Forge Cinders)
   - *Ability: Change the current season for one round*
   - *Drawback: Disrupts natural order (add 1 Threat token)*

7. **Iron Grove Key** (Bog Iron + Silver Mistletoe + Forge Cinders)
   - *Ability: Unlock hidden paths and secret areas on Landscape cards*
   - *Drawback: Opens doors for otherworldly beings (roll on Manifestation table)*

8. **Spirit Bridge Tokens** (Barrow Dust + Sacred Water + Amber Shards)
   - *Ability: Travel instantly to any previously visited Landscape*
   - *Drawback: Spiritual disorientation (-2 to next challenge roll)*

### Season Cards (5)
*Identified by wheel symbol*

These cards represent the turning of the Celtic year and its effects on your journey:

1. **Samhain** (Winter Beginning)
   - *Effect: Veil between worlds is thin, spiritual challenges are harder (+2 difficulty)*
   - *Benefit: Ancestral guidance available (may consult discard pile once)*
   - *Resource Abundance: Barrow Dust, Standing Stone Chips*
   - *Resource Scarcity: Woven Reeds, Rowan Wood*

2. **Winter's Depth**
   - *Effect: Harsh conditions make physical challenges harder (+2 difficulty)*
   - *Benefit: Clearer thinking in stillness (+1 to wisdom challenges)*
   - *Resource Abundance: Forge Cinders, Bog Iron*
   - *Resource Scarcity: Sacred Water, Horse Hair*

3. **Imbolc** (Spring Stirrings)
   - *Effect: Renewal energy makes healing more effective (recover +1 Health)*
   - *Benefit: New growth provides hope (+1 to all challenge rolls)*
   - *Resource Abundance: Silver Mistletoe, Sacred Water*
   - *Resource Scarcity: Barrow Dust, Forge Cinders*

4. **Beltane** (Summer Beginning)
   - *Effect: Vibrant energy enhances all crafting (crafted items gain +1 use)*
   - *Benefit: Life force is strong (max Health increased by 1)*
   - *Resource Abundance: Rowan Wood, Oak Galls*
   - *Resource Scarcity: Standing Stone Chips, Amber Shards*

5. **Lughnasadh** (Harvest Beginning)
   - *Effect: Gathering time (collect +1 Resource when successful)*
   - *Benefit: Community support (double the effectiveness of healing)*
   - *Resource Abundance: Horse Hair, Woven Reeds, Ogham Sticks*
   - *Resource Scarcity: Bog Iron, Silver Mistletoe*

### Character Cards (4)
*Identified by silhouette symbol*

These cards represent the different types of pathfinders you can play as:

1. **Giant Beastfriend**
   - *Starting Ability: Animal Empathy (Animal Companions cost -1 resource)*
   - *Health: 7 (base)*
   - *Resource Capacity: 8*
   - *Special Rule: May use two Animal Companions simultaneously*
   - *Weakness: Cannot use crafted items containing Bog Iron without penalty*

2. **Hedge Witch/Warlock**
   - *Starting Ability: Herbal Knowledge (can substitute one resource for another)*
   - *Health: 5 (base)*
   - *Resource Capacity: 7*
   - *Special Rule: May craft one additional item beyond normal limits*
   - *Weakness: -2 penalty on all social challenges in villages*

3. **Iron Crafter**
   - *Starting Ability: Master Smith (crafting requires one fewer resource)*
   - *Health: 6 (base)*
   - *Resource Capacity: 6*
   - *Special Rule: Crafted items have one additional use before breaking*
   - *Weakness: Cannot use Animal Companions effectively (-1 to their abilities)*

4. **Village Elder**
   - *Starting Ability: Ancient Wisdom (start with knowledge of entire journey path)*
   - *Health: 5 (base)*
   - *Resource Capacity: 5*
   - *Special Rule: Can invoke communal aid once per season (automatic success)*
   - *Weakness: Physical challenges are more difficult (+1 difficulty)*

---

## GAME SETUP

1. **Prepare the Journey Path**:
   - Arrange the 15 Landscape cards in a circular path, face-down:
     * Cards 1-12: Outward journey
     * Cards 13-15: Return journey
   - Reveal the first Landscape card (your starting point)

2. **Set the Season**:
   - Place the Samhain Season card face up (starting season)
   - Place the Seasonal Wheel in the center with marker on Samhain

3. **Choose Your Character**:
   - Select one of the four Character cards
   - Set your starting dice values:
     * Red die: Health (from your character card)
     * Green die: Resource Capacity (from your character card)
     * Blue die: Journey Progress (starts at 0)

4. **Prepare the Decks**:
   - Place all Animal Companion, Resource, and Crafted Item cards in separate face-up decks
   - If playing as Village Elder, you may look at all Landscape cards in order, then return them face down

5. **Starting Tokens**:
   - Start with 0 Threat tokens
   - Start with 1 Blessing token

---

## CORE GAME MECHANICS

### Challenge Resolution System
The heart of the game is overcoming challenges at each Landscape. Challenges represent obstacles, guardians, or trials you must face to progress on your journey.

### Resource Management
Gathering, carrying, and using resources wisely is crucial. Resources are used to feed Animal Companions, craft magical items, and sometimes overcome specific challenges.

### Animal Companions
These spiritual animals can join your journey, offering unique abilities that help overcome challenges, but they require care and feeding.

### Crafting System
By combining specific resources, you can create powerful magical items that grant special abilities, though each comes with a drawback.

### Seasonal Cycle
The Celtic year turns as you progress, affecting challenge difficulties, resource availability, and offering unique opportunities.

### Threat Accumulation
Certain actions and failures increase the spiritual imbalance of your journey, represented by Threat tokens. Managing this threat is vital for success.

---

## TURN SEQUENCE

Each turn consists of the following phases:

### 1. Seasonal Assessment
- Check the current Season card for effects
- If you've reached a seasonal boundary, advance the Season marker:
  * Samhain (Starting season): Landscapes 1-3
  * Winter's Depth: Landscapes 4-6
  * Imbolc: Landscapes 7-9
  * Beltane: Landscapes 10-12
  * Lughnasadh: Landscapes 13-15
- Apply all seasonal effects immediately

### 2. Threat Level Check
- Count your Threat tokens
- For each 3 tokens, increase challenge difficulty by +1
- At 5+ Threat tokens: Draw a random event at the start of your turn
- At 10+ Threat tokens: Roll on the Otherworldly Manifestation table

### 3. Landscape Challenge
- Identify the challenge on your current Landscape card
- Calculate the challenge difficulty:
  * Base Difficulty (4-8) + Season Modifier (+/-2) + Threat Modifier (+1 per 3 tokens)
- Calculate your bonus:
  * Character Ability (+/-2) + Item Bonuses + Blessing tokens (each +1)
- Roll the eight-sided die and add your bonus
- Note: A natural 8 always succeeds regardless of modifiers

### 4. Challenge Resolution
- **Success** (Roll + bonus  difficulty): 
  * Move to the next Landscape card
  * Gain 2 resources from the current Landscape
  * Potentially gain a Blessing token (on exceptional success)
- **Partial Success** (Roll + bonus = difficulty - 1): 
  * Move forward but suffer a minor setback
  * Gain 1 resource from the current Landscape
- **Failure** (Roll + bonus < difficulty - 1):
  * Suffer consequences based on challenge type:
    - Physical challenges: Lose 1-3 Health
    - Mental challenges: Add 1-2 Threat tokens
    - Social challenges: Lose access to a resource type temporarily
    - Spiritual challenges: Animal Companions become wary
  * Stay on the current Landscape card

### 5. Resource Management
- Resource availability determined by:
  * Current Landscape (each offers 2-3 specific resources)
  * Current season (affects abundance/scarcity)
- Your Resource capacity is shown on your green die
- If you exceed capacity, immediately discard excess resources
- Some resources change or spoil with seasonal transitions

### 6. Animal Companion Action
- You may call upon one Animal Companion (or two for Giant Beastfriend)
- Each companion has a special ability that can help with challenges
- Each use requires feeding (1 Resource):
  * Preferred resources grant +1 to companion's effectiveness
  * Any resource type can be used
- If you don't feed a companion:
  * First failure: Companion becomes "Wary" (flip card face-down)
  * Second consecutive failure: Companion leaves (discard card)
- You can gain new companions at specific Landscapes

### 7. Crafting (Optional)
- Requirements:
  * Specified resources in your inventory
  * Appropriate Landscape type (or any Landscape with -1 penalty)
  * Successful craft check: Roll D8 + Character modifier  item complexity
- Item complexity:
  * Simple items: Difficulty 5
  * Complex items: Difficulty 6
  * Legendary items: Difficulty 7
- Items have limited uses (1-4 depending on item)
- Failed crafting doesn't consume resources

### 8. Journey Progression
- If you successfully resolved the challenge, advance your Journey Progress tracker
- Check for character advancement milestones:
  * At 5 experience: Choose one minor improvement
  * At 10 experience: Choose one major improvement
  * At 15 experience: Unlock character's ultimate ability
- Reveal the next Landscape card if moving forward

---

## CHALLENGE RESOLUTION

Challenges are the core of your journey and represent obstacles or trials at each location.

### Challenge Types

- **Physical Challenges**: Tests of strength, agility, or endurance
  * Failure consequences: Lose 1-3 Health
  * Examples: Molten Trials, Thorny Barriers, Sinking Ground

- **Mental Challenges**: Tests of wisdom, perception, or knowledge
  * Failure consequences: Add 1-2 Threat tokens
  * Examples: Spectral Guardians, Stone Sentinels, Wisdom Trial

- **Social Challenges**: Tests of charm, cunning, or trade
  * Failure consequences: Lose access to a resource type temporarily
  * Examples: Suspicious Elders, Rival Seekers, Trickster Beings

- **Spiritual Challenges**: Tests of courage, connection, or patience
  * Failure consequences: Animal Companions become wary
  * Examples: Ancestral Spirits, Water Spirits, Untamed Spirits

### Challenge Difficulty
- Base difficulty for each challenge is listed on the Landscape card (4-8)
- Modified by:
  * Current season (certain challenges are +2 harder in specific seasons)
  * Threat level (every 3 Threat tokens = +1 difficulty)
  * Character weaknesses/strengths
  * Crafted items (may provide bonuses)
  * Animal Companion assistance

### Challenge Resolution Process
1. Determine difficulty: Base Difficulty + Season Modifier + Threat Modifier
2. Calculate your bonus: Character Ability + Item Bonuses + Blessing tokens
3. Roll D8 and add your bonus
4. Compare to difficulty:
   - Success: Roll + bonus  difficulty
   - Partial Success: Roll + bonus = difficulty - 1
   - Failure: Roll + bonus < difficulty - 1
5. A natural 8 always succeeds regardless of modifiers

### Challenge Results
- **Success**: Move forward, collect resources, potentially gain Blessing token
- **Partial Success**: Move forward but suffer minor setback, collect reduced resources
- **Failure**: Stay in place, suffer consequences based on challenge type

---

## RESOURCE MANAGEMENT

Resources are vital materials used for crafting, feeding Animal Companions, and sometimes directly affecting challenges.

### Resource Types
There are 12 different resources, each with unique properties:
- **Protective**: Rowan Wood, Woven Reeds
- **Crafting Base**: Bog Iron, Oak Galls
- **Spiritual**: Silver Mistletoe, Barrow Dust
- **Elemental**: Forge Cinders, Sacred Water
- **Binding**: Horse Hair, Amber Shards
- **Mystic**: Standing Stone Chips, Ogham Sticks

### Gathering Resources
- **On successful challenge**: Gain 2 resources from the current Landscape
- **On partial success**: Gain 1 resource from the current Landscape
- Resources available are determined by:
  * Landscape type (each has 2-3 associated resources)
  * Current season (abundance/scarcity modifies availability)

### Resource Capacity
- Your maximum resource capacity is shown on your green die
- If you exceed capacity, you must immediately discard excess resources
- Certain Animal Companions or items can temporarily increase capacity

### Seasonal Effects on Resources
Each season makes certain resources more abundant and others scarce:
- **Samhain**: Abundant - Barrow Dust, Standing Stone Chips
  Scarce - Woven Reeds, Rowan Wood
- **Winter's Depth**: Abundant - Forge Cinders, Bog Iron
  Scarce - Sacred Water, Horse Hair
- **Imbolc**: Abundant - Silver Mistletoe, Sacred Water
  Scarce - Barrow Dust, Forge Cinders
- **Beltane**: Abundant - Rowan Wood, Oak Galls
  Scarce - Standing Stone Chips, Amber Shards
- **Lughnasadh**: Abundant - Horse Hair, Woven Reeds, Ogham Sticks
  Scarce - Bog Iron, Silver Mistletoe

### Resource Uses
1. **Feeding Animal Companions**: 1 resource per use
2. **Crafting Magic Items**: Specific combinations required
3. **Special Effects**: Some resources can be used directly
   - Sacred Water: Remove 1 Threat token or heal 1 Health
   - Rowan Wood: Prevent 1 additional Threat token accumulation
   - Barrow Dust: Commune with spirits for hints

---

## ANIMAL COMPANIONS

Animal Companions are spiritual beings that can join your journey, offering unique abilities to help overcome challenges.

### Gaining Companions
- Start with no Animal Companions
- Can encounter and bond with companions at specific Landscapes:
  * Sacred Oak Grove (Wolf, Deer, Bear, Boar)
  * Faerie Knoll (Fox, Hare)
  * Moonlit Loch (Salmon, Owl)
  * Whispering Heath (Raven)
  * Wild Horse Plain (Horse)
- Bonding requires:
  * Successful challenge
  * Appropriate offering (specific resource)

### Using Companions
- Each companion has a unique ability that can help with challenges
- Animal effectiveness varies by season (some stronger in winter, others in summer)
- Each use requires feeding the companion (1 Resource)
- You may call upon one companion per turn (or two for Giant Beastfriend)

### Feeding Requirements
- All companions accept any resource type
- Each companion has preferred resources:
  * Wolf: Prefers meat-associated resources (Bog Iron)
  * Bear: Prefers protective resources (Rowan Wood, Woven Reeds)
  * Deer: Prefers growth resources (Silver Mistletoe, Oak Galls)
  * Raven: Prefers spiritual resources (Barrow Dust, Standing Stone Chips)
  * Etc.
- Using preferred resources grants +1 to companion's effectiveness

### Companion Loyalty
- If you don't feed a companion when using it:
  * First failure: Companion becomes "Wary" (flip card face-down)
  * Second consecutive failure: Companion leaves (discard card)
- A wary companion can be restored by feeding it twice in the same turn

### Seasonal Affinities
Each companion has seasons they are more powerful in:
- **Winter Creatures** (stronger in Samhain/Winter's Depth): Wolf, Raven, Owl
- **Spring Creatures** (stronger in Imbolc): Hare, Deer, Salmon
- **Summer Creatures** (stronger in Beltane): Fox, Horse, Bear
- **Harvest Creatures** (stronger in Lughnasadh): Boar

During their preferred season, companions gain +1 to their ability effectiveness.

---

## CRAFTING SYSTEM

By combining specific resources, you can create powerful magical items that grant special abilities, though each comes with a drawback.

### Crafting Requirements
- Having the specified resources in your inventory
- Being at an appropriate Landscape (or any Landscape with -1 penalty)
- Successful craft check: Roll D8 + Character modifier  item complexity

### Item Complexity
- **Simple items** (2 resources): Difficulty 5
- **Complex items** (3 resources): Difficulty 6
- **Legendary items** (4+ resources): Difficulty 7

### Crafting Locations
Certain Landscapes are better for crafting specific items:
- **Iron Forge Dell**: +1 to craft metal items (containing Bog Iron)
- **Sacred Oak Grove**: +1 to craft wooden items (containing Rowan Wood)
- **Druid's Sanctuary**: +1 to craft spiritual items (containing Standing Stone Chips)
- **Moonlit Loch**: +1 to craft water-based items (containing Sacred Water)

### Item Uses
- Each item has limited uses (1-4 depending on item)
- Iron Crafter character gets +1 use
- Beltane season grants +1 use
- When all uses are expended, the item breaks (discard card)

### Crafting Process
1. Declare which item you wish to craft
2. Verify you have the required resources
3. Check if you're at an appropriate Landscape
4. Roll crafting check (D8 + Character modifier)
5. If successful, discard the resources and take the Crafted Item card
6. If unsuccessful, keep resources and try again later

### Item Drawbacks
Every crafted item has a drawback that balances its power:
- Health loss
- Threat accumulation
- Resource capacity reduction
- Unreliability
- Attracting unwanted attention

These drawbacks occur either upon use or as an ongoing effect while the item is in your possession.

---

## SEASONAL MECHANICS

The Celtic year turns as you progress through your journey, affecting challenges, resources, and offering unique opportunities.

### Seasonal Progression
- Fixed seasonal progression:
  * Samhain (Starting season): Landscapes 1-3
  * Winter's Depth: Landscapes 4-6
  * Imbolc: Landscapes 7-9
  * Beltane: Landscapes 10-12
  * Lughnasadh: Landscapes 13-15

### Seasonal Transition
- Occurs automatically upon reaching the designated Landscape
- Apply all season effects immediately
- Check for any seasonal quest opportunities

### Seasonal Effects

**Samhain (Winter Beginning)**
- *Effect*: Veil between worlds is thin, spiritual challenges harder (+2 difficulty)
- *Benefit*: Ancestral guidance available (may consult discard pile once)
- *Resource Abundance*: Barrow Dust, Standing Stone Chips
- *Resource Scarcity*: Woven Reeds, Rowan Wood
- *Animal Affinity*: Wolf, Raven, Owl (+1 effectiveness)

**Winter's Depth**
- *Effect*: Harsh conditions make physical challenges harder (+2 difficulty)
- *Benefit*: Clearer thinking in stillness (+1 to wisdom challenges)
- *Resource Abundance*: Forge Cinders, Bog Iron
- *Resource Scarcity*: Sacred Water, Horse Hair
- *Animal Affinity*: Wolf, Raven, Owl (+1 effectiveness)

**Imbolc (Spring Stirrings)**
- *Effect*: Renewal energy makes healing more effective (recover +1 Health)
- *Benefit*: New growth provides hope (+1 to all challenge rolls)
- *Resource Abundance*: Silver Mistletoe, Sacred Water
- *Resource Scarcity*: Barrow Dust, Forge Cinders
- *Animal Affinity*: Hare, Deer, Salmon (+1 effectiveness)

**Beltane (Summer Beginning)**
- *Effect*: Vibrant energy enhances all crafting (crafted items gain +1 use)
- *Benefit*: Life force is strong (max Health increased by 1)
- *Resource Abundance*: Rowan Wood, Oak Galls
- *Resource Scarcity*: Standing Stone Chips, Amber Shards
- *Animal Affinity*: Fox, Horse, Bear (+1 effectiveness)

**Lughnasadh (Harvest Beginning)**
- *Effect*: Gathering time (collect +1 Resource when successful)
- *Benefit*: Community support (double the effectiveness of healing)
- *Resource Abundance*: Horse Hair, Woven Reeds, Ogham Sticks
- *Resource Scarcity*: Bog Iron, Silver Mistletoe
- *Animal Affinity*: Boar (+1 effectiveness)

### Seasonal Quests
Each season offers an optional quest that appears on the Seasonal Wheel:

**Samhain Quest**: Honor the Ancestors
- Visit the Misty Barrow Downs
- Make an offering of Barrow Dust
- Reward: Gain the protection of an ancestor (+1 to all challenges until next season)

**Winter's Depth Quest**: Forge of Endurance
- Visit the Iron Forge Dell
- Craft an item containing Bog Iron
- Reward: Gain +1 max Health permanently

**Imbolc Quest**: Awakening the Land
- Visit the Sacred Oak Grove
- Plant a seed (discard Oak Galls)
- Reward: Remove 3 Threat tokens

**Beltane Quest**: Sacred Union
- Visit the Faerie Knoll
- Successfully complete a challenge with two different Animal Companions
- Reward: Gain a unique Blessing token that can be used twice

**Lughnasadh Quest**: First Harvest
- Visit the Gathering Fair
- Trade 3 resources for 1 Crafted Item component
- Reward: Gain +1 Resource capacity permanently

---

## THREAT SYSTEM

The Threat system represents the growing spiritual imbalance and chaos that may follow your actions.

### Threat Accumulation
Threat tokens accumulate through:
- Failed challenges: +1-2 tokens (based on challenge type)
- Using powerful crafted items: +1-3 tokens (as listed on item)
- Crossing seasonal boundaries unprepared: +2 tokens
- Disrespecting sacred sites: +1-3 tokens

### Threat Effects
- For each 3 Threat tokens, increase all challenge difficulties by +1
- At 5+ Threat tokens: Draw a random event at the start of each turn
- At 10+ Threat tokens: Roll on the Otherworldly Manifestation table

### Threat Reduction
Threat can be reduced by:
- Sacred sites:
  * Moonlit Loch: Remove 1-3 tokens through purification ritual
  * Druid's Sanctuary: Remove 2 tokens through meditation
- Specific resources:
  * Sacred Water: Remove 1 token when used
  * Rowan Wood: Prevent 1 token accumulation when used
- Seasonal purification rituals: Available once per season
- Maximum reduction per turn: 3 tokens

### Otherworldly Manifestations
At high Threat levels, roll on this table when triggered:
1. **Mist Wraith**: Obscures path, requires Amber Shards to banish
2. **Barrow Wight**: Drains health each turn, must outrun or confront
3. **Faerie Enticement**: Attempts to lead you astray, requires willpower challenge
4. **Wild Hunt**: Pursues you for 1d4 turns, must hide or join the hunt
5. **Ancient Guardian**: Blocks path, requires specific offering or riddling
6. **Boundary Collapse**: Seasons blur, unpredictable effects each turn
7. **Spirit Possession**: Animal Companion turns against you
8. **Cosmic Imbalance**: All challenges +2 difficulty until balance restored

---

## JOURNEY NAVIGATION

The journey through the Celtic Realm follows a circular path, with challenges and opportunities along the way.

### Journey Structure
- The 15 Landscape cards form a circular path:
  * First 12 cards: Outward journey
  * Last 3 cards: Return journey
- Each Landscape has a unique challenge associated with it

### Movement Options
- After successful challenge: Move forward one card
- After partial success: Move forward one card with minor consequences
- After failure: Stay in place
- Using specific items/companions: May move backward one card or to specific locations
- No skipping Landscapes (except with specific abilities)

### Revisiting Landscapes
- Challenges are easier on revisit (-1 difficulty)
- Resource availability is reduced (only 1 resource per success)
- Some locations have different effects on return journey (final 3 cards)

### Hidden Paths
Certain items or successful perception challenges may reveal hidden paths:
- **Iron Grove Key**: Reveals hidden paths between certain Landscapes
- **Spirit Bridge Tokens**: Allows instant travel to previously visited locations
- **Raven Scout**: Reveals information about the next Landscape
- **Salmon Journeyer**: Allows return to a previous Landscape

---

## CHARACTER PROGRESSION

As you journey, your character will grow and develop new abilities.

### Experience Points
Characters gain experience from:
- Overcoming difficult challenges (difficulty 6+): +1 XP
- Crafting complex items: +1 XP
- Forming bonds with Animal Companions (feeding 3 times): +1 XP
- Discovering hidden locations: +1 XP
- Completing seasonal quests: +2 XP

### Advancement Milestones
- **At 5 experience**: Choose one minor improvement
- **At 10 experience**: Choose one major improvement
- **At 15 experience**: Unlock character's ultimate ability

### Improvement Examples
- **Minor Improvements**:
  * +1 Health
  * +1 Resource capacity
  * New skill (e.g., Foraging, Navigation, Spirit Sight)
  * +1 to specific challenge types

- **Major Improvements**:
  * +2 Health
  * Special ability (unique to character)
  * Reduced threat accumulation
  * Animal Companion specialization
  * Crafting expertise

- **Ultimate Abilities** (Character-specific):
  * **Giant Beastfriend**: Wild Shape (transform into any Animal Companion)
  * **Hedge Witch/Warlock**: Elemental Mastery (control weather and elements)
  * **Iron Crafter**: Legendary Forge (craft items with no drawbacks)
  * **Village Elder**: Ancient Pact (call upon powerful allies from any location)

### Character Development
- Track experience on the Journey Progress tracker (blue die)
- When reaching a milestone, choose an improvement and note it
- Character development persists throughout the journey

---

## HEALING AND RECOVERY

Maintaining your health is crucial for completing your journey.

### Health System
- Your maximum health is shown on your red die
- Health does not regenerate naturally
- If health reaches 0, you must immediately retreat to the nearest healing location and lose 1-3 resources

### Healing Methods
- **Visiting healing locations**:
  * Sacred Oak Grove: +1-3 Health
  * Moonlit Loch: +1-2 Health
  * Druid's Sanctuary: +2 Health
- **Using specific resources**:
  * Sacred Water: +1 Health
  * Rowan Wood + Oak Galls: +1 Health when used together
- **Animal Companion abilities**:
  * Bear Protector: Prevent damage
  * Deer Guide: Minor healing (+1 Health)
- **Seasonal effects**:
  * Imbolc: +1 Health recovery
  * Lughnasadh: Double healing effectiveness

### Health Penalties
Health can be lost through:
- Failed physical challenges: -1-3 Health
- Using certain crafted items: Variable loss
- Exposure to elements: -1 Health per turn in certain conditions
- Otherworldly Manifestations: Variable loss

---

## VICTORY CONDITIONS

To successfully complete your journey through the Celtic Realm, you must achieve all of the following:

1. **Complete the Journey**: Successfully traverse all 15 Landscape cards, returning to your starting point
2. **Maintain Balance**: End with fewer than 6 Threat tokens
3. **Acquire Knowledge**: Return with at least 2 Crafted Items
4. **Form Bonds**: End with at least one Animal Companion
5. **Fulfill Your Quest**: Resolve your Character's personal quest (unique to each Character)

### Character Quests
Each character has a unique personal quest to fulfill:

- **Giant Beastfriend**: Bond with at least 4 different Animal Companions during your journey
- **Hedge Witch/Warlock**: Create at least 3 different Crafted Items
- **Iron Crafter**: Craft a Legendary Item (requires special materials and conditions)
- **Village Elder**: Visit all major sacred sites and perform rituals at each

---

## ADVANCED RULES

Once you're familiar with the basic game, you can incorporate these advanced rules for a deeper experience.

### Seasonal Quests
As described in the Seasonal Mechanics section, each season has an optional quest that grants unique rewards.

### Deep Crafting
Beyond the standard Crafted Items, special crafting locations allow for advanced items:
- Combining basic crafted items creates legendary artifacts
- Crafting during celestial events (solstice, equinox) imbues special properties
- Hidden recipes can be discovered through exploration and challenges

### Antagonist System
The Otherworld responds to your actions:
- High Threat levels attract specific antagonists
- Each antagonist has unique challenges and counter-strategies
- Some antagonists can be negotiated with rather than fought
- Defeating or appeasing antagonists grants significant rewards

### Character Specialization
Beyond the basic advancements, characters can specialize:
- Focus on specific challenge types (Physical, Mental, Social, Spiritual)
- Develop deep bonds with certain Animal Companions
- Master specific crafting techniques
- Attune to particular seasons

---

## QUICK REFERENCE GUIDE

### Challenge Resolution
- **Roll**: D8 + Character Modifier + Item Bonuses + Blessing tokens
- **Success**: Roll  Difficulty
- **Partial Success**: Roll = Difficulty - 1
- **Failure**: Roll < Difficulty - 1
- Natural 8 always succeeds

### Health Loss
- Failed physical challenges: -1-3 Health
- Crafted item drawbacks: Variable
- Exposure to elements: -1 Health in harsh conditions
- At 0 Health: Retreat to nearest healing location

### Resource Gathering
- Success: 2 resources from current Landscape
- Partial Success: 1 resource from current Landscape
- Based on Landscape and current season

### Threat Accumulation
- Failed challenges: +1-2 tokens
- Using powerful items: +1-3 tokens
- Crossing seasonal boundaries unprepared: +2 tokens
- Every 3 tokens: +1 difficulty to all challenges

### Seasonal Effects
- Changes every 3 Landscapes
- Affects challenge difficulties, resource availability, healing, and Animal Companions

### Crafting
- Requires specific resources and successful craft check
- Item complexity determines difficulty (5-7)
- Iron Crafter and Beltane season improve crafting

### Animal Companions
- Each use requires feeding (1 resource)
- Not feeding causes wary status, then companion leaves
- Companions have seasonal affinities
</file>

<file path="src/assets/scss/_animations.scss">
@import 'variables';

// Fade In
@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.fade-in {
  animation: fadeIn $transition-normal;
}

// Fade Out
@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.fade-out {
  animation: fadeOut $transition-normal;
}

// Slide In From Right
@keyframes slideInRight {
  from {
    transform: translateX(100%);
  }
  to {
    transform: translateX(0);
  }
}

.slide-in-right {
  animation: slideInRight $transition-normal;
}

// Slide In From Left
@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

.slide-in-left {
  animation: slideInLeft $transition-normal;
}

// Slide In From Top
@keyframes slideInTop {
  from {
    transform: translateY(-100%);
  }
  to {
    transform: translateY(0);
  }
}

.slide-in-top {
  animation: slideInTop $transition-normal;
}

// Slide In From Bottom
@keyframes slideInBottom {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

.slide-in-bottom {
  animation: slideInBottom $transition-normal;
}

// Bounce
@keyframes bounce {
  0%, 20%, 50%, 80%, 100% {
    transform: translateY(0);
  }
  40% {
    transform: translateY(-20px);
  }
  60% {
    transform: translateY(-10px);
  }
}

.bounce {
  animation: bounce $transition-slow;
}

// Pulse
@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

.pulse {
  animation: pulse $transition-slow infinite;
}

// Shake
@keyframes shake {
  0%, 100% {
    transform: translateX(0);
  }
  10%, 30%, 50%, 70%, 90% {
    transform: translateX(-5px);
  }
  20%, 40%, 60%, 80% {
    transform: translateX(5px);
  }
}

.shake {
  animation: shake $transition-normal;
}

// Rotate
@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.rotate {
  animation: rotate 2s linear infinite;
}

// Card Flip
@keyframes cardFlip {
  0% {
    transform: rotateY(0deg);
  }
  100% {
    transform: rotateY(180deg);
  }
}

.card-flip {
  animation: cardFlip $transition-normal;
  backface-visibility: hidden;
}

// Card Hover
@keyframes cardHover {
  0% {
    transform: translateY(0);
    box-shadow: $shadow-md;
  }
  100% {
    transform: translateY(-10px);
    box-shadow: $shadow-lg;
  }
}

.card-hover {
  transition: transform $transition-normal, box-shadow $transition-normal;
  
  &:hover {
    transform: translateY(-10px);
    box-shadow: $shadow-lg;
  }
}

// Dice Roll
@keyframes diceRoll {
  0% {
    transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
  }
  25% {
    transform: rotateX(90deg) rotateY(180deg) rotateZ(45deg);
  }
  50% {
    transform: rotateX(180deg) rotateY(90deg) rotateZ(90deg);
  }
  75% {
    transform: rotateX(270deg) rotateY(270deg) rotateZ(135deg);
  }
  100% {
    transform: rotateX(360deg) rotateY(360deg) rotateZ(180deg);
  }
}

.dice-roll {
  animation: diceRoll 1s ease-out;
}

// Seasonal Transition
@keyframes seasonalTransition {
  0% {
    opacity: 1;
    filter: hue-rotate(0deg);
  }
  50% {
    opacity: 0.7;
    filter: hue-rotate(180deg);
  }
  100% {
    opacity: 1;
    filter: hue-rotate(360deg);
  }
}

.seasonal-transition {
  animation: seasonalTransition 2s ease-in-out;
}

// Resource Collection
@keyframes resourceCollect {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.5);
    opacity: 0.8;
  }
  100% {
    transform: scale(0);
    opacity: 0;
  }
}

.resource-collect {
  animation: resourceCollect $transition-normal;
}

// Companion Appear
@keyframes companionAppear {
  0% {
    transform: scale(0.5);
    opacity: 0;
  }
  70% {
    transform: scale(1.1);
    opacity: 1;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.companion-appear {
  animation: companionAppear $transition-normal;
}

// Crafting Sparkle
@keyframes craftingSparkle {
  0%, 100% {
    opacity: 1;
    filter: brightness(1);
  }
  50% {
    opacity: 0.8;
    filter: brightness(1.5) saturate(1.5);
  }
}

.crafting-sparkle {
  animation: craftingSparkle 1s ease-in-out infinite;
}

// Health Change
@keyframes healthChange {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.7;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.health-increase {
  animation: healthChange $transition-normal;
  color: $success-color;
}

.health-decrease {
  animation: healthChange $transition-normal;
  color: $danger-color;
}

// Vue Transitions
.fade-enter-active,
.fade-leave-active {
  transition: opacity $transition-normal;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.slide-right-enter-active,
.slide-right-leave-active {
  transition: transform $transition-normal;
}

.slide-right-enter-from {
  transform: translateX(-100%);
}

.slide-right-leave-to {
  transform: translateX(100%);
}

.slide-up-enter-active,
.slide-up-leave-active {
  transition: transform $transition-normal;
}

.slide-up-enter-from {
  transform: translateY(100%);
}

.slide-up-leave-to {
  transform: translateY(-100%);
}
</file>

<file path="src/assets/scss/_typography.scss">
@import 'variables';

// Base Typography
body {
  font-family: $font-family-base;
  font-size: $font-size-base;
  line-height: 1.5;
  color: $dark-color;
  background-color: $light-color;
}

// Headings
h1, h2, h3, h4, h5, h6 {
  font-family: $font-family-display;
  margin-bottom: $spacing-md;
  font-weight: 700;
  line-height: 1.2;
  color: $primary-color;
}

h1 {
  font-size: $font-size-xxl;
  margin-top: $spacing-xl;
}

h2 {
  font-size: $font-size-xl;
  margin-top: $spacing-lg;
}

h3 {
  font-size: $font-size-lg;
  margin-top: $spacing-md;
}

h4 {
  font-size: $font-size-base;
  margin-top: $spacing-sm;
}

// Game Title
.game-title {
  font-family: $font-family-display;
  font-size: 2.5rem;
  font-weight: 700;
  color: $primary-color;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
  letter-spacing: 1px;
  text-align: center;
  margin-bottom: $spacing-lg;
}

// Card Titles
.card-title {
  font-family: $font-family-display;
  font-size: $font-size-lg;
  font-weight: 600;
  margin-bottom: $spacing-sm;
}

// Landscape Names
.landscape-name {
  font-family: $font-family-display;
  font-size: $font-size-lg;
  font-weight: 700;
  color: $landscape-color;
}

// Character Names
.character-name {
  font-family: $font-family-display;
  font-size: $font-size-lg;
  font-weight: 700;
  color: $character-color;
}

// Resource Names
.resource-name {
  font-family: $font-family-base;
  font-size: $font-size-base;
  font-weight: 600;
  color: $resource-color;
}

// Animal Companion Names
.companion-name {
  font-family: $font-family-base;
  font-size: $font-size-base;
  font-weight: 600;
  color: $animal-companion-color;
}

// Crafted Item Names
.item-name {
  font-family: $font-family-base;
  font-size: $font-size-base;
  font-weight: 600;
  color: $crafted-item-color;
}

// Season Names
.season-name {
  font-family: $font-family-display;
  font-size: $font-size-lg;
  font-weight: 700;
  
  &.samhain {
    color: $samhain-color;
  }
  
  &.winter {
    color: $winter-color;
  }
  
  &.imbolc {
    color: $imbolc-color;
  }
  
  &.beltane {
    color: $beltane-color;
  }
  
  &.lughnasadh {
    color: $lughnasadh-color;
  }
}

// Game Log
.game-log {
  font-family: $font-family-base;
  font-size: $font-size-sm;
  line-height: 1.4;
}

// Challenge Types
.challenge-type {
  font-weight: 600;
  
  &.physical {
    color: $physical-color;
  }
  
  &.mental {
    color: $mental-color;
  }
  
  &.social {
    color: $social-color;
  }
  
  &.spiritual {
    color: $spiritual-color;
  }
}

// Stats and Values
.stat-value {
  font-weight: 700;
  color: $accent-color;
}

.stat-label {
  font-weight: 600;
  color: $dark-color;
}

// Ability Descriptions
.ability-description {
  font-style: italic;
  color: $dark-color;
  font-size: $font-size-sm;
}

// Drawback Descriptions
.drawback-description {
  font-style: italic;
  color: $danger-color;
  font-size: $font-size-sm;
}

// Celtic Quotes
.celtic-quote {
  font-family: $font-family-handwritten;
  font-size: $font-size-xl;
  font-style: italic;
  color: $accent-color;
  text-align: center;
  margin: $spacing-lg 0;
  line-height: 1.4;
}

// Links
a {
  color: $accent-color;
  text-decoration: none;
  transition: color $transition-fast;
  
  &:hover {
    color: darken($accent-color, 15%);
    text-decoration: underline;
  }
}

// Button Text
.btn {
  font-family: $font-family-base;
  font-weight: 600;
  letter-spacing: 0.5px;
}

// Helper Classes
.text-center {
  text-align: center;
}

.text-right {
  text-align: right;
}

.text-bold {
  font-weight: 700;
}

.text-italic {
  font-style: italic;
}

.text-small {
  font-size: $font-size-sm;
}

.text-large {
  font-size: $font-size-lg;
}

.text-primary {
  color: $primary-color;
}

.text-secondary {
  color: $secondary-color;
}

.text-accent {
  color: $accent-color;
}

.text-success {
  color: $success-color;
}

.text-warning {
  color: $warning-color;
}

.text-danger {
  color: $danger-color;
}

.text-info {
  color: $info-color;
}
</file>

<file path="src/assets/styles.css">
/* Global Styles for Pathfinder's Journey */

/* Card Styles */
.card {
  background-color: #34495e;
  border-radius: 8px;
  padding: 15px;
  margin: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s ease;
}

.card:hover {
  transform: translateY(-5px);
}

.card-title {
  font-size: 1.2em;
  font-weight: bold;
  margin-bottom: 10px;
  color: #f3d35e;
}

.card-description {
  font-size: 0.9em;
  color: #bdc3c7;
}

/* Button Styles */
.game-button {
  background-color: #2980b9;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 16px;
  margin: 5px;
  cursor: pointer;
  font-weight: bold;
  transition: background-color 0.3s ease;
}

.game-button:hover {
  background-color: #3498db;
}

.game-button:disabled {
  background-color: #7f8c8d;
  cursor: not-allowed;
}

.action-button {
  background-color: #27ae60;
}

.action-button:hover {
  background-color: #2ecc71;
}

.danger-button {
  background-color: #c0392b;
}

.danger-button:hover {
  background-color: #e74c3c;
}

/* Game Board Layout */
.game-container {
  display: grid;
  grid-template-columns: 3fr 1fr;
  gap: 20px;
}

.game-board {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.game-sidebar {
  background-color: #2c3e50;
  border-radius: 8px;
  padding: 15px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Message Log */
.message-log {
  background-color: #2c3e50;
  border-radius: 8px;
  padding: 15px;
  margin-top: 20px;
  max-height: 200px;
  overflow-y: auto;
}

.message-log-title {
  font-size: 1.2em;
  font-weight: bold;
  margin-bottom: 10px;
  color: #f3d35e;
}

.message {
  padding: 5px 0;
  border-bottom: 1px solid #34495e;
}

/* Character Selection */
.character-selection {
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}

.character-card {
  background-color: var(--character-color);
  width: 250px;
}

/* Landscape Path */
.landscape-path {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}

.landscape-card {
  background-color: var(--landscape-color);
  width: 200px;
}

/* Animal Companions */
.animal-card {
  background-color: var(--animal-color);
  width: 180px;
}

/* Resources */
.resource-card {
  background-color: var(--resource-color);
  width: 150px;
}

/* Crafted Items */
.crafted-card {
  background-color: var(--crafted-color);
  width: 180px;
}

/* Season Display */
.season-display {
  background-color: var(--season-color);
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
  text-align: center;
}

.season-name {
  font-size: 1.5em;
  font-weight: bold;
  color: #f3d35e;
}

/* Game Stats */
.game-stats {
  display: flex;
  justify-content: space-around;
  background-color: #34495e;
  border-radius: 8px;
  padding: 15px;
  margin: 10px 0;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 1.8em;
  font-weight: bold;
  color: #f3d35e;
}

.stat-label {
  font-size: 0.9em;
  color: #bdc3c7;
}

/* Responsive Design */
@media (max-width: 768px) {
  .game-container {
    grid-template-columns: 1fr;
  }
}
</file>

<file path="src/assets/vue-js-initial-plan.md">
# Pathfinder's Journey: The Celtic Realm
## Comprehensive 10-Step Vue.js Development Plan

---

## Overview

This document outlines a detailed 10-step plan for developing "Pathfinder's Journey: The Celtic Realm" as a Vue.js application. Each step includes specific technical requirements, implementation details, and deliverables to ensure systematic progress.

---

## Technical Stack

- **Frontend Framework**: Vue 3.4+ with Composition API
- **State Management**: Pinia 2.x
- **Build Tool**: Vite 5.x
- **Type System**: TypeScript 5.x
- **CSS Preprocessor**: SCSS with modules
- **Testing Framework**: Vitest for unit testing, Cypress for E2E
- **Code Quality**: ESLint + Prettier

---

## Step 1: Project Foundation & Core Architecture

### Technical Requirements
- Establish project architecture with proper folder structure
- Configure TypeScript with strict type checking
- Set up Pinia stores with modular architecture
- Create foundational UI components with SCSS variables

### Implementation Details

#### Project Initialization
```bash
# Command line instructions
npm create vite@latest pathfinders-journey -- --template vue-ts
cd pathfinders-journey
npm install pinia vue-router sass
npm install -D vitest @vitejs/plugin-vue-jsx @vue/test-utils cypress
```

#### Folder Structure
```
pathfinders-journey/
 public/
    assets/
        fonts/
        icons/
 src/
    assets/
       scss/
           _variables.scss
           _typography.scss
           _animations.scss
    components/
       core/   # Base components
       game/   # Game-specific components
       layout/ # Layout components
    composables/
       useGameState.ts
    models/
       types/
          cards.ts
          game.ts
          player.ts
       enums/
           cardTypes.ts
           phases.ts
           seasons.ts
    stores/
       gameStore.ts
       playerStore.ts
       cardStore.ts
       index.ts
    views/
       GameSetupView.vue
       GameBoardView.vue
    router/
       index.ts
    App.vue
    main.ts
 tsconfig.json
 vite.config.ts
 package.json
```

#### Core Type Definitions
Define foundational interfaces and enums in `src/models/`:

**Game Phases**
```typescript
// src/models/enums/phases.ts
export enum GamePhase {
  SETUP = 'setup',
  SEASONAL_ASSESSMENT = 'seasonalAssessment',
  THREAT_CHECK = 'threatCheck',
  LANDSCAPE_CHALLENGE = 'landscapeChallenge',
  CHALLENGE_RESOLUTION = 'challengeResolution',
  RESOURCE_MANAGEMENT = 'resourceManagement',
  ANIMAL_COMPANION = 'animalCompanion',
  CRAFTING = 'crafting',
  JOURNEY_PROGRESSION = 'journeyProgression',
  GAME_OVER = 'gameOver'
}
```

**Card Types**
```typescript
// src/models/enums/cardTypes.ts
export enum CardType {
  LANDSCAPE = 'landscape',
  ANIMAL_COMPANION = 'animalCompanion',
  RESOURCE = 'resource',
  CRAFTED_ITEM = 'craftedItem',
  SEASON = 'season',
  CHARACTER = 'character'
}

export enum ChallengeType {
  PHYSICAL = 'physical',
  MENTAL = 'mental',
  SOCIAL = 'social',
  SPIRITUAL = 'spiritual'
}
```

#### Store Architecture
Create modular Pinia stores:

```typescript
// src/stores/gameStore.ts (structure only)
interface GameState {
  phase: GamePhase;
  turn: number;
  season: Season;
  threatTokens: number;
  blessingTokens: number;
  currentLandscapeId: string | null;
  visitedLandscapes: string[];
  seasonalWheel: {
    position: number;
    quests: { id: string; completed: boolean }[];
  };
  victoryConditions: {
    journeyCompleted: boolean;
    balanceMaintained: boolean;
    knowledgeAcquired: boolean;
    bondsFormed: boolean;
    questFulfilled: boolean;
  };
}
```

### Deliverables
- Configured Vue 3 project with TypeScript, Vite, and Pinia
- Complete folder structure with placeholders for all major components
- Core type definitions for game entities
- Basic SCSS design system with variables and mixins
- Initial Pinia store structure (unimplemented)
- Project README with setup instructions

---

## Step 2: Data Modeling & Card System

### Technical Requirements
- Implement comprehensive type definitions for all game entities
- Create card data structure with type safety
- Build initial card components with text-only representation
- Set up card repository system for data access

### Implementation Details

#### Core Data Models
Implement detailed interfaces for all game entities:

```typescript
// src/models/types/cards.ts
interface BaseCard {
  id: string;
  type: CardType;
  name: string;
  description?: string;
}

interface LandscapeCard extends BaseCard {
  type: CardType.LANDSCAPE;
  challenge: {
    type: ChallengeType;
    name: string;
    difficulty: number;
    description: string;
  };
  availableResources: string[]; // Resource IDs
  imagePlaceholder?: string; // For future image integration
}

// Similar interfaces for other card types
```

#### Card Repository
Implement a data service for managing cards:

```typescript
// src/services/cardRepository.ts (structure)
class CardRepository {
  // Internal storage
  private landscapes: Map<string, LandscapeCard>;
  private companions: Map<string, AnimalCompanionCard>;
  private resources: Map<string, ResourceCard>;
  private craftedItems: Map<string, CraftedItemCard>;
  private seasons: Map<string, SeasonCard>;
  private characters: Map<string, CharacterCard>;

  // Methods for accessing cards
  getLandscapeById(id: string): LandscapeCard | undefined;
  getCompanionById(id: string): AnimalCompanionCard | undefined;
  // ...other getters

  // Methods for filtering cards
  getLandscapesByChallenge(type: ChallengeType): LandscapeCard[];
  getResourcesByType(type: string): ResourceCard[];
  // ...other filters

  // Card collection management
  getAllLandscapeCards(): LandscapeCard[];
  // ...other collection getters
}
```

#### Card Components
Create base components for cards:

```vue
<!-- src/components/game/BaseCard.vue (structure) -->
<script setup lang="ts">
import { computed } from 'vue';
import type { BaseCard } from '@/models/types/cards';

const props = defineProps<{
  card: BaseCard;
  selected?: boolean;
  disabled?: boolean;
}>();

const emit = defineEmits<{
  (e: 'click', card: BaseCard): void;
}>();

const cardClasses = computed(() => ({
  'card': true,
  [`card--${props.card.type.toLowerCase()}`]: true,
  'card--selected': props.selected,
  'card--disabled': props.disabled
}));
</script>

<template>
  <div :class="cardClasses" @click="emit('click', card)">
    <div class="card__header">
      <h3 class="card__title">{{ card.name }}</h3>
    </div>
    <div class="card__content">
      <slot></slot>
    </div>
    <div class="card__footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>
```

### Deliverables
- Complete type definitions for all game entities
- Card repository with access methods and filtering
- Base card component with type-specific variations
- Static card data for initial game setup
- Card styling with text-first approach (placeholder for future images)

---

## Step 3: Game State Management

### Technical Requirements
- Implement core Pinia stores with proper TypeScript types
- Create state transitions system with validation
- Build game initialization flow
- Develop save/load mechanism for game state

### Implementation Details

#### Pinia Store Implementation
Implement the core game stores:

**Game Store**
Responsible for game flow, phases, and overall state:

```typescript
// src/stores/gameStore.ts (structure)
export const useGameStore = defineStore('game', {
  state: (): GameState => ({
    phase: GamePhase.SETUP,
    turn: 0,
    season: Season.SAMHAIN,
    threatTokens: 0,
    blessingTokens: 1,
    currentLandscapeId: null,
    visitedLandscapes: [],
    seasonalWheel: {
      position: 0,
      quests: [
        { id: 'samhain', completed: false },
        { id: 'winter', completed: false },
        { id: 'imbolc', completed: false },
        { id: 'beltane', completed: false },
        { id: 'lughnasadh', completed: false }
      ]
    },
    victoryConditions: {
      journeyCompleted: false,
      balanceMaintained: false,
      knowledgeAcquired: false,
      bondsFormed: false,
      questFulfilled: false
    }
  }),
  
  getters: {
    // Calculate derived state
    threatLevel: (state) => Math.floor(state.threatTokens / 3),
    seasonalEffects: (state) => SEASONAL_EFFECTS[state.season],
    isVictory: (state) => Object.values(state.victoryConditions).every(Boolean),
  },
  
  actions: {
    // Phase transitions
    transitionToPhase(newPhase: GamePhase): boolean,
    
    // Game initialization
    startGame(characterId: string): void,
    
    // Turn progression
    advanceTurn(): void,
    
    // Season management
    checkSeasonTransition(): void,
    
    // Victory conditions
    checkVictoryConditions(): void,
    
    // State persistence
    saveGame(): GameSaveData,
    loadGame(saveData: GameSaveData): void
  }
});
```

**Player Store**
Manages character state, resources, health, etc.:

```typescript
// src/stores/playerStore.ts (structure)
export const usePlayerStore = defineStore('player', {
  state: (): PlayerState => ({
    characterId: null,
    health: 0,
    maxHealth: 0,
    resourceCapacity: 0,
    resources: [],
    animalCompanions: [],
    craftedItems: [],
    experience: 0,
    abilities: []
  }),
  
  getters: {
    character: (state) => state.characterId ? getCharacterById(state.characterId) : null,
    resourceCount: (state) => state.resources.length,
    isOverCapacity: (state) => state.resources.length > state.resourceCapacity,
    companionCount: (state) => state.animalCompanions.length,
  },
  
  actions: {
    initializeCharacter(characterId: string): void,
    modifyHealth(amount: number): void,
    addResource(resourceId: string): boolean,
    removeResource(resourceId: string): boolean,
    addCompanion(companionId: string): void,
    makeCompanionWary(companionId: string): void,
    addCraftedItem(itemId: string): void,
    useCraftedItem(itemId: string): void,
    gainExperience(amount: number): void
  }
});
```

**Card Store**
Manages the card decks, active cards, and discard piles:

```typescript
// src/stores/cardStore.ts (structure)
export const useCardStore = defineStore('cards', {
  state: (): CardState => ({
    decks: {
      landscape: [],
      animalCompanion: [],
      resource: [],
      craftedItem: [],
      season: []
    },
    active: {
      landscape: [],
      animalCompanion: [],
      resource: [],
      craftedItem: [],
      season: []
    },
    discard: {
      landscape: [],
      animalCompanion: [],
      resource: [],
      craftedItem: [],
      season: []
    }
  }),
  
  getters: {
    activeLandscape: (state) => {
      const gameStore = useGameStore();
      return state.active.landscape.find(
        card => card.id === gameStore.currentLandscapeId
      );
    },
    // Other getters for active cards and collections
  },
  
  actions: {
    initializeDecks(): void,
    shuffleDeck(deckType: keyof typeof CardType): void,
    drawCard(deckType: keyof typeof CardType): BaseCard | null,
    discardCard(card: BaseCard): void,
    activateCard(card: BaseCard): void,
    revealLandscape(id: string): LandscapeCard | null
  }
});
```

#### State Persistence
Implement save and load functionality:

```typescript
// src/services/saveManager.ts (structure)
class SaveManager {
  // Save game state to localStorage
  saveGame(): string {
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    
    const saveData = {
      version: '1.0.0',
      timestamp: Date.now(),
      game: gameStore.$state,
      player: playerStore.$state,
      cards: cardStore.$state
    };
    
    const saveString = JSON.stringify(saveData);
    localStorage.setItem('pathfindersJourney_save', saveString);
    return saveString;
  }
  
  // Load game state from localStorage
  loadGame(): boolean {
    const saveString = localStorage.getItem('pathfindersJourney_save');
    if (!saveString) return false;
    
    try {
      const saveData = JSON.parse(saveString);
      
      // Version check and migration if needed
      if (saveData.version !== '1.0.0') {
        this.migrateSaveData(saveData);
      }
      
      const gameStore = useGameStore();
      const playerStore = usePlayerStore();
      const cardStore = useCardStore();
      
      // Reset stores to saved state
      gameStore.$state = saveData.game;
      playerStore.$state = saveData.player;
      cardStore.$state = saveData.cards;
      
      return true;
    } catch (error) {
      console.error('Failed to load save:', error);
      return false;
    }
  }
  
  // Handle save data migration between versions
  private migrateSaveData(saveData: any): void {
    // Implementation for future versions
  }
}
```

### Deliverables
- Fully implemented Pinia stores with TypeScript support
- Game state transition system with validation
- Player state management with character attributes
- Card state management with deck operations
- Save/load functionality with localStorage persistence
- Unit tests for core store functionality

---

## Step 4: Game Board & UI Components

### Technical Requirements
- Create responsive game board layout
- Build UI components for game elements
- Implement seasonal wheel visualization
- Develop player dashboard with status indicators
- Create card display areas with proper layout

### Implementation Details

#### Game Board Layout
Design the main game board using CSS Grid for responsive layout:

```vue
<!-- src/views/GameBoardView.vue (structure) -->
<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import SeasonalWheel from '@/components/game/SeasonalWheel.vue';
import JourneyPath from '@/components/game/JourneyPath.vue';
import PlayerDashboard from '@/components/game/PlayerDashboard.vue';
import ActionPanel from '@/components/game/ActionPanel.vue';
import StatusArea from '@/components/game/StatusArea.vue';

const gameStore = useGameStore();
const playerStore = usePlayerStore();

// Reactive properties based on stores
const currentPhase = computed(() => gameStore.phase);
const currentSeason = computed(() => gameStore.season);
const threatLevel = computed(() => gameStore.threatLevel);
</script>

<template>
  <div class="game-board">
    <div class="game-board__top">
      <SeasonalWheel 
        :season="currentSeason" 
        :quests="gameStore.seasonalWheel.quests"
      />
      <StatusArea 
        :threat-tokens="gameStore.threatTokens"
        :blessing-tokens="gameStore.blessingTokens"
        :turn="gameStore.turn"
      />
    </div>
    
    <div class="game-board__center">
      <JourneyPath 
        :current-landscape-id="gameStore.currentLandscapeId"
        :visited-landscapes="gameStore.visitedLandscapes"
      />
    </div>
    
    <div class="game-board__bottom">
      <PlayerDashboard 
        :character="playerStore.character"
        :health="playerStore.health"
        :max-health="playerStore.maxHealth"
        :resources="playerStore.resources"
        :resource-capacity="playerStore.resourceCapacity"
        :companions="playerStore.animalCompanions"
        :crafted-items="playerStore.craftedItems"
      />
      <ActionPanel :phase="currentPhase" />
    </div>
  </div>
</template>

<style lang="scss">
.game-board {
  display: grid;
  grid-template-rows: auto 1fr auto;
  height: 100vh;
  overflow: hidden;
  
  &__top {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 1rem;
    padding: 1rem;
  }
  
  &__center {
    overflow-y: auto;
    padding: 1rem;
  }
  
  &__bottom {
    display: grid;
    grid-template-columns: 3fr 1fr;
    gap: 1rem;
    padding: 1rem;
  }
}

@media (max-width: 768px) {
  .game-board {
    &__top,
    &__bottom {
      grid-template-columns: 1fr;
    }
  }
}
</style>
```

#### Seasonal Wheel Component
Create an interactive visualization of the seasonal cycle:

```vue
<!-- src/components/game/SeasonalWheel.vue (structure) -->
<script setup lang="ts">
import { computed } from 'vue';
import { Season } from '@/models/enums/seasons';

const props = defineProps<{
  season: Season;
  quests: { id: string; completed: boolean }[];
}>();

const seasonIndex = computed(() => {
  const seasonMap = {
    [Season.SAMHAIN]: 0,
    [Season.WINTERS_DEPTH]: 1,
    [Season.IMBOLC]: 2,
    [Season.BELTANE]: 3,
    [Season.LUGHNASADH]: 4
  };
  return seasonMap[props.season] || 0;
});

const rotationDegrees = computed(() => seasonIndex.value * 72);
</script>

<template>
  <div class="seasonal-wheel">
    <div class="seasonal-wheel__container">
      <div 
        class="seasonal-wheel__dial" 
        :style="`transform: rotate(${rotationDegrees}deg)`"
      >
        <!-- Season sections - 5 sections (72 each) -->
        <div class="seasonal-wheel__section" data-season="samhain">
          <div class="seasonal-wheel__label">Samhain</div>
          <div class="seasonal-wheel__quest" :class="{ 'completed': quests[0].completed }">
            <span>Quest</span>
          </div>
        </div>
        <!-- Repeat for other seasons -->
      </div>
      
      <div class="seasonal-wheel__pointer"></div>
    </div>
    
    <div class="seasonal-wheel__info">
      <h3>{{ season }}</h3>
      <div class="seasonal-wheel__effects">
        <!-- Season effects displayed here -->
      </div>
    </div>
  </div>
</template>

<style lang="scss">
.seasonal-wheel {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 1rem;
  
  &__container {
    position: relative;
    width: 200px;
    height: 200px;
  }
  
  &__dial {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    border: 2px solid var(--color-border);
    transition: transform 0.5s ease-in-out;
  }
  
  &__section {
    position: absolute;
    width: 50%;
    height: 50%;
    transform-origin: bottom left;
    
    &[data-season="samhain"] {
      transform: rotate(0deg);
    }
    
    // Position other sections with appropriate rotation
  }
  
  &__pointer {
    position: absolute;
    top: 0;
    left: 50%;
    width: 2px;
    height: 20px;
    background-color: var(--color-accent);
    transform: translateX(-50%);
  }
}
</style>
```

#### Player Dashboard
Create a comprehensive player status display:

```vue
<!-- src/components/game/PlayerDashboard.vue (structure) -->
<script setup lang="ts">
import { computed } from 'vue';
import type { Character } from '@/models/types/character';
import type { Resource } from '@/models/types/cards';
import ResourceBadge from '@/components/game/ResourceBadge.vue';
import HealthMeter from '@/components/ui/HealthMeter.vue';
import CompanionsList from '@/components/game/CompanionsList.vue';
import CraftedItemsList from '@/components/game/CraftedItemsList.vue';

// Props with TypeScript types
const props = defineProps<{
  character: Character | null;
  health: number;
  maxHealth: number;
  resources: Resource[];
  resourceCapacity: number;
  companions: string[];
  craftedItems: string[];
}>();

// Computed properties
const isOverCapacity = computed(() => 
  props.resources.length > props.resourceCapacity
);

const healthPercentage = computed(() => 
  (props.health / props.maxHealth) * 100
);

const healthStatus = computed(() => {
  if (healthPercentage.value > 75) return 'good';
  if (healthPercentage.value > 30) return 'warning';
  return 'danger';
});

const characterName = computed(() => 
  props.character?.name || 'No Character Selected'
);
</script>

<template>
  <div class="player-dashboard">
    <div class="player-dashboard__header">
      <h2>{{ characterName }}</h2>
      <HealthMeter 
        :value="health" 
        :max="maxHealth"
        :status="healthStatus"
      />
    </div>
    
    <div class="player-dashboard__resources">
      <h3>Resources ({{ resources.length }}/{{ resourceCapacity }})</h3>
      <div 
        class="resource-list"
        :class="{ 'resource-list--over-capacity': isOverCapacity }"
      >
        <ResourceBadge 
          v-for="resource in resources" 
          :key="resource.id"
          :resource="resource"
        />
      </div>
    </div>
    
    <div class="player-dashboard__companions">
      <h3>Animal Companions</h3>
      <CompanionsList :companions="companions" />
    </div>
    
    <div class="player-dashboard__items">
      <h3>Crafted Items</h3>
      <CraftedItemsList :items="craftedItems" />
    </div>
  </div>
</template>
```

### Deliverables
- Complete game board layout with responsive design
- Seasonal wheel visualization with rotation animation
- Player dashboard with health, resources, and companions
- Journey path visualization with current location indicator
- Action panel for phase-specific controls
- Status area for game state indicators
- Comprehensive SCSS styling system

---

## Step 5: Challenge System Implementation

### Technical Requirements
- Build dice rolling mechanism with proper randomization
- Implement challenge difficulty calculator
- Create challenge resolution pipeline
- Develop success/failure outcome handler
- Build challenge history tracker

### Implementation Details

#### Dice Rolling Service
Create a service for handling dice rolls with proper randomization:

```typescript
// src/services/diceService.ts
class DiceService {
  // Roll a specific die (d4, d6, d8, etc.)
  rollDie(sides: number): number {
    return Math.floor(Math.random() * sides) + 1;
  }
  
  // Roll the game's eight-sided die
  rollD8(): number {
    return this.rollDie(8);
  }
  
  // Roll with advantage (roll twice, take higher)
  rollWithAdvantage(sides: number): { rolls: number[], result: number } {
    const roll1 = this.rollDie(sides);
    const roll2 = this.rollDie(sides);
    return {
      rolls: [roll1, roll2],
      result: Math.max(roll1, roll2)
    };
  }
  
  // Roll with disadvantage (roll twice, take lower)
  rollWithDisadvantage(sides: number): { rolls: number[], result: number } {
    const roll1 = this.rollDie(sides);
    const roll2 = this.rollDie(sides);
    return {
      rolls: [roll1, roll2],
      result: Math.min(roll1, roll2)
    };
  }
  
  // For debug/test purposes, can force a specific roll result
  private _debugMode = false;
  private _forcedValue: number | null = null;
  
  setForcedRoll(value: number | null): void {
    this._debugMode = value !== null;
    this._forcedValue = value;
  }
}

export const diceService = new DiceService();
```

#### Challenge Resolution System
Build a comprehensive challenge resolution system:

```typescript
// src/services/challengeService.ts
class ChallengeService {
  // Calculate challenge difficulty based on multiple factors
  calculateDifficulty(challenge: Challenge): number {
    const gameStore = useGameStore();
    const baseDifficulty = challenge.difficulty;
    
    // Apply seasonal modifiers
    const seasonModifier = this.getSeasonalModifier(challenge.type, gameStore.season);
    
    // Apply threat level modifier
    const threatModifier = Math.floor(gameStore.threatTokens / 3);
    
    return baseDifficulty + seasonModifier + threatModifier;
  }
  
  // Calculate player's bonus for challenge
  calculatePlayerBonus(challenge: Challenge): number {
    const playerStore = usePlayerStore();
    
    // Character ability bonus
    let bonus = this.getCharacterBonus(playerStore.character, challenge.type);
    
    // Item bonuses
    bonus += this.getItemBonuses(playerStore.craftedItems, challenge.type);
    
    // Companion bonuses
    bonus += this.getCompanionBonuses(playerStore.animalCompanions, challenge.type);
    
    // Blessing tokens
    const gameStore = useGameStore();
    bonus += gameStore.blessingTokens;
    
    return bonus;
  }
  
  // Determine challenge outcome
  resolveChallenge(challenge: Challenge): ChallengeOutcome {
    const difficulty = this.calculateDifficulty(challenge);
    const playerBonus = this.calculatePlayerBonus(challenge);
    
    const diceRoll = diceService.rollD8();
    const total = diceRoll + playerBonus;
    
    // Record the challenge attempt
    this.recordChallengeAttempt({
      challengeType: challenge.type,
      difficulty,
      diceRoll,
      playerBonus,
      total
    });
    
    // Natural 8 always succeeds
    if (diceRoll === 8) {
      return {
        success: true,
        exceptional: true,
        roll: diceRoll,
        total,
        difficulty
      };
    }
    
    // Success: total >= difficulty
    if (total >= difficulty) {
      return {
        success: true,
        exceptional: total >= difficulty + 2,
        roll: diceRoll,
        total,
        difficulty
      };
    }
    
    // Partial success: total = difficulty - 1
    if (total === difficulty - 1) {
      return {
        success: 'partial',
        exceptional: false,
        roll: diceRoll,
        total,
        difficulty
      };
    }
    
    // Failure
    return {
      success: false,
      exceptional: total <= difficulty - 3,
      roll: diceRoll,
      total,
      difficulty
    };
  }
  
  // Apply challenge outcomes
  applyOutcome(outcome: ChallengeOutcome, challenge: Challenge): void {
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    
    if (outcome.success === true) {
      // Full success
      if (outcome.exceptional) {
        // Exceptional success (e.g., gain blessing token)
        gameStore.blessingTokens++;
      }
      
      // Collect resources
      this.collectResources(2);
      
      // Advance to next landscape
      gameStore.moveToNextLandscape();
    } 
    else if (outcome.success === 'partial') {
      // Partial success
      this.collectResources(1);
      gameStore.moveToNextLandscape();
    } 
    else {
      // Failure
      this.applyFailureConsequences(challenge);
    }
  }
  
  // Apply consequences of challenge failure
  private applyFailureConsequences(challenge: Challenge): void {
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    
    switch (challenge.type) {
      case ChallengeType.PHYSICAL:
        // Lose health (1-3 points)
        const healthLoss = Math.floor(Math.random() * 3) + 1;
        playerStore.modifyHealth(-healthLoss);
        break;
        
      case ChallengeType.MENTAL:
        // Add threat tokens (1-2)
        const threatGain = Math.floor(Math.random() * 2) + 1;
        gameStore.addThreatTokens(threatGain);
        break;
        
      case ChallengeType.SOCIAL:
        // Lose access to a resource type temporarily
        this.blockResourceType();
        break;
        
      case ChallengeType.SPIRITUAL:
        // Animal companions become wary
        playerStore.makeAllCompanionsWary();
        break;
    }
  }
  
  // Challenge history tracking
  private challengeHistory: ChallengeAttempt[] = [];
  
  recordChallengeAttempt(attempt: ChallengeAttempt): void {
    this.challengeHistory.push({
      ...attempt,
      timestamp: Date.now()
    });
    
    // Keep history at a reasonable size
    if (this.challengeHistory.length > 20) {
      this.challengeHistory.shift();
    }
  }
  
  getChallengeHistory(): ChallengeAttempt[] {
    return [...this.challengeHistory];
  }
  
  // Helper methods
  private getSeasonalModifier(challengeType: ChallengeType, season: Season): number;
  private getCharacterBonus(character: Character, challengeType: ChallengeType): number;
  private getItemBonuses(items: string[], challengeType: ChallengeType): number;
  private getCompanionBonuses(companions: string[], challengeType: ChallengeType): number;
  private collectResources(count: number): void;
  private blockResourceType(): void;
}

export const challengeService = new ChallengeService();
```

#### Challenge Resolution Component
Create a UI for challenge resolution:

```vue
<!-- src/components/game/ChallengeResolution.vue (structure) -->
<script setup lang="ts">
import { ref, computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { useCardStore } from '@/stores/cardStore';
import { challengeService } from '@/services/challengeService';
import { diceService } from '@/services/diceService';
import DiceRoller from '@/components/game/DiceRoller.vue';
import ChallengeDetails from '@/components/game/ChallengeDetails.vue';
import OutcomeDisplay from '@/components/game/OutcomeDisplay.vue';

const gameStore = useGameStore();
const cardStore = useCardStore();

const challenge = computed(() => {
  const activeLandscape = cardStore.activeLandscape;
  return activeLandscape?.challenge;
});

const difficulty = computed(() => {
  if (!challenge.value) return 0;
  return challengeService.calculateDifficulty(challenge.value);
});

const playerBonus = computed(() => {
  if (!challenge.value) return 0;
  return challengeService.calculatePlayerBonus(challenge.value);
});

const isRolling = ref(false);
const outcomeResult = ref(null);

const startRoll = () => {
  if (!challenge.value) return;
  
  isRolling.value = true;
  
  // Simulate dice roll animation
  setTimeout(() => {
    const outcome = challengeService.resolveChallenge(challenge.value);
    outcomeResult.value = outcome;
    isRolling.value = false;
  }, 1500);
};

const applyOutcome = () => {
  if (!outcomeResult.value || !challenge.value) return;
  
  challengeService.applyOutcome(outcomeResult.value, challenge.value);
  gameStore.transitionToPhase(GamePhase.RESOURCE_MANAGEMENT);
};
</script>

<template>
  <div class="challenge-resolution">
    <ChallengeDetails 
      v-if="challenge"
      :challenge="challenge"
      :difficulty="difficulty"
      :player-bonus="playerBonus"
    />
    
    <div class="challenge-resolution__dice">
      <DiceRoller 
        :sides="8"
        :rolling="isRolling"
        :result="outcomeResult?.roll"
      />
    </div>
    
    <div class="challenge-resolution__controls">
      <button 
        class="button button--primary"
        :disabled="isRolling || outcomeResult"
        @click="startRoll"
      >
        Roll for Challenge
      </button>
    </div>
    
    <OutcomeDisplay 
      v-if="outcomeResult"
      :outcome="outcomeResult"
      :challenge="challenge"
    />
    
    <div class="challenge-resolution__next">
      <button 
        v-if="outcomeResult"
        class="button button--primary"
        @click="applyOutcome"
      >
        Continue
      </button>
    </div>
  </div>
</template>
```

### Deliverables
- Dice rolling service with proper randomization
- Challenge difficulty calculator with all modifiers
- Challenge resolution system with outcome determination
- Success/failure consequence handler
- Challenge history tracking system
- Challenge resolution UI with dice animation
- Unit tests for challenge resolution edge cases

---

## Step 6: Journey & Seasonal Systems

### Technical Requirements
- Implement journey path navigation with card revelation
- Build seasonal transition system with effects
- Create location-specific interaction system
- Develop seasonal quest tracking
- Implement journey progress visualization

### Implementation Details

#### Journey System
Create a service for managing the journey path:

```typescript
// src/services/journeyService.ts
class JourneyService {
  // Initialize journey path with 15 landscapes
  initializeJourney(): string[] {
    const cardRepository = new CardRepository();
    const allLandscapes = cardRepository.getAllLandscapeCards();
    
    // Shuffle landscapes
    const shuffled = [...allLandscapes].sort(() => 0.5 - Math.random());
    
    // Select 15 landscapes for the journey
    const journeyLandscapes = shuffled.slice(0, 15);
    
    // Return landscape IDs in journey order
    return journeyLandscapes.map(landscape => landscape.id);
  }
  
  // Get current location index in journey
  getCurrentLocationIndex(currentLandscapeId: string, journeyPath: string[]): number {
    return journeyPath.findIndex(id => id === currentLandscapeId);
  }
  
  // Get next location in journey
  getNextLocation(currentLandscapeId: string, journeyPath: string[]): string | null {
    const currentIndex = this.getCurrentLocationIndex(currentLandscapeId, journeyPath);
    
    if (currentIndex === -1 || currentIndex >= journeyPath.length - 1) {
      return null;
    }
    
    return journeyPath[currentIndex + 1];
  }
  
  // Move to next location
  moveToNextLocation(gameStore, cardStore): boolean {
    const nextLandscapeId = this.getNextLocation(
      gameStore.currentLandscapeId, 
      gameStore.journeyPath
    );
    
    if (!nextLandscapeId) {
      return false;
    }
    
    // Reveal landscape if needed
    cardStore.revealLandscape(nextLandscapeId);
    
    // Update current location
    gameStore.currentLandscapeId = nextLandscapeId;
    
    // Add to visited locations
    if (!gameStore.visitedLandscapes.includes(nextLandscapeId)) {
      gameStore.visitedLandscapes.push(nextLandscapeId);
    }
    
    // Check for seasonal boundary
    this.checkSeasonalBoundary(gameStore);
    
    return true;
  }
  
  // Check if current location is at a seasonal boundary
  checkSeasonalBoundary(gameStore): boolean {
    const locationIndex = this.getCurrentLocationIndex(
      gameStore.currentLandscapeId,
      gameStore.journeyPath
    );
    
    // Seasonal boundaries at indices 3, 6, 9, 12
    const newSeasonIndex = Math.floor(locationIndex / 3);
    
    if (newSeasonIndex !== gameStore.seasonalWheel.position) {
      gameStore.seasonalWheel.position = newSeasonIndex;
      this.updateSeason(gameStore);
      return true;
    }
    
    return false;
  }
  
  // Update current season based on wheel position
  updateSeason(gameStore): void {
    const seasonMap = [
      Season.SAMHAIN,
      Season.WINTERS_DEPTH,
      Season.IMBOLC,
      Season.BELTANE,
      Season.LUGHNASADH
    ];
    
    const newSeason = seasonMap[gameStore.seasonalWheel.position];
    
    if (newSeason && newSeason !== gameStore.season) {
      gameStore.season = newSeason;
      this.applySeasonalEffects(gameStore);
    }
  }
  
  // Apply effects when season changes
  applySeasonalEffects(gameStore, playerStore): void {
    // Clear previous seasonal effects
    this.clearSeasonalEffects();
    
    // Apply new seasonal effects
    switch (gameStore.season) {
      case Season.SAMHAIN:
        // Veil between worlds is thin, spiritual challenges harder
        // Ancestral guidance available
        break;
        
      case Season.WINTERS_DEPTH:
        // Harsh conditions make physical challenges harder
        // Clearer thinking in stillness
        break;
        
      case Season.IMBOLC:
        // Renewal energy makes healing more effective
        // New growth provides hope
        break;
        
      case Season.BELTANE:
        // Vibrant energy enhances crafting
        // Life force is strong
        playerStore.maxHealth++;
        break;
        
      case Season.LUGHNASADH:
        // Gathering time - collect more resources
        // Community support - better healing
        break;
    }
  }
  
  // Track seasonal quests
  activateSeasonalQuest(season: Season): SeasonalQuest {
    // Return the quest details for the specified season
  }
  
  completeSeasonalQuest(season: Season, gameStore): void {
    const questIndex = this.getSeasonalQuestIndex(season);
    if (questIndex >= 0) {
      gameStore.seasonalWheel.quests[questIndex].completed = true;
      this.applyQuestReward(season, gameStore);
    }
  }
  
  // Helper methods
  private clearSeasonalEffects(): void;
  private getSeasonalQuestIndex(season: Season): number;
  private applyQuestReward(season: Season, gameStore): void;
}

export const journeyService = new JourneyService();
```

#### Journey Path Component
Create a visual representation of the journey:

```vue
<!-- src/components/game/JourneyPath.vue (structure) -->
<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { useCardStore } from '@/stores/cardStore';
import LandscapeCard from '@/components/game/LandscapeCard.vue';

const props = defineProps<{
  currentLandscapeId: string | null;
  visitedLandscapes: string[];
}>();

const gameStore = useGameStore();
const cardStore = useCardStore();

const journeyPath = computed(() => gameStore.journeyPath);

const visibleLandscapes = computed(() => {
  return journeyPath.value.map(id => {
    const isVisited = props.visitedLandscapes.includes(id);
    const isCurrent = id === props.currentLandscapeId;
    
    // Only show details for visited or current locations
    const landscape = isVisited || isCurrent
      ? cardStore.getLandscapeById(id)
      : null;
    
    return {
      id,
      landscape,
      isVisited,
      isCurrent,
      isRevealed: !!landscape
    };
  });
});

const currentIndex = computed(() => {
  if (!props.currentLandscapeId) return -1;
  return journeyPath.value.findIndex(id => id === props.currentLandscapeId);
});

const journeyProgress = computed(() => {
  if (currentIndex.value < 0) return 0;
  return (currentIndex.value / (journeyPath.value.length - 1)) * 100;
});
</script>

<template>
  <div class="journey-path">
    <div class="journey-path__progress">
      <div 
        class="journey-path__progress-bar"
        :style="`width: ${journeyProgress}%`"
      ></div>
    </div>
    
    <div class="journey-path__locations">
      <div 
        v-for="(location, index) in visibleLandscapes"
        :key="location.id"
        class="journey-path__location"
        :class="{
          'journey-path__location--visited': location.isVisited,
          'journey-path__location--current': location.isCurrent,
          'journey-path__location--hidden': !location.isRevealed
        }"
      >
        <div class="journey-path__node"></div>
        
        <div v-if="location.isRevealed" class="journey-path__card">
          <LandscapeCard 
            v-if="location.landscape"
            :card="location.landscape"
            :is-current="location.isCurrent"
          />
          <div v-else class="journey-path__placeholder">
            Unknown Location
          </div>
        </div>
        
        <div v-else class="journey-path__placeholder">
          ?
        </div>
      </div>
    </div>
  </div>
</template>

<style lang="scss">
.journey-path {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  
  &__progress {
    height: 8px;
    background-color: var(--color-background-alt);
    border-radius: 4px;
    overflow: hidden;
  }
  
  &__progress-bar {
    height: 100%;
    background-color: var(--color-primary);
    transition: width 0.5s ease-in-out;
  }
  
  &__locations {
    display: flex;
    flex-wrap: nowrap;
    gap: 1rem;
    overflow-x: auto;
    padding: 1rem 0;
  }
  
  &__location {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    
    &--visited .journey-path__node {
      background-color: var(--color-success);
    }
    
    &--current .journey-path__node {
      background-color: var(--color-primary);
      transform: scale(1.5);
    }
    
    &--hidden .journey-path__placeholder {
      background-color: var(--color-background-alt);
      color: var(--color-text-muted);
    }
  }
  
  &__node {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background-color: var(--color-border);
    transition: transform 0.3s ease, background-color 0.3s ease;
  }
  
  &__card {
    width: 200px;
  }
  
  &__placeholder {
    width: 200px;
    height: 120px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--color-background);
    border: 1px dashed var(--color-border);
    border-radius: 8px;
  }
}
</style>
```

### Deliverables
- Journey path initialization system
- Seasonal transition mechanism with effects
- Location-specific interaction system
- Journey path visualization with progress tracking
- Seasonal wheel component with rotation animation
- Seasonal quest tracking and rewards
- Journey navigation system with movement controls

---

## Step 7: Resource & Companion Management

### Technical Requirements
- Implement resource collection and management
- Build resource capacity system with limits
- Create animal companion bonding mechanics
- Develop companion loyalty and feeding system
- Implement resource type preferences for companions

### Implementation Details

#### Resource Management Service
Create a service for handling resources:

```typescript
// src/services/resourceService.ts
class ResourceService {
  // Check if player can collect a resource
  canCollectResource(resourceId: string, playerStore): boolean {
    // Check capacity limits
    if (playerStore.resources.length >= playerStore.resourceCapacity) {
      return false;
    }
    
    return true;
  }
  
  // Collect a specific resource
  collectResource(resourceId: string, playerStore, cardStore): boolean {
    if (!this.canCollectResource(resourceId, playerStore)) {
      return false;
    }
    
    // Get resource card
    const resource = cardStore.getResourceById(resourceId);
    if (!resource) {
      return false;
    }
    
    // Add to player resources
    playerStore.addResource(resourceId);
    return true;
  }
  
  // Collect random resources from current landscape
  collectLandscapeResources(count: number, gameStore, playerStore, cardStore): string[] {
    const landscape = cardStore.getLandscapeById(gameStore.currentLandscapeId);
    if (!landscape) {
      return [];
    }
    
    // Get available resources at this landscape
    const availableResources = landscape.availableResources;
    
    // Apply seasonal abundance/scarcity
    const seasonallyAdjusted = this.applySeasonalResourceEffects(
      availableResources,
      gameStore.season
    );
    
    // Randomly select resources up to count
    const shuffled = [...seasonallyAdjusted].sort(() => 0.5 - Math.random());
    const selectedResources = shuffled.slice(0, count);
    
    // Add to player inventory
    const collected = [];
    for (const resourceId of selectedResources) {
      if (this.collectResource(resourceId, playerStore, cardStore)) {
        collected.push(resourceId);
      }
    }
    
    return collected;
  }
  
  // Use a resource
  useResource(resourceId: string, playerStore): boolean {
    return playerStore.removeResource(resourceId);
  }
  
  // Get resources by type
  getResourcesByType(type: string, playerStore, cardStore): string[] {
    return playerStore.resources.filter(resourceId => {
      const resource = cardStore.getResourceById(resourceId);
      return resource && resource.type === type;
    });
  }
  
  // Apply seasonal abundance/scarcity effects
  applySeasonalResourceEffects(resourceIds: string[], season: Season): string[] {
    // Define seasonal abundance/scarcity
    const seasonalEffects = {
      [Season.SAMHAIN]: {
        abundant: ['barrow_dust', 'standing_stone_chips'],
        scarce: ['woven_reeds', 'rowan_wood']
      },
      [Season.WINTERS_DEPTH]: {
        abundant: ['forge_cinders', 'bog_iron'],
        scarce: ['sacred_water', 'horse_hair']
      },
      [Season.IMBOLC]: {
        abundant: ['silver_mistletoe', 'sacred_water'],
        scarce: ['barrow_dust', 'forge_cinders']
      },
      [Season.BELTANE]: {
        abundant: ['rowan_wood', 'oak_galls'],
        scarce: ['standing_stone_chips', 'amber_shards']
      },
      [Season.LUGHNASADH]: {
        abundant: ['horse_hair', 'woven_reeds', 'ogham_sticks'],
        scarce: ['bog_iron', 'silver_mistletoe']
      }
    };
    
    // If no seasonal effects for current season, return original
    if (!seasonalEffects[season]) {
      return resourceIds;
    }
    
    // Make abundant resources more likely, scarce less likely
    let adjusted = [...resourceIds];
    
    // Double abundant resources (increase probability)
    for (const resourceId of resourceIds) {
      if (seasonalEffects[season].abundant.includes(resourceId)) {
        adjusted.push(resourceId);
      }
    }
    
    // Remove scarce resources (decrease probability)
    adjusted = adjusted.filter(resourceId => 
      !seasonalEffects[season].scarce.includes(resourceId)
    );
    
    return adjusted;
  }
}

export const resourceService = new ResourceService();
```

#### Companion Management Service
Create a service for animal companions:

```typescript
// src/services/companionService.ts
class CompanionService {
  // Bond with a new companion
  bondWithCompanion(companionId: string, resourceId: string, playerStore, cardStore): boolean {
    // Check if player already has this companion
    if (playerStore.animalCompanions.includes(companionId)) {
      return false;
    }
    
    // Get companion card
    const companion = cardStore.getCompanionById(companionId);
    if (!companion) {
      return false;
    }
    
    // Check if resource is appropriate for bonding
    if (!this.isResourceSuitableForBonding(resourceId, companionId)) {
      return false;
    }
    
    // Use the resource
    const resourceUsed = resourceService.useResource(resourceId, playerStore);
    if (!resourceUsed) {
      return false;
    }
    
    // Add companion to player's collection
    playerStore.addCompanion(companionId);
    return true;
  }
  
  // Feed a companion
  feedCompanion(companionId: string, resourceId: string, playerStore, cardStore): boolean {
    // Check if player has this companion
    if (!playerStore.animalCompanions.includes(companionId)) {
      return false;
    }
    
    // Use the resource
    const resourceUsed = resourceService.useResource(resourceId, playerStore);
    if (!resourceUsed) {
      return false;
    }
    
    // Restore companion loyalty
    playerStore.restoreCompanionLoyalty(companionId);
    
    // Return success
    return true;
  }
  
  // Use companion ability
  useCompanionAbility(companionId: string, playerStore, gameStore): {
    success: boolean;
    effect: string;
  } {
    // Check if player has this companion
    if (!playerStore.animalCompanions.includes(companionId)) {
      return { success: false, effect: 'Companion not found' };
    }
    
    // Check if companion is wary
    if (playerStore.isCompanionWary(companionId)) {
      return { success: false, effect: 'Companion is wary' };
    }
    
    // Make companion wary unless fed this turn
    if (!playerStore.isCompanionFed(companionId)) {
      playerStore.makeCompanionWary(companionId);
    }
    
    // Apply companion ability
    const companion = cardStore.getCompanionById(companionId);
    if (!companion) {
      return { success: false, effect: 'Companion not found in cards' };
    }
    
    // Apply seasonal bonus if applicable
    const effectBonus = this.getSeasonalCompanionBonus(companionId, gameStore.season);
    
    // Execute ability based on companion type
    switch (companionId) {
      case 'raven_scout':
        // Reveal next Landscape card
        const nextLandscapeId = journeyService.getNextLocation(
          gameStore.currentLandscapeId,
          gameStore.journeyPath
        );
        
        if (nextLandscapeId) {
          cardStore.revealLandscape(nextLandscapeId);
          return { 
            success: true, 
            effect: `Revealed next location: ${cardStore.getLandscapeById(nextLandscapeId)?.name}`
          };
        }
        return { success: false, effect: 'No next location to reveal' };
        
      case 'wolf_guardian':
        // +2 to combat-related challenges
        return { 
          success: true, 
          effect: `+${2 + effectBonus} to combat challenges` 
        };
      
      // More companion abilities...
    }
    
    return { success: false, effect: 'Unknown companion ability' };
  }
  
  // Check if resource is preferred by companion
  isResourcePreferredByCompanion(resourceId: string, companionId: string): boolean {
    const preferredResources = {
      'wolf_guardian': ['bog_iron'],
      'bear_protector': ['rowan_wood', 'woven_reeds'],
      'deer_guide': ['silver_mistletoe', 'oak_galls'],
      'raven_scout': ['barrow_dust', 'standing_stone_chips'],
      // Other companions...
    };
    
    return preferredResources[companionId]?.includes(resourceId) || false;
  }
  
  // Get seasonal bonus for companion
  getSeasonalCompanionBonus(companionId: string, season: Season): number {
    const seasonalAffinities = {
      [Season.SAMHAIN]: ['wolf_guardian', 'raven_scout', 'owl_sage'],
      [Season.WINTERS_DEPTH]: ['wolf_guardian', 'raven_scout', 'owl_sage'],
      [Season.IMBOLC]: ['hare_pathfinder', 'deer_guide', 'salmon_journeyer'],
      [Season.BELTANE]: ['fox_trickster', 'horse_carrier', 'bear_protector'],
      [Season.LUGHNASADH]: ['boar_digger']
    };
    
    return seasonalAffinities[season]?.includes(companionId) ? 1 : 0;
  }
  
  // Helper methods
  private isResourceSuitableForBonding(resourceId: string, companionId: string): boolean;
}

export const companionService = new CompanionService();
```

#### Resource Management Components
Create UI components for resource management:

```vue
<!-- src/components/game/ResourceManagement.vue (structure) -->
<script setup lang="ts">
import { ref, computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { resourceService } from '@/services/resourceService';
import ResourceCard from '@/components/game/ResourceCard.vue';

const gameStore = useGameStore();
const playerStore = usePlayerStore();
const cardStore = useCardStore();

const collectableResources = ref([]);
const collectedResources = ref([]);

// Compute resources available at current location
const availableResources = computed(() => {
  const landscape = cardStore.getLandscapeById(gameStore.currentLandscapeId);
  if (!landscape) return [];
  
  return landscape.availableResources.map(id => {
    const resource = cardStore.getResourceById(id);
    return {
      id,
      name: resource?.name || 'Unknown Resource',
      description: resource?.description || '',
      seasonal: isSeasonalResource(id)
    };
  });
});

// Check if resource is affected by current season
const isSeasonalResource = (resourceId) => {
  const seasonalEffects = {
    [Season.SAMHAIN]: {
      abundant: ['barrow_dust', 'standing_stone_chips'],
      scarce: ['woven_reeds', 'rowan_wood']
    },
    // Other seasons...
  };
  
  return {
    abundant: seasonalEffects[gameStore.season]?.abundant.includes(resourceId) || false,
    scarce: seasonalEffects[gameStore.season]?.scarce.includes(resourceId) || false
  };
};

// Method to collect resources
const collectResources = () => {
  // Number of resources to collect based on challenge success
  const resourceCount = gameStore.lastChallengeOutcome?.success === true ? 2 : 1;
  
  // Apply Lughnasadh seasonal bonus
  const seasonalBonus = gameStore.season === Season.LUGHNASADH ? 1 : 0;
  
  // Collect resources
  const collected = resourceService.collectLandscapeResources(
    resourceCount + seasonalBonus,
    gameStore,
    playerStore,
    cardStore
  );
  
  collectedResources.value = collected;
  
  // If at capacity, show warning
  if (playerStore.isOverCapacity) {
    // Handle over capacity...
  }
  
  // Move to next phase
  gameStore.transitionToPhase(GamePhase.ANIMAL_COMPANION);
};
</script>

<template>
  <div class="resource-management">
    <h2>Resource Collection</h2>
    
    <div class="resource-management__available">
      <h3>Available Resources</h3>
      <p>You can collect resources from this location.</p>
      
      <div class="resource-grid">
        <div 
          v-for="resource in availableResources"
          :key="resource.id"
          class="resource-item"
          :class="{
            'resource-item--abundant': resource.seasonal.abundant,
            'resource-item--scarce': resource.seasonal.scarce
          }"
        >
          <ResourceCard :resource-id="resource.id" />
          
          <div class="resource-item__seasonal" v-if="resource.seasonal.abundant">
            Abundant
          </div>
          
          <div class="resource-item__seasonal" v-if="resource.seasonal.scarce">
            Scarce
          </div>
        </div>
      </div>
    </div>
    
    <div class="resource-management__inventory">
      <h3>Your Resources ({{ playerStore.resourceCount }}/{{ playerStore.resourceCapacity }})</h3>
      
      <div class="resource-grid">
        <div 
          v-for="resourceId in playerStore.resources"
          :key="resourceId"
          class="resource-item"
        >
          <ResourceCard :resource-id="resourceId" />
        </div>
      </div>
    </div>
    
    <div class="resource-management__actions">
      <button 
        class="button button--primary"
        @click="collectResources"
      >
        Collect Resources
      </button>
    </div>
  </div>
</template>
```

### Deliverables
- Resource collection and management system
- Resource capacity tracking with limits
- Seasonal effects on resource availability
- Animal companion bonding mechanics
- Companion loyalty and feeding system
- Companion ability usage with seasonal effects
- Resource management UI components
- Companion management UI components

---

## Step 8: Crafting System Implementation

### Technical Requirements
- Implement crafting recipe system with requirements
- Build crafting success probability calculator
- Create crafted item usage tracking
- Develop item drawback system
- Implement location bonuses for crafting

### Implementation Details

#### Crafting Service
Create a service for the crafting system:

```typescript
// src/services/craftingService.ts
class CraftingService {
  // Check if player can craft an item
  canCraftItem(itemId: string, playerStore, cardStore, gameStore): {
    canCraft: boolean;
    missingResources: string[];
    locationBonus: number;
  } {
    // Get crafted item
    const item = cardStore.getCraftedItemById(itemId);
    if (!item) {
      return {
        canCraft: false,
        missingResources: [],
        locationBonus: 0
      };
    }
    
    // Check if player has required resources
    const missingResources = [];
    for (const requiredResourceId of item.requiredResources) {
      if (!playerStore.hasResource(requiredResourceId)) {
        missingResources.push(requiredResourceId);
      }
    }
    
    // Calculate location bonus
    const locationBonus = this.getLocationCraftingBonus(
      itemId,
      gameStore.currentLandscapeId,
      cardStore
    );
    
    return {
      canCraft: missingResources.length === 0,
      missingResources,
      locationBonus
    };
  }
  
  // Craft an item
  craftItem(itemId: string, playerStore, cardStore, gameStore): {
    success: boolean;
    item?: CraftedItem;
    message: string;
  } {
    // Check if crafting is possible
    const { canCraft, missingResources, locationBonus } = this.canCraftItem(
      itemId,
      playerStore,
      cardStore,
      gameStore
    );
    
    if (!canCraft) {
      return {
        success: false,
        message: `Missing resources: ${missingResources.join(', ')}`
      };
    }
    
    // Get crafted item
    const item = cardStore.getCraftedItemById(itemId);
    if (!item) {
      return {
        success: false,
        message: 'Item not found'
      };
    }
    
    // Calculate crafting difficulty
    const difficulty = this.calculateCraftingDifficulty(item);
    
    // Calculate player bonus
    let craftingBonus = 0;
    
    // Character bonus
    if (playerStore.character?.type === 'iron_crafter') {
      craftingBonus += 2;
    }
    
    // Location bonus
    craftingBonus += locationBonus;
    
    // Beltane season bonus
    if (gameStore.season === Season.BELTANE) {
      craftingBonus += 1;
    }
    
    // Roll for success
    const diceRoll = diceService.rollD8();
    const total = diceRoll + craftingBonus;
    
    if (total >= difficulty) {
      // Crafting successful
      
      // Consume resources
      for (const resourceId of item.requiredResources) {
        playerStore.removeResource(resourceId);
      }
      
      // Calculate uses based on item and bonuses
      let uses = item.uses;
      
      // Iron Crafter bonus
      if (playerStore.character?.type === 'iron_crafter') {
        uses += 1;
      }
      
      // Beltane season bonus
      if (gameStore.season === Season.BELTANE) {
        uses += 1;
      }
      
      // Add item to inventory with use count
      const craftedItem = {
        ...item,
        remainingUses: uses
      };
      
      playerStore.addCraftedItem(craftedItem);
      
      return {
        success: true,
        item: craftedItem,
        message: `Successfully crafted ${item.name}`
      };
    } else {
      // Crafting failed
      return {
        success: false,
        message: `Failed to craft ${item.name} (rolled ${diceRoll}, needed ${difficulty - craftingBonus})`
      };
    }
  }
  
  // Use a crafted item
  useItem(itemId: string, playerStore, gameStore): {
    success: boolean;
    effect: string;
    drawback?: string;
  } {
    // Find item in inventory
    const item = playerStore.getCraftedItemById(itemId);
    if (!item || item.remainingUses <= 0) {
      return {
        success: false,
        effect: 'Item not found or no uses remaining'
      };
    }
    
    // Apply item effect
    const effect = this.applyItemEffect(item, playerStore, gameStore);
    
    // Apply item drawback
    const drawback = this.applyItemDrawback(item, playerStore, gameStore);
    
    // Reduce remaining uses
    playerStore.useItem(itemId);
    
    return {
      success: true,
      effect,
      drawback
    };
  }
  
  // Calculate crafting difficulty based on item complexity
  calculateCraftingDifficulty(item: CraftedItem): number {
    // Difficulty based on resource count
    const resourceCount = item.requiredResources.length;
    
    if (resourceCount <= 2) {
      return 5; // Simple item
    } else if (resourceCount <= 3) {
      return 6; // Complex item
    } else {
      return 7; // Legendary item
    }
  }
  
  // Get crafting bonus based on location
  getLocationCraftingBonus(itemId: string, locationId: string, cardStore): number {
    const item = cardStore.getCraftedItemById(itemId);
    const landscape = cardStore.getLandscapeById(locationId);
    
    if (!item || !landscape) {
      return 0;
    }
    
    // Location-specific bonuses
    const craftingBonuses = {
      'iron_forge_dell': (item) => {
        // Bonus for metal items (containing Bog Iron)
        return item.requiredResources.includes('bog_iron') ? 1 : 0;
      },
      'sacred_oak_grove': (item) => {
        // Bonus for wooden items (containing Rowan Wood)
        return item.requiredResources.includes('rowan_wood') ? 1 : 0;
      },
      'druids_sanctuary': (item) => {
        // Bonus for spiritual items (containing Standing Stone Chips)
        return item.requiredResources.includes('standing_stone_chips') ? 1 : 0;
      },
      'moonlit_loch': (item) => {
        // Bonus for water-based items (containing Sacred Water)
        return item.requiredResources.includes('sacred_water') ? 1 : 0;
      }
    };
    
    const bonusCalculator = craftingBonuses[locationId];
    return bonusCalculator ? bonusCalculator(item) : 0;
  }
  
  // Helper methods
  private applyItemEffect(item: CraftedItem, playerStore, gameStore): string;
  private applyItemDrawback(item: CraftedItem, playerStore, gameStore): string;
}

export const craftingService = new CraftingService();
```

#### Crafting Interface Component
Create a UI for the crafting system:

```vue
<!-- src/components/game/CraftingInterface.vue (structure) -->
<script setup lang="ts">
import { ref, computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { craftingService } from '@/services/craftingService';
import CraftedItemCard from '@/components/game/CraftedItemCard.vue';
import ResourceCard from '@/components/game/ResourceCard.vue';
import DiceRoller from '@/components/game/DiceRoller.vue';

const gameStore = useGameStore();
const playerStore = usePlayerStore();
const cardStore = useCardStore();

const selectedItemId = ref(null);
const craftingResult = ref(null);
const isRolling = ref(false);

// Get all available crafting recipes
const availableRecipes = computed(() => {
  return cardStore.getAllCraftedItems().map(item => {
    const craftCheck = craftingService.canCraftItem(
      item.id,
      playerStore,
      cardStore,
      gameStore
    );
    
    return {
      ...item,
      canCraft: craftCheck.canCraft,
      missingResources: craftCheck.missingResources,
      locationBonus: craftCheck.locationBonus
    };
  });
});

// Get crafting difficulty for selected item
const craftingDifficulty = computed(() => {
  if (!selectedItemId.value) return null;
  
  const item = cardStore.getCraftedItemById(selectedItemId.value);
  if (!item) return null;
  
  return craftingService.calculateCraftingDifficulty(item);
});

// Get player's crafting bonus
const craftingBonus = computed(() => {
  if (!selectedItemId.value) return 0;
  
  let bonus = 0;
  
  // Character bonus
  if (playerStore.character?.type === 'iron_crafter') {
    bonus += 2;
  }
  
  // Location bonus
  const locationBonus = craftingService.getLocationCraftingBonus(
    selectedItemId.value,
    gameStore.currentLandscapeId,
    cardStore
  );
  bonus += locationBonus;
  
  // Beltane season bonus
  if (gameStore.season === Season.BELTANE) {
    bonus += 1;
  }
  
  return bonus;
});

// Select an item for crafting
const selectItem = (itemId) => {
  selectedItemId.value = itemId;
  craftingResult.value = null;
};

// Attempt to craft the selected item
const craftItem = () => {
  if (!selectedItemId.value) return;
  
  isRolling.value = true;
  
  // Simulate dice roll animation
  setTimeout(() => {
    const result = craftingService.craftItem(
      selectedItemId.value,
      playerStore,
      cardStore,
      gameStore
    );
    
    craftingResult.value = result;
    isRolling.value = false;
  }, 1500);
};

// Continue to next phase
const continueToNextPhase = () => {
  gameStore.transitionToPhase(GamePhase.JOURNEY_PROGRESSION);
};
</script>

<template>
  <div class="crafting-interface">
    <h2>Crafting</h2>
    
    <div class="crafting-interface__recipes">
      <h3>Available Recipes</h3>
      
      <div class="recipe-grid">
        <div 
          v-for="recipe in availableRecipes"
          :key="recipe.id"
          class="recipe-item"
          :class="{
            'recipe-item--selected': selectedItemId === recipe.id,
            'recipe-item--available': recipe.canCraft,
            'recipe-item--unavailable': !recipe.canCraft
          }"
          @click="selectItem(recipe.id)"
        >
          <CraftedItemCard :item="recipe" />
          
          <div v-if="!recipe.canCraft" class="recipe-item__missing">
            Missing: {{ recipe.missingResources.length }} resources
          </div>
          
          <div v-if="recipe.locationBonus" class="recipe-item__bonus">
            Location bonus: +{{ recipe.locationBonus }}
          </div>
        </div>
      </div>
    </div>
    
    <div class="crafting-interface__details" v-if="selectedItemId">
      <h3>Crafting Details</h3>
      
      <div class="crafting-details">
        <div class="crafting-details__difficulty">
          <p>Difficulty: {{ craftingDifficulty }}</p>
          <p>Your bonus: +{{ craftingBonus }}</p>
          <p>Need to roll: {{ Math.max(1, craftingDifficulty - craftingBonus) }}+</p>
        </div>
        
        <div class="crafting-details__resources">
          <h4>Required Resources</h4>
          <div class="resource-list">
            <div 
              v-for="resourceId in cardStore.getCraftedItemById(selectedItemId)?.requiredResources"
              :key="resourceId"
              class="resource-item"
              :class="{
                'resource-item--available': playerStore.hasResource(resourceId),
                'resource-item--unavailable': !playerStore.hasResource(resourceId)
              }"
            >
              <ResourceCard :resource-id="resourceId" />
            </div>
          </div>
        </div>
      </div>
      
      <div class="crafting-interface__roll">
        <DiceRoller 
          v-if="isRolling || craftingResult"
          :sides="8"
          :rolling="isRolling"
          :result="craftingResult?.roll"
        />
      </div>
      
      <div v-if="craftingResult" class="crafting-result">
        <div 
          class="crafting-result__message"
          :class="{
            'crafting-result__message--success': craftingResult.success,
            'crafting-result__message--failure': !craftingResult.success
          }"
        >
          {{ craftingResult.message }}
        </div>
        
        <div v-if="craftingResult.item" class="crafting-result__item">
          <CraftedItemCard :item="craftingResult.item" />
        </div>
      </div>
    </div>
    
    <div class="crafting-interface__actions">
      <button 
        class="button button--primary"
        :disabled="!selectedItemId || isRolling || craftingResult || !availableRecipes.find(r => r.id === selectedItemId)?.canCraft"
        @click="craftItem"
      >
        Craft Item
      </button>
      
      <button 
        class="button button--secondary"
        @click="continueToNextPhase"
      >
        Continue
      </button>
    </div>
  </div>
</template>
```

### Deliverables
- Crafting recipe system with resource requirements
- Crafting success probability calculator
- Crafted item usage tracking with limiting uses
- Drawback system for item effects
- Location bonuses for specific crafting types
- Seasonal effects on crafting
- Crafting interface with recipe selection
- Crafting result visualization with animations

---

## Step 9: Threat & Victory Systems

### Technical Requirements
- Implement threat token accumulation system
- Build otherworldly manifestation mechanics
- Create victory condition validation
- Develop game completion flow
- Build narrative event system for threats

### Implementation Details

#### Threat Management Service
Create a service for managing threat:

```typescript
// src/services/threatService.ts
class ThreatService {
  // Add threat tokens
  addThreatTokens(amount: number, gameStore): number {
    const oldThreatLevel = Math.floor(gameStore.threatTokens / 3);
    
    gameStore.threatTokens += amount;
    
    // Prevent threat prevention effects
    // E.g., Rowan Wood can prevent 1 threat
    if (playerStore.hasActiveEffect('threat_prevention')) {
      const preventAmount = playerStore.getEffectStrength('threat_prevention');
      gameStore.threatTokens = Math.max(0, gameStore.threatTokens - preventAmount);
    }
    
    const newThreatLevel = Math.floor(gameStore.threatTokens / 3);
    
    // If threat level increased, trigger effects
    if (newThreatLevel > oldThreatLevel) {
      this.applyThreatLevelIncrease(oldThreatLevel, newThreatLevel, gameStore);
    }
    
    return gameStore.threatTokens;
  }
  
  // Remove threat tokens
  removeThreatTokens(amount: number, gameStore): number {
    const oldThreatLevel = Math.floor(gameStore.threatTokens / 3);
    
    gameStore.threatTokens = Math.max(0, gameStore.threatTokens - amount);
    
    const newThreatLevel = Math.floor(gameStore.threatTokens / 3);
    
    // If threat level decreased, clear effects
    if (newThreatLevel < oldThreatLevel) {
      this.applyThreatLevelDecrease(oldThreatLevel, newThreatLevel, gameStore);
    }
    
    return gameStore.threatTokens;
  }
  
  // Check for threat effects at start of turn
  checkThreatEffects(gameStore): ThreatEffect | null {
    // At 5+ tokens: Draw a random event
    if (gameStore.threatTokens >= 5 && gameStore.threatTokens < 10) {
      return this.generateRandomEvent();
    }
    
    // At 10+ tokens: Roll on Otherworldly Manifestation table
    if (gameStore.threatTokens >= 10) {
      return this.generateManifestation();
    }
    
    return null;
  }
  
  // Generate a random threat event
  generateRandomEvent(): ThreatEffect {
    const events = [
      {
        name: 'Spectral Mist',
        description: 'A thick mist descends, making navigation difficult.',
        effect: (gameStore, playerStore) => {
          // Next movement requires +1 on challenge roll
          gameStore.addTempEffect('difficult_navigation', 1);
        }
      },
      {
        name: 'Eerie Whispers',
        description: 'Unsettling whispers cause doubt and confusion.',
        effect: (gameStore, playerStore) => {
          // -1 to next mental challenge
          gameStore.addTempEffect('mental_challenge_penalty', 1);
        }
      },
      {
        name: 'Sudden Cold',
        description: 'An unnatural chill cuts to the bone.',
        effect: (gameStore, playerStore) => {
          // Lose 1 health unless at a shelter
          if (!landscapeService.isCurrentLocationShelter(gameStore)) {
            playerStore.modifyHealth(-1);
          }
        }
      },
      // More random events...
    ];
    
    const randomIndex = Math.floor(Math.random() * events.length);
    return events[randomIndex];
  }
  
  // Generate an otherworldly manifestation
  generateManifestation(): ThreatEffect {
    // Roll 1-8 on manifestation table
    const roll = diceService.rollD8();
    
    const manifestations = [
      {
        name: 'Mist Wraith',
        description: 'A ghostly figure formed of mist blocks your path.',
        resolution: 'Requires Amber Shards to banish.',
        effect: (gameStore, playerStore) => {
          // Implementation of effect
        }
      },
      {
        name: 'Barrow Wight',
        description: 'An ancient guardian of the dead rises.',
        resolution: 'Drains 1 health each turn until outrun or confronted.',
        effect: (gameStore, playerStore) => {
          // Implementation of effect
        }
      },
      // Other manifestations...
    ];
    
    return manifestations[roll - 1];
  }
  
  // Apply effects when threat level increases
  private applyThreatLevelIncrease(oldLevel: number, newLevel: number, gameStore): void {
    // Implement effects for crossing threat thresholds
  }
  
  // Apply effects when threat level decreases
  private applyThreatLevelDecrease(oldLevel: number, newLevel: number, gameStore): void {
    // Implement effects for reducing threat thresholds
  }
}

export const threatService = new ThreatService();
```

#### Victory Condition Service
Create a service for validating victory conditions:

```typescript
// src/services/victoryService.ts
class VictoryService {
  // Check all victory conditions
  checkVictoryConditions(gameStore, playerStore): {
    isVictory: boolean;
    conditions: {
      journeyCompleted: boolean;
      balanceMaintained: boolean;
      knowledgeAcquired: boolean;
      bondsFormed: boolean;
      questFulfilled: boolean;
    };
  } {
    const conditions = {
      journeyCompleted: this.checkJourneyCompletion(gameStore),
      balanceMaintained: this.checkBalanceMaintained(gameStore),
      knowledgeAcquired: this.checkKnowledgeAcquired(playerStore),
      bondsFormed: this.checkBondsFormed(playerStore),
      questFulfilled: this.checkPersonalQuest(playerStore, gameStore)
    };
    
    const isVictory = Object.values(conditions).every(Boolean);
    
    // Update game state
    gameStore.victoryConditions = conditions;
    
    return {
      isVictory,
      conditions
    };
  }
  
  // Check if journey is complete (all 15 landscapes visited)
  checkJourneyCompletion(gameStore): boolean {
    // Complete when returned to starting point after visiting all landscapes
    const lastLandscapeIndex = gameStore.journeyPath.length - 1;
    return gameStore.visitedLandscapes.length >= gameStore.journeyPath.length &&
           gameStore.currentLandscapeId === gameStore.journeyPath[lastLandscapeIndex];
  }
  
  // Check if balance is maintained (fewer than 6 threat tokens)
  checkBalanceMaintained(gameStore): boolean {
    return gameStore.threatTokens < 6;
  }
  
  // Check if knowledge acquired (at least 2 crafted items)
  checkKnowledgeAcquired(playerStore): boolean {
    return playerStore.craftedItems.length >= 2;
  }
  
  // Check if bonds formed (at least one animal companion)
  checkBondsFormed(playerStore): boolean {
    return playerStore.animalCompanions.length >= 1;
  }
  
  // Check character-specific personal quest
  checkPersonalQuest(playerStore, gameStore): boolean {
    switch (playerStore.character?.type) {
      case 'giant_beastfriend':
        // Bond with at least 4 different Animal Companions
        return playerStore.companionsBondedCount >= 4;
        
      case 'hedge_witch':
        // Create at least 3 different Crafted Items
        return playerStore.uniqueCraftedItemsCount >= 3;
        
      case 'iron_crafter':
        // Craft a Legendary Item
        return playerStore.hasCraftedLegendaryItem;
        
      case 'village_elder':
        // Visit all major sacred sites and perform rituals
        return gameStore.completedRitualSites.length >= 5;
        
      default:
        return false;
    }
  }
  
  // Process victory
  processVictory(gameStore): void {
    gameStore.isGameOver = true;
    gameStore.isVictory = true;
    gameStore.phase = GamePhase.GAME_OVER;
    
    // Record victory stats
    gameStore.gameStats = {
      turnsPlayed: gameStore.turn,
      threatTokens: gameStore.threatTokens,
      finalSeason: gameStore.season,
      timestamp: Date.now()
    };
  }
  
  // Process defeat
  processDefeat(gameStore, reason: string): void {
    gameStore.isGameOver = true;
    gameStore.isVictory = false;
    gameStore.gameOverReason = reason;
    gameStore.phase = GamePhase.GAME_OVER;
    
    // Record defeat stats
    gameStore.gameStats = {
      turnsPlayed: gameStore.turn,
      threatTokens: gameStore.threatTokens,
      finalSeason: gameStore.season,
      defeatReason: reason,
      timestamp: Date.now()
    };
  }
}

export const victoryService = new VictoryService();
```

#### Game Over Component
Create a UI for game completion:

```vue
<!-- src/components/game/GameOver.vue (structure) -->
<script setup lang="ts">
import { computed } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useRouter } from 'vue-router';

const gameStore = useGameStore();
const playerStore = usePlayerStore();
const router = useRouter();

const isVictory = computed(() => gameStore.isVictory);
const gameStats = computed(() => gameStore.gameStats);
const victoryConditions = computed(() => gameStore.victoryConditions);

const victoryPercentage = computed(() => {
  if (!victoryConditions.value) return 0;
  
  const completedConditions = Object.values(victoryConditions.value).filter(Boolean).length;
  return (completedConditions / 5) * 100;
});

// Start a new game
const startNewGame = () => {
  router.push('/setup');
};

// View game history
const viewHistory = () => {
  // Implementation for viewing game stats/history
};
</script>

<template>
  <div 
    class="game-over"
    :class="{
      'game-over--victory': isVictory,
      'game-over--defeat': !isVictory
    }"
  >
    <div class="game-over__content">
      <h1 v-if="isVictory" class="game-over__title game-over__title--victory">
        Victory!
      </h1>
      <h1 v-else class="game-over__title game-over__title--defeat">
        Journey's End
      </h1>
      
      <div class="game-over__message">
        <p v-if="isVictory">
          You have successfully completed your journey through the Celtic Realm,
          maintaining balance and gathering knowledge along the way.
        </p>
        <p v-else>
          Your journey has come to an end. {{ gameStore.gameOverReason }}
        </p>
      </div>
      
      <div class="game-over__stats">
        <h2>Journey Statistics</h2>
        <ul>
          <li>Turns Played: {{ gameStats.turnsPlayed }}</li>
          <li>Final Threat Level: {{ Math.floor(gameStats.threatTokens / 3) }} ({{ gameStats.threatTokens }} tokens)</li>
          <li>Final Season: {{ gameStats.finalSeason }}</li>
          <li>Resources Collected: {{ playerStore.resourcesCollectedCount }}</li>
          <li>Companions Bonded: {{ playerStore.companionsBondedCount }}</li>
          <li>Items Crafted: {{ playerStore.craftedItemsCount }}</li>
        </ul>
      </div>
      
      <div v-if="!isVictory" class="game-over__progress">
        <h2>Victory Progress</h2>
        <div class="progress-bar">
          <div class="progress-bar__fill" :style="`width: ${victoryPercentage}%`"></div>
        </div>
        <ul class="victory-conditions">
          <li 
            v-for="(completed, condition) in victoryConditions"
            :key="condition"
            :class="{ 'completed': completed }"
          >
            {{ formatConditionName(condition) }}: {{ completed ? 'Completed' : 'Incomplete' }}
          </li>
        </ul>
      </div>
      
      <div class="game-over__actions">
        <button 
          class="button button--primary"
          @click="startNewGame"
        >
          Start New Journey
        </button>
        
        <button 
          class="button button--secondary"
          @click="viewHistory"
        >
          View Journey Log
        </button>
      </div>
    </div>
  </div>
</template>
```

### Deliverables
- Threat token accumulation system
- Random event generation for moderate threat
- Otherworldly manifestation system for high threat
- Victory condition validation for all requirements
- Character-specific quest validation
- Game completion flow with statistics
- Victory/defeat screen with journey summary
- Threat visualization with escalating effects

---

## Step 10: Final Integration & Polish

### Technical Requirements
- Implement comprehensive test suite
- Create game tutorial system
- Optimize performance for mobile devices
- Implement accessibility features
- Add final visual polish and animations

### Implementation Details

#### Test Suite Implementation
Develop comprehensive tests for game functionality:

```typescript
// tests/unit/gameStore.test.ts (example structure)
import { describe, it, expect, beforeEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useGameStore } from '@/stores/gameStore';
import { GamePhase } from '@/models/enums/phases';
import { Season } from '@/models/enums/seasons';

describe('Game Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });
  
  it('initializes with default values', () => {
    const gameStore = useGameStore();
    
    expect(gameStore.phase).toBe(GamePhase.SETUP);
    expect(gameStore.turn).toBe(0);
    expect(gameStore.season).toBe(Season.SAMHAIN);
    expect(gameStore.threatTokens).toBe(0);
    expect(gameStore.blessingTokens).toBe(1);
    expect(gameStore.currentLandscapeId).toBeNull();
    expect(gameStore.visitedLandscapes).toEqual([]);
  });
  
  it('transitions between valid phases', () => {
    const gameStore = useGameStore();
    
    expect(gameStore.phase).toBe(GamePhase.SETUP);
    
    const result = gameStore.transitionToPhase(GamePhase.SEASONAL_ASSESSMENT);
    expect(result).toBe(true);
    expect(gameStore.phase).toBe(GamePhase.SEASONAL_ASSESSMENT);
  });
  
  it('prevents invalid phase transitions', () => {
    const gameStore = useGameStore();
    
    expect(gameStore.phase).toBe(GamePhase.SETUP);
    
    const result = gameStore.transitionToPhase(GamePhase.CHALLENGE_RESOLUTION);
    expect(result).toBe(false);
    expect(gameStore.phase).toBe(GamePhase.SETUP);
  });
  
  // More tests...
});
```
</file>

<file path="src/components/CardSection.vue">
<template>
    <div class="card-section" :class="{ 'card-section--expanded': expanded }">
      <div v-if="title" class="card-section__header" @click="toggleExpanded">
        <h3 class="card-section__title">{{ title }}</h3>
        <button v-if="collapsible" class="card-section__toggle">
          {{ expanded ? '' : '' }}
        </button>
      </div>
      
      <div v-if="!collapsible || expanded" :class="[
        'card-section__content',
        `card-section__content--${layout}`,
        { 'card-section__content--empty': $slots.empty && !hasChildren }
      ]">
        <slot v-if="hasChildren"></slot>
        <slot v-else name="empty">
          <div class="card-section__empty">
            No items to display
          </div>
        </slot>
      </div>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, useSlots, computed } from 'vue';
  
  export default defineComponent({
    name: 'CardSection',
    props: {
      title: {
        type: String,
        default: ''
      },
      layout: {
        type: String,
        default: 'grid',
        validator: (value: string) => ['grid', 'horizontal', 'vertical'].includes(value)
      },
      collapsible: {
        type: Boolean,
        default: false
      },
      initiallyExpanded: {
        type: Boolean,
        default: true
      }
    },
    setup(props) {
      const expanded = ref(props.initiallyExpanded);
      const slots = useSlots();
      
      const hasChildren = computed(() => {
        return !!slots.default && slots.default().length > 0;
      });
      
      const toggleExpanded = () => {
        if (props.collapsible) {
          expanded.value = !expanded.value;
        }
      };
      
      return {
        expanded,
        hasChildren,
        toggleExpanded
      };
    }
  });
  </script>
  
  <style lang="scss" scoped>
  .card-section {
    width: 100%;
    margin-bottom: 16px;
    
    &__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid rgba(140, 120, 81, 0.3);
      
      &:hover {
        cursor: pointer;
      }
    }
    
    &__title {
      margin: 0;
      color: #5a3e2b;
      font-family: 'Cinzel', serif;
    }
    
    &__toggle {
      background: none;
      border: none;
      font-size: 1rem;
      color: #5a3e2b;
      cursor: pointer;
      transition: transform 0.3s;
    }
    
    &__content {
      transition: max-height 0.3s ease, opacity 0.3s ease;
      
      &--grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
      }
      
      &--horizontal {
        display: flex;
        flex-wrap: nowrap;
        gap: 16px;
        overflow-x: auto;
        padding-bottom: 12px;
        
        > * {
          flex: 0 0 auto;
          width: 200px;
        }
      }
      
      &--vertical {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      
      &--empty {
        min-height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    }
    
    &__empty {
      color: #8c7851;
      font-style: italic;
      text-align: center;
      padding: 24px;
      background-color: rgba(240, 230, 210, 0.3);
      border-radius: 8px;
      width: 100%;
    }
    
    &--expanded {
      .card-section__toggle {
        transform: rotate(180deg);
      }
    }
  }
  
  @media (max-width: 768px) {
    .card-section {
      &__content--grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
    }
  }
  </style>
</file>

<file path="src/components/CompanionCard.vue">
<template>
    <GameCard 
      :title="companion?.name || 'Unknown Companion'" 
      :subtitle="'Animal Companion'" 
      :cardType="CardType.ANIMAL_COMPANION"
      :selected="selected"
      :disabled="isCompanionWary || abilityUsed"
      @click="$emit('select', companionId)"
    >
      <div class="companion-card__content">
        <div class="companion-loyalty">
          <div class="loyalty-meter">
            <div class="loyalty-bar" :style="loyaltyBarStyle"></div>
          </div>
        </div>
        
        <p v-if="companion?.ability">{{ companion.ability.description }}</p>
        
        <div class="companion-seasons" v-if="companion?.affinitySeasons?.length">
          <div class="season-tags">
            <span 
              v-for="season in companion.affinitySeasons" 
              :key="season"
              class="season-tag"
              :class="season.toLowerCase()"
            >
              {{ formatSeasonName(season) }}
            </span>
          </div>
        </div>
      </div>
      
      <template #footer>
        <div class="companion-card__actions">
          <button 
            v-if="canFeed"
            class="btn btn--primary"
            @click.stop="openFeedDialog"
          >
            Feed
          </button>
          <button 
            class="btn"
            @click.stop="$emit('use-ability', companionId)"
            :disabled="abilityUsed || isCompanionWary"
          >
            {{ isCompanionWary ? 'Wary' : (abilityUsed ? 'Used' : 'Use') }}
          </button>
        </div>
      </template>
    </GameCard>

    <!-- Feed Dialog -->
    <div class="feed-dialog-overlay" v-if="showFeedDialog">
      <div class="feed-dialog">
        <div class="feed-dialog__header">
          <h3>Feed {{ companion?.name }}</h3>
          <button class="close-btn" @click="closeFeedDialog">&times;</button>
        </div>
        
        <div class="feed-dialog__content">
          <p>Select a resource to feed your companion:</p>
          
          <div class="resource-list">
            <div 
              v-for="resource in compatibleResources" 
              :key="resource.id"
              class="resource-item"
              :class="{ 'selected': selectedResource === resource.id }"
              @click="selectedResource = resource.id"
            >
              <span>{{ resource.name }}</span>
            </div>
            <div v-if="compatibleResources.length === 0" class="empty-state">
              No compatible resources available.
            </div>
          </div>
        </div>
        
        <div class="feed-dialog__footer">
          <button 
            class="btn btn--primary" 
            @click="feedCompanion"
            :disabled="!selectedResource || compatibleResources.length === 0"
          >
            Feed
          </button>
          <button class="btn btn--secondary" @click="closeFeedDialog">
            Cancel
          </button>
        </div>
      </div>
    </div>
  </template>
  
  <script>
  import { defineComponent, computed, ref } from 'vue';
  import { CardType } from '@/models/enums/cardTypes';
  import GameCard from '@/components/core/GameCard.vue';
  import { useServices } from '@/composables/useServices';
  
  export default defineComponent({
    name: 'CompanionCard',
    components: {
      GameCard
    },
    props: {
      companionId: {
        type: String,
        required: true
      },
      selected: {
        type: Boolean,
        default: false
      },
      abilityUsed: {
        type: Boolean,
        default: false
      },
      canFeed: {
        type: Boolean,
        default: false
      }
    },
    emits: ['select', 'use-ability', 'feed', 'update:canFeed'],
    setup(props, { emit }) {
      const { cardRepository, companionService } = useServices();
      
      const showFeedDialog = ref(false);
      const selectedResource = ref('');
      
      // Get companion data - now using cardRepository from services
      const companion = computed(() => {
        return cardRepository.getAnimalCompanionById(props.companionId);
      });
      
      // Get companion loyalty
      const loyalty = computed(() => {
        return companionService.getLoyalty(props.companionId);
      });
      
      // Loyalty bar style - use the service method
      const loyaltyBarStyle = computed(() => {
        return companionService.getLoyaltyBarStyle(props.companionId);
      });
      
      // Compatible resources for feeding - use the service method
      const compatibleResources = computed(() => {
        return companionService.getCompatibleResources(props.companionId);
      });
      
      // Check if companion is wary
      const isCompanionWary = computed(() => {
        return companionService.isCompanionWary(props.companionId);
      });
      
      // Format season name for display - use the service method
      const formatSeasonName = (season) => {
        return companionService.formatSeasonName(season);
      };
      
      // Dialog management
      const openFeedDialog = () => {
        showFeedDialog.value = true;
      };
      
      const closeFeedDialog = () => {
        showFeedDialog.value = false;
        selectedResource.value = '';
      };
      
      const feedCompanion = () => {
        if (selectedResource.value) {
          emit('update:canFeed', false);
          emit('feed', props.companionId, selectedResource.value);
          closeFeedDialog();
        }
      };
      
      return {
        companion,
        loyalty,
        loyaltyBarStyle,
        isCompanionWary,
        compatibleResources,
        showFeedDialog,
        selectedResource,
        formatSeasonName,
        openFeedDialog,
        closeFeedDialog,
        feedCompanion,
        CardType
      };
    }
  });
  </script>
  
  <style lang="scss" scoped>
  .companion-card__content {
    display: flex;
    flex-direction: column;
    width: 100%;
    gap: 8px;
  }
  
  .companion-loyalty {
    margin-bottom: 8px;
  }
  
  .loyalty-meter {
    height: 8px;
    background-color: #eee;
    border-radius: 4px;
    overflow: hidden;
  }
  
  .loyalty-bar {
    height: 100%;
    transition: width 0.3s, background-color 0.3s;
  }
  
  .season-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
    margin-top: 4px;
  }
  
  .season-tag {
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 10px;
    
    &.samhain {
      background-color: #8b6a2c;
      color: white;
    }
    
    &.winters_depth {
      background-color: #b3c7d6;
      color: #333;
    }
    
    &.imbolc {
      background-color: #c6d8c6;
      color: #333;
    }
    
    &.beltane {
      background-color: #f7c9a9;
      color: #333;
    }
    
    &.lughnasadh {
      background-color: #f0d9a0;
      color: #333;
    }
  }
  
  .companion-card__actions {
    display: flex;
    gap: 4px;
    
    .btn {
      flex: 1;
      padding: 4px;
      border-radius: 4px;
      font-size: 0.8rem;
      background: #e6d7b9;
      border: 1px solid #8c7851;
      cursor: pointer;
      
      &:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      &--primary {
        background: #5a3e2b;
        color: white;
      }
    }
  }
  
  // Feed Dialog Styles
  .feed-dialog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  
  .feed-dialog {
    background-color: #fff;
    border-radius: 8px;
    width: 90%;
    max-width: 400px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    
    &__header {
      padding: 16px;
      border-bottom: 1px solid #eee;
      display: flex;
      justify-content: space-between;
      align-items: center;
      
      h3 {
        margin: 0;
        color: #5a3e2b;
      }
      
      .close-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #999;
        
        &:hover {
          color: #333;
        }
      }
    }
    
    &__content {
      padding: 16px;
      
      .resource-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 12px;
        max-height: 200px;
        overflow-y: auto;
      }
      
      .resource-item {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        
        &:hover {
          background-color: #f5f5f5;
        }
        
        &.selected {
          background-color: rgba(76, 175, 80, 0.1);
          border-color: #4CAF50;
        }
      }
      
      .empty-state {
        padding: 16px;
        text-align: center;
        color: #999;
        font-style: italic;
      }
    }
    
    &__footer {
      padding: 16px;
      border-top: 1px solid #eee;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
  }
  </style>
</file>

<file path="src/components/CraftingRecipeCard.vue">
<template>
    <GameCard 
      :title="recipe.name" 
      :subtitle="`Complexity: ${recipe.complexity}`" 
      :cardType="CardType.CRAFTED_ITEM"
      :selected="selected"
      :disabled="!canCraft"
      @click="$emit('select', recipe.id)"
    >
      <div class="recipe-card__content">
        <p>{{ truncateDescription(recipe.description) }}</p>
        
        <div class="recipe-resources">
          <h5>Required:</h5>
          <div class="resource-list">
            <div 
              v-for="resourceId in recipe.requiredResources" 
              :key="resourceId"
              class="resource-tag"
              :class="{ 'available': hasResource(resourceId), 'missing': !hasResource(resourceId) }"
            >
              {{ getResourceName(resourceId) }}
            </div>
          </div>
        </div>
        
        <div class="recipe-ability" v-if="recipe.ability">
          <p class="ability-name">{{ recipe.ability.name }}</p>
        </div>
      </div>
      
      <template #footer v-if="showActions">
        <div class="recipe-card__actions">
          <button 
            class="btn btn--primary"
            @click.stop="$emit('craft', recipe.id)"
            :disabled="!canCraft"
          >
            Craft
          </button>
          <button 
            class="btn"
            @click.stop="$emit('cancel')"
          >
            Cancel
          </button>
        </div>
      </template>
    </GameCard>
  </template>
  
  <script>
  import { defineComponent, computed } from 'vue';
  import { CardType } from '@/models/enums/cardTypes';
  import GameCard from '@/components/core/GameCard.vue';
  import { usePlayerStore } from '@/stores/playerStore';
  import { useServices } from '@/composables/useServices';
  
  export default defineComponent({
    name: 'CraftingRecipeCard',
    components: {
      GameCard
    },
    props: {
      recipe: {
        type: Object,
        required: true
      },
      selected: {
        type: Boolean,
        default: false
      },
      showActions: {
        type: Boolean,
        default: false
      }
    },
    emits: ['select', 'craft', 'cancel'],
    setup(props) {
      const playerStore = usePlayerStore();
      const { craftingService, cardRepository } = useServices();
      
      // Check if player has a specific resource
      const hasResource = (resourceId) => {
        return craftingService.hasResource(resourceId);
      };
      
      // Get the name of a resource
      const getResourceName = (resourceId) => {
        return craftingService.getResourceName(resourceId);
      };
      
      // Check if player can craft this item
      const canCraft = computed(() => {
        return craftingService.canCraftItem(props.recipe.id);
      });
      
      // Truncate description for display
      const truncateDescription = (text) => {
        return craftingService.truncateDescription(text);
      };
      
      return {
        hasResource,
        getResourceName,
        canCraft,
        truncateDescription,
        CardType
      };
    }
  });
  </script>
  
  <style lang="scss" scoped>
  .recipe-card__content {
    display: flex;
    flex-direction: column;
    width: 100%;
    gap: 8px;
    font-size: 0.9rem;
  }
  
  .recipe-resources {
    margin-top: 6px;
    
    h5 {
      margin: 0 0 4px 0;
      font-size: 0.9rem;
    }
  }
  
  .resource-list {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
  }
  
  .resource-tag {
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 10px;
    
    &.available {
      background-color: rgba(76, 175, 80, 0.2);
      color: #2e7d32;
    }
    
    &.missing {
      background-color: rgba(244, 67, 54, 0.2);
      color: #c62828;
    }
  }
  
  .recipe-ability {
    margin-top: 6px;
    
    .ability-name {
      font-weight: bold;
      font-size: 0.8rem;
      color: #5a3e2b;
    }
  }
  
  .recipe-card__actions {
    display: flex;
    gap: 4px;
    
    .btn {
      flex: 1;
      padding: 4px;
      border-radius: 4px;
      font-size: 0.8rem;
      background: #e6d7b9;
      border: 1px solid #8c7851;
      cursor: pointer;
      
      &:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      &--primary {
        background: #5a3e2b;
        color: white;
      }
    }
  }
  </style>
</file>

<file path="src/components/GameCard.vue">
<template>
    <div 
      class="game-card" 
      :class="[
        `game-card--${cardTypeClass}`,
        { 'game-card--disabled': disabled, 'game-card--selected': selected }
      ]"
      @click="!disabled && $emit('click', $event)"
    >
      <!-- Card Header -->
      <div class="game-card__header">
        <h3 class="game-card__title">{{ title }}</h3>
        <div v-if="subtitle" class="game-card__subtitle">{{ subtitle }}</div>
      </div>
      
      <!-- Card Body with Background Symbol -->
      <div class="game-card__body">
        <div v-if="!noSymbol" class="game-card__symbol">{{ getSuitSymbol() }}</div>
        <slot></slot>
      </div>
      
      <!-- Optional Footer -->
      <div v-if="$slots.footer" class="game-card__footer">
        <slot name="footer"></slot>
      </div>
    </div>
  </template>
  
  <script>
  import { defineComponent } from 'vue';
  import { CardType } from '@/models/enums/cardTypes';
  import { Season } from '@/models/enums/seasons';
  
  export default defineComponent({
    name: 'GameCard',
    props: {
      title: {
        type: String,
        required: true
      },
      subtitle: {
        type: String,
        default: ''
      },
      cardType: {
        type: [String, Number],
        required: true,
        validator: (value) => {
          // Allow both string values and enum values to be passed
          return Object.values(CardType).includes(value);
        }
      },
      season: {
        type: String,
        default: null
      },
      selected: {
        type: Boolean,
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      noSymbol: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      cardTypeClass() {
        if (!this.cardType) return '';
        return this.cardType.toString().toLowerCase().replace(/_/g, '-');
      }
    },
    methods: {
      getSuitSymbol() {
        // Return different suit symbols based on card type
        switch(this.cardType) {
          case CardType.LANDSCAPE: return ''; 
          case CardType.ANIMAL_COMPANION: return '';
          case CardType.RESOURCE: return '';
          case CardType.CRAFTED_ITEM: return '';
          case CardType.SEASON: return '';
          case CardType.CHARACTER: return '';
          case CardType.ACTION: return '';
          default: return '';
        }
      }
    },
    emits: ['click']
  });
  </script>
  
  <style lang="scss" scoped>
  .game-card {
    position: relative;
    border-radius: 12px;
    aspect-ratio: 2.5/3.5;
    width: 100%;
    max-width: 220px;
    display: flex;
    flex-direction: column;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    overflow: hidden;
    background: linear-gradient(to bottom, #f0e6d2 0%, #e6d7b9 100%);
    border: 2px solid #8c7851;
    transition: all 0.3s ease;
    cursor: pointer;
    
    &:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.2);
    }
    
    &--selected {
      transform: scale(1.05);
      border-color: #4a7c59;
      box-shadow: 0 0 0 2px #4a7c59, 0 8px 16px rgba(0,0,0,0.2);
    }
    
    &--disabled {
      opacity: 0.6;
      filter: grayscale(0.5);
      cursor: not-allowed;
      
      &:hover {
        transform: none;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      }
    }
    
    &__header {
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
      padding: 10px;
      text-align: center;
      background-color: rgba(140, 120, 81, 0.25);
      z-index: 2;
    }
    
    &__title {
      margin: 0;
      font-size: 1.1rem;
      text-transform: capitalize;
      color: #5a3e2b;
      font-weight: bold;
    }
    
    &__subtitle {
      font-size: 0.8rem;
      opacity: 0.8;
      color: #5a3e2b;
    }
    
    &__body {
      flex-grow: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 15px;
      z-index: 1;
      color: #5a3e2b;
      position: relative;
    }
    
    &__symbol {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 4rem;
      opacity: 0.07;
      pointer-events: none;
      color: #5a3e2b;
      z-index: 0;
    }
    
    &__footer {
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
      padding: 10px;
      text-align: center;
      background-color: rgba(140, 120, 81, 0.15);
      z-index: 2;
    }
    
    // Card type styling
    &--landscape {
      border-top: 4px solid #6c4f30;
    }
    
    &--animal-companion {
      border-top: 4px solid #8a4444;
    }
    
    &--resource {
      border-top: 4px solid #4c6c42;
    }
    
    &--crafted-item {
      border-top: 4px solid #444b69;
    }
    
    &--character {
      border: 2px solid #82632b;
      border-top-width: 4px;
    }
    
    &--action {
      border: 2px solid #5a3e2b;
      border-top-width: 4px;
      background: linear-gradient(to bottom, #f0c8a0 0%, #e8d5b2 100%);
    }
  }
  </style>
</file>

<file path="src/components/ResourceCard.vue">
<template>
    <GameCard 
      :title="resource.name" 
      :subtitle="resource.rarity" 
      :cardType="CardType.RESOURCE"
      :selected="selected"
      @click="$emit('select', resource.id)"
    >
      <div class="resource-card__content">
        <p>{{ truncateDescription(resource.description) }}</p>
        
        <div class="resource-seasons" v-if="resource.seasonalAbundance?.length">
          <div class="season-tags">
            <span 
              v-for="season in resource.seasonalAbundance" 
              :key="season"
              class="season-tag"
              :class="getSeasonClassName(season)"
            >
              {{ formatSeasonName(season) }}
            </span>
          </div>
        </div>
        
        <div class="resource-special" v-if="resource.specialEffect">
          <p class="special-effect">{{ resource.specialEffect.description }}</p>
        </div>
      </div>
      
      <template #footer v-if="showActions">
        <div class="resource-card__actions">
          <button 
            class="btn btn--primary"
            @click.stop="$emit('use', resource.id)"
            :disabled="!resource.specialEffect"
          >
            Use
          </button>
          <button 
            class="btn"
            @click.stop="$emit('discard', resource.id)"
          >
            Discard
          </button>
        </div>
      </template>
    </GameCard>
  </template>
  
  <script>
  import { defineComponent } from 'vue';
  import { CardType } from '@/models/enums/cardTypes';
  import GameCard from '@/components/core/GameCard.vue';
  import { resourceService } from '@/services/resourceService';
  
  export default defineComponent({
    name: 'ResourceCard',
    components: {
      GameCard
    },
    props: {
      resource: {
        type: Object,
        required: true
      },
      selected: {
        type: Boolean,
        default: false
      },
      showActions: {
        type: Boolean,
        default: false
      }
    },
    emits: ['select', 'use', 'discard'],
    setup(props) {
      // Truncate description for display - use the service method
      const truncateDescription = (text) => {
        return resourceService.truncateDescription(text);
      };
      
      // Format season name for display - use the service method
      const formatSeasonName = (season) => {
        return resourceService.formatSeasonName(season);
      };
      
      // Get CSS class for season - use the service method
      const getSeasonClassName = (season) => {
        return resourceService.getSeasonClassName(season);
      };
      
      return {
        CardType,
        truncateDescription,
        formatSeasonName,
        getSeasonClassName
      };
    }
  });
  </script>
  
  <style lang="scss" scoped>
  .resource-card__content {
    display: flex;
    flex-direction: column;
    width: 100%;
    gap: 8px;
    font-size: 0.9rem;
  }
  
  .resource-seasons {
    margin-top: 6px;
  }
  
  .season-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    justify-content: center;
  }
  
  .season-tag {
    font-size: 0.7rem;
    padding: 2px 6px;
    border-radius: 10px;
    
    &.imbolc {
      background-color: #e6f7ff;
      color: #0066cc;
    }
    
    &.beltane {
      background-color: #f0fff0;
      color: #228b22;
    }
    
    &.lughnasadh {
      background-color: #fff0e0;
      color: #b25900;
    }
    
    &.samhain {
      background-color: #f9e6ff;
      color: #5a008a;
    }
    
    &.winters-depth {
      background-color: #e6f0ff;
      color: #0047b3;
    }
  }
  
  .resource-special {
    margin-top: 6px;
    
    .special-effect {
      font-style: italic;
      font-size: 0.8rem;
      color: #5a3e2b;
    }
  }
  
  .resource-card__actions {
    display: flex;
    gap: 4px;
    
    .btn {
      flex: 1;
      padding: 4px;
      border-radius: 4px;
      font-size: 0.8rem;
      background: #e6d7b9;
      border: 1px solid #8c7851;
      cursor: pointer;
      
      &:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      
      &--primary {
        background: #5a3e2b;
        color: white;
      }
    }
  }
  </style>
</file>

<file path="src/composables/useGameState.ts">
import { computed, ref } from 'vue';
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { useSeasonStore } from '@/stores/seasonStore';
import { useJourneyStore } from '@/stores/journeyStore';
import { useChallenge } from '@/stores/challengeStore';
import { GamePhase } from '@/models/enums/phases';
import { Season } from '@/models/enums/seasons';

/**
 * Composable for accessing and manipulating game state
 * Provides a unified interface to interact with multiple stores
 */
export function useGameState() {
  const gameStore = useGameStore();
  const playerStore = usePlayerStore();
  const cardStore = useCardStore();
  const seasonStore = useSeasonStore();
  const journeyStore = useJourneyStore();
  const challengeStore = useChallenge();

  // Computed properties for common game state
  const isGameStarted = computed(() => gameStore.currentPhase !== GamePhase.SETUP);
  const currentCharacter = computed(() => 
    playerStore.characterId ? cardStore.getCharacterById(playerStore.characterId) : null
  );
  const currentLandscape = computed(() => 
    journeyStore.currentLandscapeId ? cardStore.getLandscapeById(journeyStore.currentLandscapeId) : null
  );
  const currentSeason = computed(() => 
    seasonStore.currentSeason ? cardStore.getSeasonById(seasonStore.currentSeason) : null
  );
  const playerResources = computed(() => 
    playerStore.resources.map(id => cardStore.getResourceById(id)).filter(Boolean)
  );
  const playerCompanions = computed(() => 
    playerStore.animalCompanions.map(id => cardStore.getAnimalCompanionById(id)).filter(Boolean)
  );
  const playerCraftedItems = computed(() => 
    playerStore.craftedItems.map(id => cardStore.getCraftedItemById(id)).filter(Boolean)
  );
  const journeyProgress = computed(() => {
    const totalLandscapes = 15; // Total number of landscapes in the game
    return Math.floor((journeyStore.visitedLandscapes.length / totalLandscapes) * 100);
  });
  const threatLevel = computed(() => 
    Math.floor(challengeStore.threatTokens / 3)
  );

  // Game state helpers
  const canCraftItems = computed(() => 
    isGameStarted.value && 
    playerResources.value.length > 0 && 
    gameStore.currentPhase === GamePhase.RESOURCE_MANAGEMENT
  );
  
  const canBondWithCompanion = computed(() => 
    isGameStarted.value && 
    playerResources.value.length > 0 && 
    gameStore.currentPhase === GamePhase.ANIMAL_COMPANION
  );

  const canResolveChallenge = computed(() => 
    isGameStarted.value && 
    gameStore.currentPhase === GamePhase.LANDSCAPE_CHALLENGE
  );

  // Return all the state and helpers
  return {
    // Stores
    gameStore,
    playerStore,
    cardStore,
    seasonStore,
    journeyStore,
    challengeStore,
    
    // Game state
    isGameStarted,
    currentCharacter,
    currentLandscape,
    currentSeason,
    playerResources,
    playerCompanions,
    playerCraftedItems,
    journeyProgress,
    threatLevel,
    
    // Game state helpers
    canCraftItems,
    canBondWithCompanion,
    canResolveChallenge
  };
}
</file>

<file path="src/models/data/characters.d.ts">
// Type definitions for characters.js
import { CharacterCard } from '@/models/types/cards';

declare const characters: CharacterCard[];
export default characters;
</file>

<file path="src/models/data/characters.js">
// Character data based on the game rules
export const characters = [
  {
    id: 'giant_beastfriend',
    name: 'Giant Beastfriend',
    description: 'A towering figure with a natural affinity for wild creatures, able to form bonds with even the most ferocious beasts.',
    abilities: [
      {
        name: 'Animal Empathy',
        description: 'Animal Companions cost -1 resource to bond with'
      },
      {
        name: 'Multiple Companions',
        description: 'May use two Animal Companions simultaneously'
      }
    ],
    startingItems: ['horse_hair', 'standing_stone_chips'],
    health: 7,
    resourceCapacity: 8,
    specialAction: {
      name: 'Wild Call',
      description: 'Once per journey, summon any animal companion temporarily without forming a permanent bond',
      uses: 1
    },
    image: 'giant_beastfriend.jpg',
    stats: {
      physical: 3,
      mental: 2,
      spiritual: 3,
      social: 1
    },
    weakness: 'Cannot use crafted items containing Bog Iron without penalty (-2 to related checks)'
  },
  {
    id: 'hedge_witch',
    name: 'Hedge Witch/Warlock',
    description: 'A practitioner of herbal magic and minor enchantments who dwells at the borderlands between civilization and wilderness.',
    abilities: [
      {
        name: 'Herbal Knowledge',
        description: 'Can substitute one resource for another when crafting'
      },
      {
        name: 'Extra Crafting',
        description: 'May craft one additional item beyond normal limits'
      }
    ],
    startingItems: ['silver_mistletoe', 'sacred_water'],
    health: 5,
    resourceCapacity: 7,
    specialAction: {
      name: 'Herbal Remedy',
      description: 'Once per journey, create a potion that heals 3 health or removes a negative effect',
      uses: 1
    },
    image: 'hedge_witch.jpg',
    stats: {
      physical: 1,
      mental: 3,
      spiritual: 4,
      social: 1
    },
    weakness: '-2 penalty on all social challenges in villages'
  },
  {
    id: 'iron_crafter',
    name: 'Iron Crafter',
    description: 'A master smith whose knowledge of metals and fire allows them to create items of remarkable power.',
    abilities: [
      {
        name: 'Master Smith',
        description: 'Crafting requires one fewer resource'
      },
      {
        name: 'Durable Crafting',
        description: 'Crafted items have one additional use before breaking'
      }
    ],
    startingItems: ['bog_iron', 'forge_cinders'],
    health: 6,
    resourceCapacity: 6,
    specialAction: {
      name: 'Forge Blessing',
      description: 'Once per journey, instantly craft any one item without requiring resources',
      uses: 1
    },
    image: 'iron_crafter.jpg',
    stats: {
      physical: 3,
      mental: 3,
      spiritual: 1,
      social: 2
    },
    weakness: 'Cannot use Animal Companions effectively (-1 to their abilities)'
  },
  {
    id: 'village_elder',
    name: 'Village Elder',
    description: 'A respected keeper of tradition and wisdom, whose connection to the community provides unique advantages.',
    abilities: [
      {
        name: 'Ancient Wisdom',
        description: 'Start with knowledge of entire journey path (all landscapes revealed at beginning)'
      },
      {
        name: 'Communal Aid',
        description: 'Can invoke communal aid once per season (automatic success on one challenge)'
      }
    ],
    startingItems: ['ogham_sticks', 'barrow_dust'],
    health: 5,
    resourceCapacity: 5,
    specialAction: {
      name: 'Ancestral Guidance',
      description: 'Once per journey, consult with ancestral spirits to avoid one negative outcome completely',
      uses: 1
    },
    image: 'village_elder.jpg',
    stats: {
      physical: 1,
      mental: 4,
      spiritual: 3,
      social: 3
    },
    weakness: 'Physical challenges are more difficult (+1 difficulty)'
  }
];

export default characters;
</file>

<file path="src/models/data/companions.d.ts">
// Type definitions for companions.js
import { AnimalCompanionCard } from '@/models/types/cards';

declare const companions: AnimalCompanionCard[];
export default companions;
</file>

<file path="src/models/data/crafted-items.d.ts">
// Type definitions for crafted-items.js
import { CraftedItemCard } from '@/models/types/cards';

declare const craftedItems: CraftedItemCard[];
export default craftedItems;
</file>

<file path="src/models/data/crafted-items.js">
// Crafted Items data based on the game rules
export const craftedItems = [
  {
    id: 'beast_speaker_charm',
    name: 'Beast Speaker Charm',
    requiredResources: ['horse_hair', 'amber_shards', 'oak_galls'],
    ability: 'Command any Animal Companion regardless of season',
    drawback: 'The charm slowly drains your vitality (-1 Health per 3 turns)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 3,
    image: 'beast_speaker_charm.jpg',
    abilityFunction: (gameState, companion) => {
      return {
        success: true,
        message: `The Beast Speaker Charm allows you to command ${companion.name} regardless of the current season.`,
        effect: {
          type: 'companion_boost',
          target: companion.id,
          boost: 1
        },
        drawback: {
          type: 'health_drain',
          interval: 3,
          amount: 1
        }
      }
    }
  },
  {
    id: 'colossal_whistle',
    name: 'Colossal Whistle',
    requiredResources: ['rowan_wood', 'silver_mistletoe'],
    ability: 'Summon aid from great beasts to overcome any physical challenge',
    drawback: 'May attract unwanted attention (add 2 Threat tokens)',
    complexity: 'simple',
    difficulty: 5,
    maxUses: 2,
    image: 'colossal_whistle.jpg',
    abilityFunction: (gameState, challengeType) => {
      if (challengeType === 'physical') {
        return {
          success: true,
          message: 'The Colossal Whistle summons great beasts to aid you, automatically succeeding at the physical challenge.',
          effect: {
            type: 'auto_success',
            challengeType: 'physical'
          },
          drawback: {
            type: 'threat_increase',
            amount: 2
          }
        }
      }
      return {
        success: false,
        message: 'The Colossal Whistle can only help with physical challenges.'
      }
    }
  },
  {
    id: 'earth_speaker_staff',
    name: 'Earth Speaker Staff',
    requiredResources: ['rowan_wood', 'standing_stone_chips', 'barrow_dust'],
    ability: 'Automatically succeed wisdom and knowledge challenges',
    drawback: 'Each use ages the wielder (lose 1 Resource capacity)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 3,
    image: 'earth_speaker_staff.jpg',
    abilityFunction: (gameState, challengeType) => {
      if (['wisdom', 'knowledge', 'mental'].includes(challengeType)) {
        return {
          success: true,
          message: 'The Earth Speaker Staff channels ancient wisdom, automatically succeeding at the mental challenge.',
          effect: {
            type: 'auto_success',
            challengeType: challengeType
          },
          drawback: {
            type: 'capacity_loss',
            amount: 1
          }
        }
      }
      return {
        success: false,
        message: 'The Earth Speaker Staff can only help with wisdom and knowledge challenges.'
      }
    }
  },
  {
    id: 'giants_bridle',
    name: 'Giant\'s Bridle',
    requiredResources: ['bog_iron', 'horse_hair', 'woven_reeds'],
    ability: 'Control powerful entities and redirect their strength',
    drawback: 'The controlled entity may break free (roll D8 each use, free on 1-2)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 2,
    image: 'giants_bridle.jpg',
    abilityFunction: (gameState) => {
      const breakFreeRoll = Math.floor(Math.random() * 8) + 1
      const breakFree = breakFreeRoll <= 2
      
      return {
        success: !breakFree,
        message: breakFree 
          ? 'The Giant\'s Bridle fails to control the entity, which breaks free!' 
          : 'The Giant\'s Bridle allows you to control a powerful entity, redirecting its strength to your advantage.',
        effect: breakFree ? null : {
          type: 'challenge_bonus',
          bonus: 3
        },
        drawback: breakFree ? {
          type: 'threat_increase',
          amount: 2
        } : null
      }
    }
  },
  {
    id: 'ogham_divining_set',
    name: 'Ogham Divining Set',
    requiredResources: ['oak_galls', 'sacred_water', 'ogham_sticks'],
    ability: 'Foresee and avoid one challenge completely',
    drawback: 'Glimpsing fate may reveal unwelcome truths (draw a Curse card)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 1,
    image: 'ogham_divining_set.jpg',
    abilityFunction: (gameState) => {
      return {
        success: true,
        message: 'The Ogham Divining Set reveals the future, allowing you to avoid one challenge completely.',
        effect: {
          type: 'skip_challenge',
          count: 1
        },
        drawback: {
          type: 'curse',
          description: 'You glimpse an unwelcome truth about your future.'
        }
      }
    }
  },
  {
    id: 'seasonal_compass',
    name: 'Seasonal Compass',
    requiredResources: ['amber_shards', 'standing_stone_chips', 'forge_cinders'],
    ability: 'Change the current season for one round',
    drawback: 'Disrupts natural order (add 1 Threat token)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 1,
    image: 'seasonal_compass.jpg',
    abilityFunction: (gameState, targetSeason) => {
      return {
        success: true,
        message: `The Seasonal Compass shifts the world around you, temporarily changing the season to ${targetSeason.name}.`,
        effect: {
          type: 'season_change',
          season: targetSeason.id,
          duration: 1
        },
        drawback: {
          type: 'threat_increase',
          amount: 1
        }
      }
    }
  },
  {
    id: 'iron_grove_key',
    name: 'Iron Grove Key',
    requiredResources: ['bog_iron', 'silver_mistletoe', 'forge_cinders'],
    ability: 'Unlock hidden paths and secret areas on Landscape cards',
    drawback: 'Opens doors for otherworldly beings (roll on Manifestation table)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 2,
    image: 'iron_grove_key.jpg',
    abilityFunction: (gameState, landscape) => {
      // Roll for manifestation (1-8)
      const manifestationRoll = Math.floor(Math.random() * 8) + 1
      
      return {
        success: true,
        message: 'The Iron Grove Key unlocks a hidden path, revealing secrets of this landscape.',
        effect: {
          type: 'reveal_secret',
          landscape: landscape.id
        },
        drawback: {
          type: 'manifestation',
          roll: manifestationRoll
        }
      }
    }
  },
  {
    id: 'spirit_bridge_tokens',
    name: 'Spirit Bridge Tokens',
    requiredResources: ['barrow_dust', 'sacred_water', 'amber_shards'],
    ability: 'Travel instantly to any previously visited Landscape',
    drawback: 'Spiritual disorientation (-2 to next challenge roll)',
    complexity: 'complex',
    difficulty: 6,
    maxUses: 1,
    image: 'spirit_bridge_tokens.jpg',
    abilityFunction: (gameState, targetLandscapeIndex) => {
      if (targetLandscapeIndex <= gameState.journeyProgress) {
        return {
          success: true,
          message: 'The Spirit Bridge Tokens create a mystical pathway, allowing you to travel instantly to a previously visited landscape.',
          effect: {
            type: 'teleport',
            destination: targetLandscapeIndex
          },
          drawback: {
            type: 'challenge_penalty',
            amount: -2,
            duration: 1
          }
        }
      }
      return {
        success: false,
        message: 'The Spirit Bridge Tokens cannot take you to a place you haven\'t yet visited.'
      }
    }
  }
]
</file>

<file path="src/models/data/landscapes.d.ts">
// Type definitions for landscapes.js
import { LandscapeCard } from '@/models/types/cards';

declare const landscapes: LandscapeCard[];
export default landscapes;
</file>

<file path="src/models/data/resources.d.ts">
// Type definitions for resources.js
import { ResourceCard } from '@/models/types/cards';

declare const resources: ResourceCard[];
export default resources;
</file>

<file path="src/models/data/seasons.js">
// Seasons data based on the game rules
export const seasons = [
  {
    id: 'samhain',
    name: 'Samhain',
    description: 'Winter Beginning - The veil between worlds is thin during this season.',
    effect: 'Spiritual challenges are harder (+2 difficulty)',
    benefit: 'Ancestral guidance available (may consult discard pile once)',
    resourceAbundance: ['barrow_dust', 'standing_stone_chips'],
    resourceScarcity: ['woven_reeds', 'rowan_wood'],
    animalAffinity: ['wolf', 'raven', 'owl'],
    image: 'samhain.jpg',
    modifiers: {
      spiritual: 2,
      physical: 0,
      mental: 0,
      social: 0
    },
    quest: {
      name: 'Honor the Ancestors',
      location: 'misty_barrow_downs',
      requirement: 'Make an offering of Barrow Dust',
      reward: 'Gain the protection of an ancestor (+1 to all challenges until next season)'
    }
  },
  {
    id: 'wintersDepth',
    name: 'Winter\'s Depth',
    description: 'The coldest and harshest part of winter tests your endurance.',
    effect: 'Physical challenges are harder (+2 difficulty)',
    benefit: 'Clearer thinking in stillness (+1 to wisdom challenges)',
    resourceAbundance: ['forge_cinders', 'bog_iron'],
    resourceScarcity: ['sacred_water', 'horse_hair'],
    animalAffinity: ['wolf', 'raven', 'owl'],
    image: 'winters_depth.jpg',
    modifiers: {
      spiritual: 0,
      physical: 2,
      mental: -1,
      social: 0
    },
    quest: {
      name: 'Forge of Endurance',
      location: 'iron_forge_dell',
      requirement: 'Craft an item containing Bog Iron',
      reward: 'Gain +1 max Health permanently'
    }
  },
  {
    id: 'imbolc',
    name: 'Imbolc',
    description: 'Spring Stirrings - The first signs of spring bring renewal and hope.',
    effect: 'Renewal energy makes healing more effective (recover +1 Health)',
    benefit: 'New growth provides hope (+1 to all challenge rolls)',
    resourceAbundance: ['silver_mistletoe', 'sacred_water'],
    resourceScarcity: ['barrow_dust', 'forge_cinders'],
    animalAffinity: ['hare', 'deer', 'salmon'],
    image: 'imbolc.jpg',
    modifiers: {
      spiritual: 0,
      physical: 0,
      mental: 0,
      social: 0,
      all: 1 // +1 to all challenge rolls
    },
    quest: {
      name: 'Awakening the Land',
      location: 'sacred_oak_grove',
      requirement: 'Plant a seed (discard Oak Galls)',
      reward: 'Remove 3 Threat tokens'
    }
  },
  {
    id: 'beltane',
    name: 'Beltane',
    description: 'Summer Beginning - The height of life energy and fertility.',
    effect: 'Vibrant energy enhances all crafting (crafted items gain +1 use)',
    benefit: 'Life force is strong (max Health increased by 1)',
    resourceAbundance: ['rowan_wood', 'oak_galls'],
    resourceScarcity: ['standing_stone_chips', 'amber_shards'],
    animalAffinity: ['fox', 'horse', 'bear'],
    image: 'beltane.jpg',
    modifiers: {
      spiritual: 0,
      physical: 0,
      mental: 0,
      social: 0
    },
    quest: {
      name: 'Sacred Union',
      location: 'faerie_knoll',
      requirement: 'Successfully complete a challenge with two different Animal Companions',
      reward: 'Gain a unique Blessing token that can be used twice'
    }
  },
  {
    id: 'lughnasadh',
    name: 'Lughnasadh',
    description: 'Harvest Beginning - The first harvest brings abundance and community.',
    effect: 'Gathering time (collect +1 Resource when successful)',
    benefit: 'Community support (double the effectiveness of healing)',
    resourceAbundance: ['horse_hair', 'woven_reeds', 'ogham_sticks'],
    resourceScarcity: ['bog_iron', 'silver_mistletoe'],
    animalAffinity: ['boar'],
    image: 'lughnasadh.jpg',
    modifiers: {
      spiritual: 0,
      physical: 0,
      mental: 0,
      social: -1 // Easier social challenges due to community support
    },
    quest: {
      name: 'First Harvest',
      location: 'gathering_fair',
      requirement: 'Trade 3 resources for 1 Crafted Item component',
      reward: 'Gain +1 Resource capacity permanently'
    }
  }
]
</file>

<file path="src/models/enums/actions.ts">
export enum PlayerAction {
  GATHER_RESOURCE = 'GATHER_RESOURCE',
  USE_RESOURCE = 'USE_RESOURCE',
  BOND_COMPANION = 'BOND_COMPANION',
  CRAFT_ITEM = 'CRAFT_ITEM',
  USE_ITEM = 'USE_ITEM',
  FACE_CHALLENGE = 'FACE_CHALLENGE',
  USE_ABILITY = 'USE_ABILITY',
  REST = 'REST',
  EXPLORE = 'EXPLORE',
  PREVENT_THREAT = 'PREVENT_THREAT'
}
</file>

<file path="src/models/enums/seasons.ts">
export enum Season {
  SAMHAIN = 'samhain',
  WINTERS_DEPTH = 'wintersDepth',
  IMBOLC = 'imbolc',
  BELTANE = 'beltane',
  LUGHNASADH = 'lughnasadh'
}
</file>

<file path="src/models/types/cards.ts">
import { CardType, ChallengeType } from '../enums/cardTypes';
import { Season } from '../enums/seasons';

interface BaseCard {
  id: string;
  name: string;
  description: string;
  type: CardType;
}

interface GameCard extends BaseCard {
  image: string;
}

export interface CharacterCard extends GameCard {
  type: CardType.CHARACTER;
  healthPoints: number;
  strength: number;
  wisdom: number;
  agility: number;
  diplomacy: number;
  survival: number;
  resourceCapacity: number;
  specialAbility: {
    name: string;
    description: string;
  };
  startingResources: string[];
  startingCompanion?: string;
  startingCompanions?: string[];
  challengeBonuses?: {
    [key: string]: number;
  };
}

export interface LandscapeCard extends GameCard {
  type: CardType.LANDSCAPE;
  challenge: string;
  challengeType: string;
  difficulty: number;
  description: string;
  availableResources: string[];
  animalCompanions?: string[];
  challenges?: Array<{
    type: string;
    difficulty: number;
  }>;
  specialFeature?: {
    name: string;
    description: string;
    effect: string;
  };
  providesShelter?: boolean;
  entryEffect?: {
    description: string;
    effect: string;
  };
  craftingBonuses?: {
    [key: string]: number;
  };
  hasCraftingFacilities?: boolean;
}

export interface AnimalCompanionCard extends GameCard {
  type: CardType.ANIMAL_COMPANION;
  description: string;
  ability: {
    name: string;
    description: string;
  };
  affinitySeasons: Season[];
  preferredResources?: string[];
  challengeBonuses?: {
    [key: string]: number;
  };
  seasonalBonuses?: {
    [key: string]: {
      [key: string]: number;
    };
  };
  bondingEffect?: (playerStore: any) => void;
  loyaltyEffects?: {
    [key: number]: (playerStore: any) => void;
  };
}

export interface ResourceCard extends GameCard {
  type: CardType.RESOURCE;
  description: string;
  resourceType: string;
  effect: {
    name: string;
    description: string;
  };
  season: string;
  rarity: 'common' | 'uncommon' | 'rare';
  seasonalAbundance: Season[];
  specialEffect?: {
    name: string;
    description: string;
    effect: string;
  };
}

export interface ChallengeCard {
  id: string;
  name: string;
  description: string;
  type: ChallengeType;
  difficulty: number;
  rewards: {
    resources?: string[];
    experience?: number;
    knowledge?: string;
  };
}

export interface CraftedItemCard extends GameCard {
  type: CardType.CRAFTED_ITEM;
  description: string;
  requiredResources: string[];
  ability: {
    name: string;
    description: string;
    type?: string;
  };
  complexity: number;
  drawback?: {
    description: string;
    effect: string;
  };
  isLegendary?: boolean;
  challengeBonuses?: {
    [key: string]: number;
  };
}

export interface SeasonCard extends GameCard {
  type: CardType.SEASON;
  description: string;
  effect: string;
  benefit: string;
  resourceAbundance?: string[];
  resourceScarcity?: string[];
  animalAffinity?: string[];
  animalAffinities?: string[];
  season: Season;
  abundantResources: string[];
  scarceResources: string[];
  modifiers?: {
    spiritual: number;
    physical: number;
    mental: number;
    social: number;
  };
  effects?: Array<{
    name: string;
    effect: string | number;
  }>;
  quest?: {
    name: string;
    location: string;
    requirement: string;
    reward: string;
  };
}
</file>

<file path="src/models/types/game.ts">
import { GamePhase } from '../enums/phases';
import { Season } from '../enums/seasons';
import { LandscapeCard, SeasonCard } from './cards';
import { ChallengeType } from '../enums/cardTypes';

export interface ChallengeOutcome {
  success: boolean | 'partial';
  exceptional: boolean;
  roll: number;
  total: number;
  difficulty: number;
}

export interface Challenge {
  id: string;
  name: string;
  description: string;
  type: ChallengeType;
  difficulty: number;
  requiredSkill: string;
  reward: {
    resources?: string[];
    experience?: number;
    knowledge?: string;
  };
  resourceReward?: string[];
  successEffect?: {
    description: string;
    effect: string;
  };
  partialSuccessEffect?: {
    description: string;
    effect: string;
  };
  failureEffect?: {
    description: string;
    effect: string;
  };
}

export interface ChallengeResult {
  success: boolean;
  resourcesGained: string[];
  experienceGained: number;
  knowledgeGained: string | null;
  healthLost: number;
}

export interface VictoryConditions {
  journeyCompleted: boolean;
  balanceMaintained: boolean;
  knowledgeAcquired: boolean;
  bondsFormed: boolean;
  questFulfilled: boolean;
  landscapesTraversed: boolean;
  seasonsExperienced: boolean;
  challengesOvercome: boolean;
}

export interface GameState {
  currentTurn: number;
  currentSeason: Season;
  currentLandscapeId: string;
  currentChallenge: string | null;
  isVictory: boolean;
  gameOver: boolean;
  threatTokens: number;
  tempEffects: TempEffect[];
}

export interface TempEffect {
  id: string;
  name: string;
  description: string;
  strength: number;
  duration: number;
}

export interface ThreatEffect {
  name: string;
  description: string;
  resolution?: string;
  effect: (gameStore: any, playerStore: any) => void;
}

export interface GameLogEntry {
  message: string;
  timestamp: number;
  highlight?: boolean;
  type?: 'phase' | 'action' | 'challenge' | 'resource' | 'companion' | 'crafting' | 'system' | 'error' | 'debug';
  details?: {
    [key: string]: any;
  };
  turn?: number;
  season?: Season;
}
</file>

<file path="src/services/challengeService.ts">
/**
 * Challenge Service
 * Handles challenge difficulty calculation and resolution
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { diceService } from '@/services/diceService';
import { ChallengeOutcome, Challenge } from '@/models/types/game';
import { ChallengeType } from '@/models/enums/cardTypes';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';
import { Season } from '@/models/enums/seasons';

class ChallengeService {
  // Private properties with consistent naming
  private _lastChallengeId: string | null = null;
  private _lastChallengeOutcome: ChallengeOutcome | null = null;
  
  /**
   * Calculate challenge difficulty based on multiple factors
   * @param challenge The challenge to calculate difficulty for
   * @returns The calculated difficulty value
   */
  calculateDifficulty(challenge: Challenge): number {
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    const baseDifficulty = challenge.difficulty;
    
    // Apply seasonal modifiers
    const seasonModifier = this._getSeasonalModifier(challenge.type, gameStore.currentSeason);
    
    // Apply threat level modifier
    const threatModifier = Math.floor(gameStore.threatTokens / 3);
    
    return baseDifficulty + seasonModifier + threatModifier;
  }
  
  /**
   * Calculate player's bonus for a challenge
   * @param challenge The challenge to calculate bonus for
   * @returns The calculated player bonus
   */
  calculatePlayerBonus(challenge: Challenge): number {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const cardStore = useCardStore();
    
    // Character ability bonus
    let bonus = this._getCharacterBonus(playerStore.characterId, challenge.type);
    
    // Item bonuses
    bonus += this._getItemBonuses(playerStore.craftedItems, challenge.type);
    
    // Companion bonuses
    bonus += this._getCompanionBonuses(playerStore.animalCompanions, challenge.type);
    
    // Blessing tokens
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    bonus += gameStore.blessingTokens;
    
    return bonus;
  }
  
  /**
   * Determine challenge outcome
   * @param challenge The challenge to resolve
   * @returns The challenge outcome
   */
  resolveChallenge(challenge: Challenge): ChallengeOutcome {
    const difficulty = this.calculateDifficulty(challenge);
    const playerBonus = this.calculatePlayerBonus(challenge);
    
    const diceRoll = diceService.rollD8();
    const total = diceRoll + playerBonus;
    
    // Record the challenge attempt
    this._recordChallengeAttempt({
      challengeType: challenge.type,
      difficulty,
      diceRoll,
      playerBonus,
      total
    });
    
    // Natural 8 always succeeds
    if (diceRoll === 8) {
      const outcome = {
        success: true,
        exceptional: true,
        roll: diceRoll,
        total,
        difficulty
      };
      
      this._lastChallengeOutcome = outcome;
      return outcome;
    }
    
    // Success: total >= difficulty
    if (total >= difficulty) {
      const outcome = {
        success: true,
        exceptional: total >= difficulty + 2,
        roll: diceRoll,
        total,
        difficulty
      };
      
      this._lastChallengeOutcome = outcome;
      return outcome;
    }
    
    // Partial success: total = difficulty - 1
    if (total === difficulty - 1) {
      const outcome: ChallengeOutcome = {
        success: 'partial' as const,
        exceptional: false,
        roll: diceRoll,
        total,
        difficulty
      };
      
      this._lastChallengeOutcome = outcome;
      return outcome;
    }
    
    // Failure
    const outcome = {
      success: false,
      exceptional: total <= difficulty - 3,
      roll: diceRoll,
      total,
      difficulty
    };
    
    this._lastChallengeOutcome = outcome;
    return outcome;
  }
  
  /**
   * Apply challenge outcomes
   * @param outcome The challenge outcome
   * @param challenge The challenge that was attempted
   */
  applyOutcome(outcome: ChallengeOutcome, challenge: Challenge): void {
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    if (outcome.success === true) {
      // Full success
      if (outcome.exceptional) {
        // Exceptional success (e.g., gain blessing token)
        gameStore.blessingTokens++;
      }
      
      // Collect resources if applicable
      if (challenge.resourceReward) {
        this._collectResources(2);
      }
      
      // Apply any specific success effects
      if (challenge.successEffect) {
        // Instead of calling the effect, just log it
        gameStore.addToGameLog(`Success effect: ${challenge.successEffect.description}`, false);
      }
    } else if (outcome.success === 'partial') {
      // Partial success
      if (challenge.resourceReward) {
        this._collectResources(1);
      }
      
      // Apply any specific partial success effects
      if (challenge.partialSuccessEffect) {
        // Instead of calling the effect, just log it
        gameStore.addToGameLog(`Partial success effect: ${challenge.partialSuccessEffect.description}`, false);
      }
    } else {
      // Failure
      if (outcome.exceptional) {
        // Exceptional failure (e.g., add threat token)
        gameStore.addThreatTokens(1);
      }
      
      // Apply any specific failure effects
      if (challenge.failureEffect) {
        // Instead of calling the effect, just log it
        gameStore.addToGameLog(`Failure effect: ${challenge.failureEffect.description}`, false);
      }
    }
  }
  
  /**
   * Get the last challenge outcome
   * @returns The last challenge outcome or null if no challenge has been resolved
   */
  getLastOutcome(): ChallengeOutcome | null {
    return this._lastChallengeOutcome;
  }
  
  /**
   * Reset the service state
   */
  reset(): void {
    this._lastChallengeId = null;
    this._lastChallengeOutcome = null;
  }
  
  /**
   * Record a challenge attempt for history tracking
   * @param attempt The challenge attempt details
   */
  private _recordChallengeAttempt(attempt: {
    challengeType: ChallengeType;
    difficulty: number;
    diceRoll: number;
    playerBonus: number;
    total: number;
  }): void {
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    // Create a record with the required properties
    const record = {
      id: `challenge_${gameStore.currentTurn}_${Date.now()}`,
      outcome: attempt.total >= attempt.difficulty ? 'success' : 'failure',
      turn: gameStore.currentTurn
    };
    
    this._lastChallengeId = record.id;
    gameStore.challengeHistory.push(record);
  }
  
  /**
   * Get seasonal modifier for a challenge type
   * @param challengeType The type of challenge
   * @param season The current season
   * @returns The seasonal modifier value
   */
  private _getSeasonalModifier(challengeType: ChallengeType, season: Season): number {
    // Define seasonal challenge modifiers
    const seasonalModifiers = {
      'SAMHAIN': {
        'spiritual': -1,
        'physical': 1
      },
      'WINTERS_DEPTH': {
        'physical': 1,
        'mental': 0
      },
      'IMBOLC': {
        'spiritual': -1,
        'social': -1
      },
      'BELTANE': {
        'social': -1,
        'mental': 0
      },
      'LUGHNASADH': {
        'physical': -1,
        'spiritual': 0
      }
    };
    
    // If no modifiers for this season or challenge type, return 0
    if (!seasonalModifiers[season] || !seasonalModifiers[season][challengeType]) {
      return 0;
    }
    
    return seasonalModifiers[season][challengeType];
  }
  
  /**
   * Get character bonus for a challenge type
   * @param characterId The character ID
   * @param challengeType The type of challenge
   * @returns The character bonus value
   */
  private _getCharacterBonus(characterId: string, challengeType: ChallengeType): number {
    const cardStore = useCardStore();
    const character = cardStore.getCharacterById(characterId);
    
    if (!character || !character.challengeBonuses) {
      return 0;
    }
    
    return character.challengeBonuses[challengeType] || 0;
  }
  
  /**
   * Get item bonuses for a challenge type
   * @param itemIds Array of crafted item IDs
   * @param challengeType The type of challenge
   * @returns The total item bonuses
   */
  private _getItemBonuses(itemIds: string[], challengeType: ChallengeType): number {
    const cardStore = useCardStore();
    let totalBonus = 0;
    
    for (const itemId of itemIds) {
      const item = cardStore.getCraftedItemById(itemId);
      if (item && item.challengeBonuses && item.challengeBonuses[challengeType]) {
        totalBonus += item.challengeBonuses[challengeType];
      }
    }
    
    return totalBonus;
  }
  
  /**
   * Get companion bonuses for a challenge type
   * @param companionIds Array of companion IDs
   * @param challengeType The type of challenge
   * @returns The total companion bonuses
   */
  private _getCompanionBonuses(companionIds: string[], challengeType: ChallengeType): number {
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    let totalBonus = 0;
    
    for (const companionId of companionIds) {
      const companion = cardStore.getCompanionById(companionId);
      if (companion && companion.challengeBonuses) {
        // Base bonus
        if (companion.challengeBonuses[challengeType]) {
          totalBonus += companion.challengeBonuses[challengeType];
        }
        
        // Seasonal bonus
        if (companion.seasonalBonuses && 
            companion.seasonalBonuses[gameStore.currentSeason] && 
            companion.seasonalBonuses[gameStore.currentSeason][challengeType]) {
          totalBonus += companion.seasonalBonuses[gameStore.currentSeason][challengeType];
        }
      }
    }
    
    return totalBonus;
  }
  
  /**
   * Collect resources as a reward
   * @param count Number of resources to collect
   */
  private _collectResources(count: number): void {
    // This would typically call resourceService.collectLandscapeResources
    // For now, we'll just log it
    console.log(`Collecting ${count} resources`);
  }
}

// Export as a singleton instance for consistent access pattern
export const challengeService = new ChallengeService();
</file>

<file path="src/services/diceService.ts">
/**
 * Dice Service
 * Provides functions for dice rolling mechanics in the game
 */

// Use a consistent class implementation
class DiceService {
  // Private properties with consistent naming
  private _debugMode = false;
  private _forcedValue: number | null = null;
  
  /**
   * Roll a specific die (d4, d6, d8, etc.)
   * @param sides The number of sides on the die
   * @returns The roll result
   */
  rollDie(sides: number): number {
    if (this._debugMode && this._forcedValue !== null) {
      return this._forcedValue;
    }
    return Math.floor(Math.random() * sides) + 1;
  }
  
  /**
   * Roll the game's eight-sided die
   * @returns The roll result
   */
  rollD8(): number {
    return this.rollDie(8);
  }
  
  /**
   * Roll with advantage (roll twice, take higher)
   * @param sides The number of sides on the die
   * @returns Object containing the rolls and the result
   */
  rollWithAdvantage(sides: number): { rolls: number[], result: number } {
    const roll1 = this.rollDie(sides);
    const roll2 = this.rollDie(sides);
    return {
      rolls: [roll1, roll2],
      result: Math.max(roll1, roll2)
    };
  }
  
  /**
   * Roll with disadvantage (roll twice, take lower)
   * @param sides The number of sides on the die
   * @returns Object containing the rolls and the result
   */
  rollWithDisadvantage(sides: number): { rolls: number[], result: number } {
    const roll1 = this.rollDie(sides);
    const roll2 = this.rollDie(sides);
    return {
      rolls: [roll1, roll2],
      result: Math.min(roll1, roll2)
    };
  }
  
  /**
   * Set a forced roll value for testing purposes
   * @param value The value to force, or null to disable forced roll
   */
  setForcedRoll(value: number | null): void {
    this._debugMode = value !== null;
    this._forcedValue = value;
  }
  
  /**
   * Reset the service state
   */
  reset(): void {
    this._debugMode = false;
    this._forcedValue = null;
  }
}

// Export as a singleton instance for consistent access pattern
export const diceService = new DiceService();
</file>

<file path="src/services/threatService.ts">
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { TempEffect } from '@/models/types/game';
import { PlayerEffect } from '@/models/types/player';
import { Season } from '@/models/enums/seasons';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';

// Threat manifestation types
export enum ThreatManifestationType {
  RESOURCE_LOSS = 'RESOURCE_LOSS',
  HEALTH_LOSS = 'HEALTH_LOSS',
  CHALLENGE_DIFFICULTY = 'CHALLENGE_DIFFICULTY',
  COMPANION_EFFECT = 'COMPANION_EFFECT',
  LANDSCAPE_EFFECT = 'LANDSCAPE_EFFECT',
  SEASONAL_SHIFT = 'SEASONAL_SHIFT'
}

// Threat event types
export enum ThreatEventType {
  MINOR = 'MINOR',
  MODERATE = 'MODERATE',
  MAJOR = 'MAJOR'
}

// Otherworldly manifestation types - Aligned with game requirements
export enum OtherworldlyManifestationType {
  MIST_WRAITH = 'MIST_WRAITH',
  BARROW_WIGHT = 'BARROW_WIGHT',
  FAERIE_ENTICEMENT = 'FAERIE_ENTICEMENT',
  WILD_HUNT = 'WILD_HUNT',
  ANCIENT_GUARDIAN = 'ANCIENT_GUARDIAN',
  BOUNDARY_COLLAPSE = 'BOUNDARY_COLLAPSE',
  SPIRIT_POSSESSION = 'SPIRIT_POSSESSION',
  COSMIC_IMBALANCE = 'COSMIC_IMBALANCE'
}

// Interface for threat events
export interface ThreatEvent {
  id: string;
  name: string;
  description: string;
  type: ThreatEventType;
  manifestation: ThreatManifestationType;
  strength: number;
  duration: number;
}

/**
 * Service for managing threat tokens and their effects in the game
 */
export class ThreatService {
  private gameStore = useGameStore() as unknown as ExtendedGameStore;
  private playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
  private cardStore = useCardStore();
  
  // Track threat reduction per turn
  private threatReductionThisTurn = 0;
  
  // Maximum threat reduction allowed per turn
  private readonly MAX_THREAT_REDUCTION_PER_TURN = 3;
  
  // Sacred sites for threat reduction
  private readonly SACRED_SITES = {
    MOONLIT_LOCH: 'moonlit_loch',
    DRUIDS_SANCTUARY: 'druids_sanctuary'
  };
  
  // Resources that can affect threat
  private readonly THREAT_RESOURCES = {
    SACRED_WATER: 'sacred_water',
    ROWAN_WOOD: 'rowan_wood'
  };
  
  // Track if seasonal ritual has been performed
  private hasPerformedSeasonalRitual = false;
  
  // Predefined threat events
  private threatEvents: ThreatEvent[] = [
    // Minor threat events
    {
      id: 'threat_event_1',
      name: 'Unsettling Whispers',
      description: 'Strange whispers echo through the landscape, causing unease.',
      type: ThreatEventType.MINOR,
      manifestation: ThreatManifestationType.CHALLENGE_DIFFICULTY,
      strength: 1,
      duration: 2
    },
    {
      id: 'threat_event_2',
      name: 'Sudden Chill',
      description: 'A bone-deep chill sets in, making it harder to perform tasks.',
      type: ThreatEventType.MINOR,
      manifestation: ThreatManifestationType.HEALTH_LOSS,
      strength: 1,
      duration: 1
    },
    {
      id: 'threat_event_3',
      name: 'Misplaced Supplies',
      description: 'Some of your resources have mysteriously gone missing.',
      type: ThreatEventType.MINOR,
      manifestation: ThreatManifestationType.RESOURCE_LOSS,
      strength: 1,
      duration: 1
    },
    
    // Moderate threat events
    {
      id: 'threat_event_4',
      name: 'Otherworldly Fog',
      description: 'A thick, unnatural fog descends, obscuring paths and hiding dangers.',
      type: ThreatEventType.MODERATE,
      manifestation: ThreatManifestationType.LANDSCAPE_EFFECT,
      strength: 2,
      duration: 3
    },
    {
      id: 'threat_event_5',
      name: 'Animal Unrest',
      description: 'Animals in the area become agitated and difficult to approach.',
      type: ThreatEventType.MODERATE,
      manifestation: ThreatManifestationType.COMPANION_EFFECT,
      strength: 2,
      duration: 2
    },
    {
      id: 'threat_event_6',
      name: 'Weakening Boundaries',
      description: 'The veil between worlds thins, allowing strange energies to seep through.',
      type: ThreatEventType.MODERATE,
      manifestation: ThreatManifestationType.CHALLENGE_DIFFICULTY,
      strength: 2,
      duration: 3
    },
    
    // Major threat events
    {
      id: 'threat_event_7',
      name: 'Seasonal Disruption',
      description: 'The natural cycle of seasons is disrupted, causing environmental chaos.',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.SEASONAL_SHIFT,
      strength: 3,
      duration: 4
    },
    {
      id: 'threat_event_8',
      name: 'Otherworldly Manifestation',
      description: 'A powerful entity from beyond manifests, draining life force from all it encounters.',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.HEALTH_LOSS,
      strength: 3,
      duration: 3
    },
    {
      id: 'threat_event_9',
      name: 'Resource Blight',
      description: 'A mysterious blight affects resources in the area, causing them to wither or spoil.',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.RESOURCE_LOSS,
      strength: 3,
      duration: 4
    }
  ];
  
  // Predefined otherworldly manifestations - Aligned with game requirements
  private otherworldlyManifestations: (ThreatEvent & {
    counterResource?: string;
    requiresChallenge?: boolean;
    challengeType?: string;
    requiresOffering?: boolean;
  })[] = [
    {
      id: 'manifestation_1',
      name: 'Mist Wraith',
      description: 'Obscures path, requires Amber Shards to banish',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.LANDSCAPE_EFFECT,
      strength: 2,
      duration: 3,
      counterResource: 'amber_shards'
    },
    {
      id: 'manifestation_2',
      name: 'Barrow Wight',
      description: 'Drains health each turn, must outrun or confront',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.HEALTH_LOSS,
      strength: 2,
      duration: 3,
      requiresChallenge: true
    },
    {
      id: 'manifestation_3',
      name: 'Faerie Enticement',
      description: 'Attempts to lead you astray, requires willpower challenge',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.CHALLENGE_DIFFICULTY,
      strength: 2,
      duration: 2,
      challengeType: 'mental'
    },
    {
      id: 'manifestation_4',
      name: 'Wild Hunt',
      description: 'Pursues you for 1d4 turns, must hide or join the hunt',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.CHALLENGE_DIFFICULTY,
      strength: 3,
      duration: Math.floor(Math.random() * 4) + 1, // 1d4 turns
      challengeType: 'physical'
    },
    {
      id: 'manifestation_5',
      name: 'Ancient Guardian',
      description: 'Blocks path, requires specific offering or riddling',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.LANDSCAPE_EFFECT,
      strength: 3,
      duration: 2,
      requiresOffering: true
    },
    {
      id: 'manifestation_6',
      name: 'Boundary Collapse',
      description: 'Seasons blur, unpredictable effects each turn',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.SEASONAL_SHIFT,
      strength: 3,
      duration: 4
    },
    {
      id: 'manifestation_7',
      name: 'Spirit Possession',
      description: 'Animal Companion turns against you',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.COMPANION_EFFECT,
      strength: 3,
      duration: 3
    },
    {
      id: 'manifestation_8',
      name: 'Cosmic Imbalance',
      description: 'All challenges +2 difficulty until balance restored',
      type: ThreatEventType.MAJOR,
      manifestation: ThreatManifestationType.CHALLENGE_DIFFICULTY,
      strength: 2,
      duration: 4
    }
  ];
  
  /**
   * Add threat tokens to the game state
   * @param amount Number of threat tokens to add
   * @returns Current number of threat tokens
   */
  public addThreatTokens(amount: number): number {
    return this.gameStore.addThreatTokens(amount);
  }
  
  /**
   * Remove threat tokens from the game state
   * @param amount Number of threat tokens to remove
   * @returns Current number of threat tokens
   */
  public removeThreatTokens(amount: number): number {
    // Enforce maximum threat reduction per turn
    const remainingReduction = this.MAX_THREAT_REDUCTION_PER_TURN - this.threatReductionThisTurn;
    if (remainingReduction <= 0) {
      this.gameStore.addToGameLog('Maximum threat reduction reached for this turn.', true);
      return this.gameStore.threatTokens;
    }
    
    // Adjust amount if it would exceed the maximum
    const actualAmount = Math.min(amount, remainingReduction);
    
    // Update the reduction tracker
    this.threatReductionThisTurn += actualAmount;
    
    // Log the reduction
    if (actualAmount < amount) {
      this.gameStore.addToGameLog(`Reduced ${actualAmount} threat tokens (limit reached for this turn).`, true);
    }
    
    return this.gameStore.removeThreatTokens(actualAmount);
  }
  
  /**
   * Reset the threat reduction tracker for a new turn
   */
  public resetThreatReductionTracker(): void {
    this.threatReductionThisTurn = 0;
  }
  
  /**
   * Get the current threat level (1 level per 3 tokens)
   * @returns Current threat level
   */
  public getThreatLevel(): number {
    return Math.floor(this.gameStore.threatTokens / 3);
  }
  
  /**
   * Check if the player has an effect that prevents threat
   * @returns True if player has threat prevention effect
   */
  public hasThreatPrevention(): boolean {
    return this.playerStore.hasEffect('threat_prevention');
  }
  
  /**
   * Generate a random threat event based on current threat level
   * @returns A random threat event
   */
  public generateRandomThreatEvent(): ThreatEvent | null {
    const threatLevel = this.getThreatLevel();
    
    // No events if threat level is 0
    if (threatLevel === 0) {
      return null;
    }
    
    // Filter events based on threat level
    let eligibleEvents: ThreatEvent[] = [];
    
    if (threatLevel === 1) {
      eligibleEvents = this.threatEvents.filter(event => event.type === ThreatEventType.MINOR);
    } else if (threatLevel === 2) {
      eligibleEvents = this.threatEvents.filter(event => 
        event.type === ThreatEventType.MINOR || event.type === ThreatEventType.MODERATE
      );
    } else {
      // All events are eligible at threat level 3+
      eligibleEvents = this.threatEvents;
    }
    
    // Return random event from eligible events
    if (eligibleEvents.length > 0) {
      const randomIndex = Math.floor(Math.random() * eligibleEvents.length);
      return eligibleEvents[randomIndex];
    }
    
    return null;
  }
  
  /**
   * Apply a threat event to the game state
   * @param event The threat event to apply
   */
  public applyThreatEvent(event: ThreatEvent): void {
    // Skip if player has threat prevention
    if (this.hasThreatPrevention()) {
      this.gameStore.addToGameLog(`${event.name} was prevented by your protective effects!`, true);
      return;
    }
    
    // Add effect to game state
    this.gameStore.addToGameLog(`Threat manifests: ${event.name} - ${event.description}`, true);
    
    // Apply immediate effects based on manifestation type
    switch (event.manifestation) {
      case ThreatManifestationType.HEALTH_LOSS:
        this.playerStore.takeDamage(event.strength);
        this.gameStore.addToGameLog(`You lose ${event.strength} health from the threat.`);
        break;
        
      case ThreatManifestationType.RESOURCE_LOSS:
        this.playerStore.loseRandomResources(event.strength);
        this.gameStore.addToGameLog(`You lose ${event.strength} random resources from the threat.`);
        break;
        
      case ThreatManifestationType.CHALLENGE_DIFFICULTY:
        // Add temporary effect to increase challenge difficulty
        this.gameStore.addTempEffect(
          'threat_challenge_difficulty',
          'Increased Challenge Difficulty',
          `Challenges are ${event.strength} points more difficult due to threat.`,
          event.strength,
          event.duration
        );
        break;
        
      case ThreatManifestationType.COMPANION_EFFECT:
        // Add temporary effect to reduce companion effectiveness
        this.gameStore.addTempEffect(
          'threat_companion_effect',
          'Companion Unrest',
          `Animal companions are less effective due to threat.`,
          event.strength,
          event.duration
        );
        break;
        
      case ThreatManifestationType.LANDSCAPE_EFFECT:
        // Add temporary effect to reduce resource gathering
        this.gameStore.addTempEffect(
          'threat_landscape_effect',
          'Landscape Disruption',
          `Resource gathering is reduced due to threat.`,
          event.strength,
          event.duration
        );
        break;
        
      case ThreatManifestationType.SEASONAL_SHIFT:
        // Add temporary effect to disrupt seasonal benefits
        this.gameStore.addTempEffect(
          'threat_seasonal_shift',
          'Seasonal Disruption',
          `Seasonal benefits are reduced due to threat.`,
          event.strength,
          event.duration
        );
        
        // Advance the season if this is a major event
        if (event.type === ThreatEventType.MAJOR) {
          this.gameStore.advanceSeason();
        }
        break;
    }
  }
  
  /**
   * Generate and apply a random threat manifestation based on current threat level
   * @returns The applied threat event, or null if none was applied
   */
  public manifestThreat(): ThreatEvent | null {
    // Check if player has threat prevention
    if (this.hasThreatPrevention()) {
      this.gameStore.addToGameLog('Your protective effects prevented a threat manifestation!', true);
      return null;
    }
    
    // Generate random event
    const event = this.generateRandomThreatEvent();
    
    // Apply the event if one was generated
    if (event) {
      this.applyThreatEvent(event);
      return event;
    }
    
    return null;
  }
  
  /**
   * Check if a threat manifestation should occur based on current threat level
   * Higher threat levels have higher chance of manifestation
   * @returns True if a manifestation should occur
   */
  public shouldManifestThreat(): boolean {
    const threatLevel = this.getThreatLevel();
    
    // No manifestations at threat level 0
    if (threatLevel === 0) {
      return false;
    }
    
    // Probability increases with threat level
    const manifestationChance = threatLevel * 0.15; // 15% per threat level
    return Math.random() < manifestationChance;
  }
  
  /**
   * Add a threat prevention effect to the player
   * @param duration Duration of the effect in turns
   * @param strength Strength of the effect (higher values prevent stronger threats)
   */
  public addThreatPreventionEffect(duration: number, strength: number = 1): void {
    const effect: PlayerEffect = {
      id: 'threat_prevention',
      name: 'Threat Prevention',
      description: 'Prevents threat manifestations from affecting you.',
      magnitude: strength,
      duration,
      type: 'protection',
      target: 'player'
    };
    
    this.playerStore.addEffect(effect);
    this.gameStore.addToGameLog(`You are now protected from threats for ${duration} turns.`, true);
  }
  
  /**
   * Process threat-related effects at the end of a turn
   * This includes checking for new manifestations and updating existing effects
   */
  public processThreatEffects(): void {
    // Reset threat reduction tracker for the new turn
    this.resetThreatReductionTracker();
    
    // Check if a new threat should manifest
    if (this.shouldManifestThreat()) {
      this.manifestThreat();
    }
    
    // Roll for otherworldly manifestation if threat is high
    if (this.gameStore.threatTokens >= 10) {
      this.rollForOtherworldlyManifestation();
    }
    
    // Process existing effects (already handled by game and player stores)
  }
  
  /**
   * Use a sacred site to reduce threat
   * @param landscapeId ID of the current landscape
   * @returns Number of threat tokens removed, or 0 if not a sacred site
   */
  public useSacredSiteForThreatReduction(landscapeId: string): number {
    if (landscapeId === this.SACRED_SITES.MOONLIT_LOCH) {
      // Moonlit Loch: Remove 1-3 tokens through purification ritual
      const reduction = Math.floor(Math.random() * 3) + 1; // 1-3 tokens
      this.gameStore.addToGameLog(`You performed a purification ritual at the Moonlit Loch, reducing threat by ${reduction}.`, true);
      return this.removeThreatTokens(reduction);
    } 
    else if (landscapeId === this.SACRED_SITES.DRUIDS_SANCTUARY) {
      // Druid's Sanctuary: Remove 2 tokens through meditation
      this.gameStore.addToGameLog('You meditated at the Druid\'s Sanctuary, reducing threat by 2.', true);
      return this.removeThreatTokens(2);
    }
    
    return 0;
  }
  
  /**
   * Use a resource to reduce or prevent threat
   * @param resourceId ID of the resource to use
   * @returns True if the resource was used successfully for threat reduction
   */
  public useResourceForThreatReduction(resourceId: string): boolean {
    const playerStore = usePlayerStore();
    
    if (resourceId === this.THREAT_RESOURCES.SACRED_WATER) {
      // Sacred Water: Remove 1 token when used
      if (this.removeThreatTokens(1) > 0) {
        playerStore.removeResource(resourceId);
        this.gameStore.addToGameLog('You used Sacred Water to purify and reduce threat by 1.', true);
        return true;
      }
    } 
    else if (resourceId === this.THREAT_RESOURCES.ROWAN_WOOD) {
      // Rowan Wood: Prevent 1 token accumulation when used
      playerStore.removeResource(resourceId);
      
      // Add a temporary effect to prevent the next threat token accumulation
      this.gameStore.addTempEffect(
        'threat_prevention_rowan',
        'Rowan Protection',
        'Protected from threat accumulation by Rowan Wood.',
        1,
        1
      );
      
      this.gameStore.addToGameLog('You used Rowan Wood to ward against the next threat accumulation.', true);
      return true;
    }
    
    return false;
  }
  
  /**
   * Perform a seasonal purification ritual
   * @returns Number of threat tokens removed
   */
  public performSeasonalPurificationRitual(): number {
    const gameStore = this.gameStore;
    const currentSeason = gameStore.currentSeason;
    
    // Check if ritual already performed this season
    if (this.hasPerformedSeasonalRitual) {
      gameStore.addToGameLog('You have already performed a purification ritual this season.', true);
      return 0;
    }
    
    // Different ritual effectiveness based on season
    let reduction = 1;
    let ritualName = '';
    
    switch (currentSeason) {
      case Season.IMBOLC:
        ritualName = 'Imbolc Purification';
        reduction = 3;
        break;
      case Season.BELTANE:
        ritualName = 'Spring Renewal Ritual';
        reduction = 2;
        break;
      case Season.LUGHNASADH:
        ritualName = 'Summer Solstice Ceremony';
        reduction = 3;
        break;
      case Season.SAMHAIN:
        ritualName = 'Autumn Harvest Offering';
        reduction = 2;
        break;
      case Season.WINTERS_DEPTH:
        ritualName = 'Winter Solstice Vigil';
        reduction = 1;
        break;
    }
    
    // Mark ritual as performed this season
    this.hasPerformedSeasonalRitual = true;
    
    gameStore.addToGameLog(`You performed the ${ritualName}, reducing threat by ${reduction}.`, true);
    return this.removeThreatTokens(reduction);
  }
  
  /**
   * Reset the seasonal ritual tracker when season changes
   */
  public resetSeasonalRitualTracker(): void {
    this.hasPerformedSeasonalRitual = false;
  }
  
  /** 
   * Roll for an otherworldly manifestation (when threat is high)
   * @returns The manifestation that occurred, or null if none
   */
  public rollForOtherworldlyManifestation(): any {
    if (this.gameStore.threatTokens < 10) {
      return null;
    }
    
    // Roll 1d8 for manifestation type
    const roll = Math.floor(Math.random() * 8) + 1;
    const manifestation = this.otherworldlyManifestations[roll - 1];
    
    this.gameStore.addToGameLog(`Otherworldly Manifestation: ${manifestation.name} - ${manifestation.description}`, true);
    
    // Apply the manifestation effects
    this.applyThreatEvent(manifestation);
    
    return manifestation;
  }
  
  /**
   * Check if the current landscape is a sacred site for threat reduction
   * @param landscapeId ID of the landscape to check
   * @returns True if the landscape is a sacred site
   */
  public isSacredSite(landscapeId: string): boolean {
    return landscapeId === this.SACRED_SITES.MOONLIT_LOCH || 
           landscapeId === this.SACRED_SITES.DRUIDS_SANCTUARY;
  }
  
  /**
   * Check if a resource can be used for threat reduction
   * @param resourceId ID of the resource to check
   * @returns True if the resource can reduce threat
   */
  public isResourceUsefulForThreat(resourceId: string): boolean {
    return resourceId === this.THREAT_RESOURCES.SACRED_WATER || 
           resourceId === this.THREAT_RESOURCES.ROWAN_WOOD;
  }
  
  /**
   * Get threat accumulation for crafting a powerful item
   * @param itemId ID of the crafted item
   * @returns Number of threat tokens to add (0 if none)
   */
  public getThreatForCraftedItem(itemId: string): number {
    const item = this.cardStore.getCraftedItemById(itemId);
    
    if (!item) return 0;
    
    // Default threat costs based on complexity
    if (item.complexity) {
      const complexityValue = typeof item.complexity === 'number' 
        ? item.complexity 
        : this.getComplexityValue(item.complexity);
        
      // Higher complexity means more threat
      if (complexityValue >= 4) {
        return 3; // LEGENDARY
      } else if (complexityValue >= 3) {
        return 2; // ADVANCED
      } else if (complexityValue >= 2) {
        return 1; // COMPLEX
      }
    }
    
    return 0;
  }
  
  /**
   * Get numeric value for complexity string
   * @param complexity Complexity as string
   * @returns Numeric value
   */
  private getComplexityValue(complexity: string): number {
    switch (complexity) {
      case 'LEGENDARY': return 4;
      case 'ADVANCED': return 3;
      case 'COMPLEX': return 2;
      case 'SIMPLE': 
      default: return 1;
    }
  }
  
  /**
   * Add threat for seasonal crossing
   * @returns Number of threat tokens added
   */
  public addThreatForSeasonalCrossing(): number {
    return this.addThreatTokens(2);
  }
  
  /**
   * Add threat for disrespecting a sacred site
   * @param landscapeId ID of the landscape
   * @param severity How severe the disrespect was (1-3)
   * @returns Number of threat tokens added
   */
  public addThreatForSacredSiteDisrespect(landscapeId: string, severity: number = 1): number {
    // Only add threat if it's a sacred site
    if (this.isSacredSite(landscapeId)) {
      // Ensure severity is within bounds
      const threatAmount = Math.max(1, Math.min(3, severity));
      this.gameStore.addToGameLog(`Your actions have disrespected a sacred site, increasing threat by ${threatAmount}.`, true);
      return this.addThreatTokens(threatAmount);
    }
    
    return 0;
  }
  
  /**
   * Process threat system on season change
   * @param oldSeason Previous season
   * @param newSeason Current season
   */
  public handleSeasonChange(oldSeason: Season, newSeason: Season): void {
    // Reset the seasonal ritual tracker
    this.resetSeasonalRitualTracker();
    
    // Add threat for seasonal crossing if player is unprepared
    const playerStore = this.playerStore;
    
    // Check if player has necessary preparation for the season
    let isPrepared = false;
    
    // Check for seasonal preparation items or effects
    if (newSeason === Season.WINTERS_DEPTH) {
      isPrepared = playerStore.resources.some(r => ['woven_reeds', 'forge_cinders'].includes(r));
    } else if (newSeason === Season.IMBOLC) {
      isPrepared = playerStore.resources.some(r => ['rowan_wood', 'silver_mistletoe'].includes(r));
    } else if (newSeason === Season.BELTANE) {
      isPrepared = playerStore.resources.some(r => ['oak_galls', 'amber_shards'].includes(r));
    } else if (newSeason === Season.LUGHNASADH) {
      isPrepared = playerStore.resources.some(r => ['sacred_water', 'horse_hair'].includes(r));
    } else if (newSeason === Season.SAMHAIN) {
      isPrepared = playerStore.resources.some(r => ['barrow_dust', 'ogham_sticks'].includes(r));
    }
    
    // Add threat if unprepared
    if (!isPrepared) {
      this.addThreatForSeasonalCrossing();
      this.gameStore.addToGameLog(`You were unprepared for the transition to ${newSeason}, increasing threat by 2.`, true);
    } else {
      this.gameStore.addToGameLog(`Your preparations have eased the transition to ${newSeason}.`, true);
    }
  }
  
  /**
   * Process threat system at the end of a turn
   * Handles threat accumulation, manifestations, and other threat-related effects
   */
  public processEndOfTurn(): void {
    // Process threat effects
    this.processThreatEffects();
    
    // Check current landscape for any threat-related effects
    const currentLandscapeId = this.gameStore.currentLandscapeId;
    if (this.isSacredSite(currentLandscapeId)) {
      this.gameStore.addToGameLog(`You are at a sacred site (${currentLandscapeId}). You may perform a ritual to reduce threat.`, false);
    }
    
    // Apply any pending threat effects from crafted items
    // This would be handled elsewhere when crafting occurs
  }
  
  /**
   * Integrate with the resource service to handle resource usage for threat reduction
   * @param resourceId ID of the resource to use
   * @returns True if the resource was used for threat reduction
   */
  public processResourceUse(resourceId: string): boolean {
    if (this.isResourceUsefulForThreat(resourceId)) {
      return this.useResourceForThreatReduction(resourceId);
    }
    return false;
  }
}

// Export singleton instance
export const threatService = new ThreatService();
</file>

<file path="src/services/victoryService.ts">
/**
 * Victory Service
 * Validates victory conditions based on game state
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { GamePhase } from '@/models/enums/phases';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';

class VictoryService {
  /**
   * Check all victory conditions
   * @returns Object with victory status and individual conditions
   */
  checkVictoryConditions(): {
    isVictory: boolean;
    conditions: {
      journeyCompleted: boolean;
      balanceMaintained: boolean;
      knowledgeAcquired: boolean;
      bondsFormed: boolean;
      questFulfilled: boolean;
      landscapesTraversed: boolean;
      seasonsExperienced: boolean;
      challengesOvercome: boolean;
    };
  } {
    const journeyCompleted = this.checkJourneyCompletion();
    const balanceMaintained = this.checkBalanceMaintained();
    const knowledgeAcquired = this.checkKnowledgeAcquired();
    const bondsFormed = this.checkBondsFormed();
    const questFulfilled = this.checkPersonalQuest();
    
    // Add the missing conditions
    const landscapesTraversed = this.checkLandscapesTraversed();
    const seasonsExperienced = this.checkSeasonsExperienced();
    const challengesOvercome = this.checkChallengesOvercome();
    
    const conditions = {
      journeyCompleted,
      balanceMaintained,
      knowledgeAcquired,
      bondsFormed,
      questFulfilled,
      landscapesTraversed,
      seasonsExperienced,
      challengesOvercome
    };
    
    const isVictory = Object.values(conditions).every(Boolean);
    
    // Update game state
    const gameStore = useGameStore() as any as ExtendedGameStore;
    gameStore.victoryConditions = conditions;
    
    return {
      isVictory,
      conditions
    };
  }
  
  /**
   * Check if journey is complete (all 15 landscapes visited)
   * @returns True if journey is complete
   */
  checkJourneyCompletion(): boolean {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    
    // Complete when all 15 landscapes have been visited
    return gameStore.visitedLandscapes.length >= 15;
  }
  
  /**
   * Check if balance is maintained (fewer than 6 threat tokens)
   * @returns True if balance is maintained
   */
  checkBalanceMaintained(): boolean {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    return gameStore.threatTokens < 6;
  }
  
  /**
   * Check if knowledge acquired (at least 2 crafted items)
   * @returns True if knowledge is acquired
   */
  checkKnowledgeAcquired(): boolean {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    return playerStore.craftedItems.length >= 2;
  }
  
  /**
   * Check if bonds formed (at least one animal companion)
   * @returns True if bonds are formed
   */
  checkBondsFormed(): boolean {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    // Fix: call the companionCount method instead of treating it as a property
    return playerStore.companionCount() >= 1;
  }
  
  /**
   * Check character-specific personal quest
   * @returns True if personal quest is fulfilled
   */
  checkPersonalQuest(): boolean {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    const cardStore = useCardStore();
    const gameStore = useGameStore() as any as ExtendedGameStore;
    
    const character = cardStore.getCharacterById(playerStore.characterId);
    if (!character) {
      return false;
    }
    
    // Since we don't have access to the actual properties needed,
    // we'll implement a simplified version based on the character's ID
    switch (character.id) {
      case 'giant_beastfriend':
        // Bond with at least 4 different Animal Companions
        // Using companionCount getter instead of animalCompanions array
        return playerStore.companionCount() >= 4;
        
      case 'hedge_witch':
        // Create at least 3 different Crafted Items
        // Using craftedItemCount getter instead of craftedItems array
        return playerStore.craftedItemCount >= 3;
        
      case 'iron_crafter':
        // Craft a Legendary Item
        // Since hasCraftedLegendaryItem doesn't exist, we'll assume this is based on having enough crafted items
        return playerStore.craftedItemCount >= 5;
        
      case 'druid_seer':
        // Complete 3 Ritual Sites
        // Since completedRitualSites doesn't exist, we'll assume this is based on visited landscapes
        return gameStore.visitedLandscapes.length >= 10;
        
      case 'celtic_warrior':
        // Defeat 5 Challenges with Strength
        // Since we don't have a way to track this, we'll assume this is based on visited landscapes
        return gameStore.visitedLandscapes.length >= 12;
        
      case 'forest_guardian':
        // Maintain perfect balance (0 threat tokens) for 5 consecutive turns
        // Since we can't track consecutive turns, we'll check if threat tokens are at 0
        return gameStore.threatTokens === 0;
        
      default:
        return false;
    }
  }
  
  /**
   * Check if landscapes traversed (at least 10 landscapes visited)
   * @returns True if landscapes traversed
   */
  checkLandscapesTraversed(): boolean {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    return gameStore.visitedLandscapes.length >= 10;
  }
  
  /**
   * Check if seasons experienced (at least 3 seasons experienced)
   * @returns True if seasons experienced
   */
  checkSeasonsExperienced(): boolean {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    // Since experiencedSeasons doesn't exist, we'll assume this is always true for now
    // In a real implementation, we would track the seasons experienced
    return true;
  }
  
  /**
   * Check if challenges overcome (at least 5 challenges overcome)
   * @returns True if challenges overcome
   */
  checkChallengesOvercome(): boolean {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    // Since overcomeChallenges doesn't exist, we'll assume this is always true for now
    // In a real implementation, we would track the challenges overcome
    return true;
  }
  
  /**
   * Process victory
   */
  processVictory(): void {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    
    // Use the endGame method instead of directly modifying state properties
    gameStore.endGame(true);
    
    // Add a victory message to the game log
    gameStore.addToGameLog('Victory! You have completed your journey through the Celtic Realm.', true);
  }
  
  /**
   * Process defeat
   * @param reason The reason for defeat
   */
  processDefeat(reason: string): void {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    
    // Use the endGame method instead of directly modifying state properties
    gameStore.endGame(false);
    
    // Add the defeat reason to the game log
    gameStore.addToGameLog(`Defeat: ${reason}`, true);
    
    // We can't set gameStats directly as it doesn't exist in the store
    // Instead, we'll log the stats to the game log
    gameStore.addToGameLog(`Game Stats - Turns: ${gameStore.currentTurn}, Threat: ${gameStore.threatTokens}, Season: ${gameStore.currentSeason}`, false);
  }
  
  /**
   * Check for defeat conditions
   * @returns Object with defeat status and reason
   */
  checkDefeatConditions(): {
    isDefeat: boolean;
    reason: string | null;
  } {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    
    // Check health
    if (playerStore.health <= 0) {
      return {
        isDefeat: true,
        reason: 'Your journey has ended as your health has fallen to zero.'
      };
    }
    
    // Check threat level
    if (gameStore.threatTokens >= 15) {
      return {
        isDefeat: true,
        reason: 'The otherworldly forces have overwhelmed you as threat tokens reached 15.'
      };
    }
    
    // Check if exceeded maximum turns
    if (gameStore.currentTurn >= 30) {
      return {
        isDefeat: true,
        reason: 'Your journey has taken too long, and winter has claimed you.'
      };
    }
    
    return {
      isDefeat: false,
      reason: null
    };
  }
}

export const victoryService = new VictoryService();
</file>

<file path="src/shims-vue.d.ts">
/* eslint-disable */
declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}
</file>

<file path="src/stores/index.ts">
import { useGameStore } from './gameStore';
import { usePlayerStore } from './playerStore';
import { useCardStore } from './cardStore';
import { useSeasonStore } from './seasonStore';
import { useJourneyStore } from './journeyStore';
import { useChallenge } from './challengeStore';
import { useLogStore } from './logStore';

export {
  useGameStore,
  usePlayerStore,
  useCardStore,
  useSeasonStore,
  useJourneyStore,
  useChallenge,
  useLogStore
};
</file>

<file path="src/types/companions.d.ts">
// Type definitions for animal companions
declare module '@/models/data/companions' {
  export interface AnimalCompanion {
    id: string;
    name: string;
    ability: string;
    abilityDescription: string;
    preferredResources: string[];
    seasonalAffinity: string[];
    image: string;
    findLocation: string;
    abilityFunction: (gameState: any, ...args: any[]) => any;
  }

  const companions: AnimalCompanion[];
  export default companions;
}
</file>

<file path="src/utils/typeMapping.ts">
import { ChallengeType } from '@/models/enums/cardTypes';

/**
 * Maps legacy challenge type strings from data files to ChallengeType enum values
 * This helps ensure consistent lookup across the application
 */
export const challengeTypeMapping: Record<string, ChallengeType> = {
  // Map from data file values to enum values
  'mental': ChallengeType.WISDOM,
  'spiritual': ChallengeType.SURVIVAL,
  'knowledge': ChallengeType.WISDOM,
  'physical': ChallengeType.STRENGTH,
  'social': ChallengeType.DIPLOMACY,
  'wilderness': ChallengeType.SURVIVAL,
  'agility': ChallengeType.AGILITY,
  'strength': ChallengeType.STRENGTH,
  'diplomacy': ChallengeType.DIPLOMACY,
  'survival': ChallengeType.SURVIVAL,
  'wisdom': ChallengeType.WISDOM,
  
  // Also include direct mappings for case-insensitive lookups
  'WISDOM': ChallengeType.WISDOM,
  'STRENGTH': ChallengeType.STRENGTH,
  'AGILITY': ChallengeType.AGILITY,
  'DIPLOMACY': ChallengeType.DIPLOMACY,
  'SURVIVAL': ChallengeType.SURVIVAL
};

/**
 * Safely gets the standardized ChallengeType from any challenge type string
 * @param challengeType The challenge type string from data files or other sources
 * @returns The corresponding ChallengeType enum value or WISDOM as fallback
 */
export function getStandardizedChallengeType(challengeType: string): ChallengeType {
  if (!challengeType) {
    console.warn('Missing challenge type, defaulting to WISDOM');
    return ChallengeType.WISDOM;
  }
  
  const standardType = challengeTypeMapping[challengeType];
  
  if (!standardType) {
    console.warn(`Unknown challenge type: ${challengeType}, defaulting to WISDOM`);
    return ChallengeType.WISDOM;
  }
  
  return standardType;
}

/**
 * Helper function to check if an ability matches a challenge type
 * Considers different ability structures and handles type inconsistencies
 */
export function abilityMatchesChallenge(ability: any, challengeType: string | ChallengeType): boolean {
  if (!ability) return false;
  
  // Standardize the challenge type
  const standardChallengeType = typeof challengeType === 'string' 
    ? getStandardizedChallengeType(challengeType)
    : challengeType;
  
  // Try different ways to match the ability to the challenge type
  return (
    // Check if ability has a type property that matches directly
    (ability.type && getStandardizedChallengeType(ability.type) === standardChallengeType) ||
    // Check if ability has a type property in the more free-form structure
    (ability.type && ability.type.toUpperCase() === standardChallengeType) ||
    // Check if ability name includes the challenge type string
    (ability.name && typeof ability.name === 'string' && 
     ability.name.toUpperCase().includes(standardChallengeType.toString()))
  );
}
</file>

<file path="tests/unit/TurnSequenceSeasonalTransition.spec.ts">
import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useGameStore } from '../../src/stores/gameStore';
import { usePlayerStore } from '../../src/stores/playerStore';
import { useCardStore } from '../../src/stores/cardStore';
import { GamePhase } from '../../src/models/enums/phases';
import { Season } from '../../src/models/enums/seasons';
import { CompanionState } from '../../src/models/types/player';

/**
 * Test suite for seasonal transitions during game progression
 * 
 * This test verifies how the game handles seasonal transitions and applies seasonal effects,
 * specifically transitioning from Samhain to Winter's Depth when reaching the appropriate
 * landscape in the journey, and how this affects:
 * - Resource availability
 * - Challenge difficulties
 * - Companion effectiveness
 * - Character abilities
 */
describe('Turn Sequence - Seasonal Transitions', () => {
  // Setup stores before each test
  beforeEach(() => {
    setActivePinia(createPinia());
    
    // Mock any randomized functions to ensure predictable outcomes
    vi.spyOn(Math, 'random').mockReturnValue(0.5);
    
    // Reset game state
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    
    gameStore.resetGame();
    playerStore.resetPlayer();
    gameStore.startGame();
    
    // Ensure we start from a consistent game state
    gameStore.setPhase(GamePhase.SEASONAL_ASSESSMENT);
  });
  
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should handle seasonal transitions and apply seasonal effects correctly', async () => {
    const gameStore = useGameStore();
    const playerStore = usePlayerStore();
    const cardStore = useCardStore();
    
    // Setup initial game state
    gameStore.resetGame();
    playerStore.resetPlayer();
    gameStore.startGame();
    playerStore.selectCharacter('giant_beastfriend');
    
    // Set up for testing seasonal transition
    // We're at the end of Samhain (landscapes 1-3)
    gameStore.setCurrentLandscape('sacred_oak_grove'); // Moving to landscape 4
    gameStore.setCurrentChallenge('wild_beasts');
    gameStore.advanceJourney(3); // Set journey progress to 3
    
    // Add some resources to test seasonal effects
    playerStore.addResource('barrow_dust'); // Abundant in Samhain
    playerStore.addResource('standing_stone_chips'); // Abundant in Samhain
    playerStore.addResource('woven_reeds'); // Scarce in Samhain
    
    // Add an animal companion affected by seasons
    playerStore.addAnimalCompanion('raven_scout');
    
    // Start at seasonal assessment phase
    gameStore.setPhase(GamePhase.SEASONAL_ASSESSMENT);
    
    // 1. PHASE: SEASONAL ASSESSMENT - Test seasonal transition
    // ------------------------------------------
    expect(gameStore.currentPhase).toBe(GamePhase.SEASONAL_ASSESSMENT);
    expect(gameStore.currentSeason).toBe(Season.SAMHAIN);
    
    // Mock the seasonal transition by directly calling advanceSeason
    // In a real game, this would happen based on journey progress
    gameStore.advanceSeason();
    
    // Verify season has changed to Winter's Depth (landscapes 4-6)
    expect(gameStore.currentSeason).toBe(Season.WINTERS_DEPTH);
    
    // Apply seasonal effects
    gameStore.updateResourceAvailability();
    
    // Verify seasonal effects on resources
    // Forge Cinders and Bog Iron should now be abundant
    // Sacred Water and Horse Hair should now be scarce
    
    // Add resources that are abundant in Winter's Depth to test
    const forgeAddResult = playerStore.addResource('forge_cinders');
    const ironAddResult = playerStore.addResource('bog_iron');
    
    expect(forgeAddResult).toBe(true);
    expect(ironAddResult).toBe(true);
    
    // Advance to next phase
    gameStore.advancePhase();
    
    // 2. PHASE: THREAT LEVEL CHECK
    // ------------------------------------------
    expect(gameStore.currentPhase).toBe(GamePhase.THREAT_LEVEL_CHECK);
    
    // Advance to challenge resolution
    gameStore.advancePhase();
    
    // Skip LANDSCAPE_CHALLENGE phase if it exists in the sequence
    if (gameStore.currentPhase === GamePhase.LANDSCAPE_CHALLENGE) {
      gameStore.advancePhase();
    }
    
    // 3. PHASE: CHALLENGE RESOLUTION - Test seasonal challenge modifiers
    // ------------------------------------------
    expect(gameStore.currentPhase).toBe(GamePhase.CHALLENGE_RESOLUTION);
    
    // In Winter's Depth, physical challenges are harder (+2 difficulty)
    // wild_beasts is a physical challenge
    
    // Mock challenge resolution parameters
    const baseDifficulty = 5; // Assuming base difficulty for wild_beasts
    const seasonalModifier = 2; // Winter's Depth makes physical challenges harder (+2)
    const threatModifier = 0; // Assuming no threat tokens
    
    // Calculate expected total difficulty
    const totalDifficulty = baseDifficulty + seasonalModifier + threatModifier;
    expect(totalDifficulty).toBe(7); // 5 base + 2 seasonal + 0 threat
    
    // Mock a successful roll (8 is always a success regardless of modifiers)
    const mockDieRoll = 8; // Natural 8
    const playerBonus = 0; // Assuming no bonuses
    
    // In Winter's Depth, there's a benefit: +1 to wisdom challenges
    // But wild_beasts is a physical challenge, so no benefit applies
    
    // Determine outcome based on roll vs difficulty
    let outcome;
    if (mockDieRoll === 8 || mockDieRoll + playerBonus >= totalDifficulty) {
      outcome = 'SUCCESS';
    } else if (mockDieRoll + playerBonus === totalDifficulty - 1) {
      outcome = 'PARTIAL';
    } else {
      outcome = 'FAILURE';
    }
    
    // With a natural 8, it should be a success regardless of difficulty
    expect(outcome).toBe('SUCCESS');
    
    // On success, gain resources from the current landscape
    // Sacred Oak Grove offers resources like Rowan Wood
    
    // Ensure we have capacity for resources
    // Reset resources first to ensure we have space
    playerStore.resources = [];
    playerStore.resourceCapacity = 5; // Make sure we have enough capacity
    
    // Add resources
    const addResult1 = playerStore.addResource('rowan_wood');
    const addResult2 = playerStore.addResource('rowan_wood');
    
    expect(addResult1).toBe(true);
    expect(addResult2).toBe(true);
    expect(playerStore.resources.includes('rowan_wood')).toBe(true);
    
    // Advance to next phase
    gameStore.advancePhase();
    
    // 4. PHASE: RESOURCE MANAGEMENT - Test seasonal resource effects
    // ------------------------------------------
    expect(gameStore.currentPhase).toBe(GamePhase.RESOURCE_MANAGEMENT);
    
    // In Winter's Depth, Forge Cinders and Bog Iron are abundant
    // This would affect resource gathering probabilities in the actual game
    // We've already verified that we have added these resources earlier
    
    // Verify that we can access our added resources
    expect(playerStore.resources.length).toBeGreaterThan(0);
    expect(playerStore.resources).toContain('rowan_wood');
    
    // Advance to next phase
    gameStore.advancePhase();
    
    // 5. PHASE: ANIMAL COMPANION - Test seasonal animal affinities
    // ------------------------------------------
    expect(gameStore.currentPhase).toBe(GamePhase.ANIMAL_COMPANION);
    
    // In Winter's Depth, certain companions have affinity
    // Just verify the phase transition for this test
    
    // Advance to next phase
    gameStore.advancePhase();
    
    // Additional phases would follow but we've tested what we need for seasonal transitions
    
    // Final verification - season should still be Winter's Depth after these phases
    expect(gameStore.currentSeason).toBe(Season.WINTERS_DEPTH);
  });
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "strict": false,
    "jsx": "preserve",
    "moduleResolution": "node",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "useDefineForClassFields": true,
    "sourceMap": true,
    "baseUrl": ".",
    "types": ["vitest/globals"],
    "paths": {
      "@/*": ["src/*"]
    },
    "lib": ["esnext", "dom", "dom.iterable", "scripthost"],
    "noEmitOnError": false,
    "noImplicitAny": false,
    "allowJs": true,
    "checkJs": false
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.tsx",
    "src/**/*.vue",
    "tests/**/*.ts",
    "tests/**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import path from 'path';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
  },
});
</file>

<file path="vue.config.js">
const { defineConfig } = require('@vue/cli-service')

module.exports = defineConfig({
  transpileDependencies: true,
  lintOnSave: false,
  configureWebpack: {
    entry: {
      app: './src/main.ts'
    }
  },
  chainWebpack: config => {
    // Disable eslint
    config.plugins.delete('eslint');
    
    // Disable TypeScript type checking
    config.module
      .rule('ts')
      .use('ts-loader')
      .tap(options => {
        options = options || {};
        options.transpileOnly = true;
        return options;
      });
  }
})
</file>

<file path="package.json">
{
  "name": "pathfinders-journey",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build --no-type-check",
    "lint": "vue-cli-service lint",
    "test:unit": "vitest run",
    "test:e2e": "cypress open"
  },
  "dependencies": {
    "core-js": "^3.8.3",
    "pinia": "^2.1.7",
    "sass": "^1.70.0",
    "vue": "^3.4.15",
    "vue-router": "^4.2.5"
  },
  "devDependencies": {
    "@babel/core": "^7.12.16",
    "@babel/eslint-parser": "^7.12.16",
    "@types/vue-router": "^2.0.0",
    "@vitejs/plugin-vue": "^5.2.1",
    "@vue/cli-plugin-babel": "~5.0.0",
    "@vue/cli-plugin-eslint": "~5.0.0",
    "@vue/cli-plugin-typescript": "^5.0.8",
    "@vue/cli-service": "~5.0.0",
    "@vue/runtime-dom": "^3.4.15",
    "@vue/test-utils": "^2.4.3",
    "cypress": "^13.6.3",
    "eslint": "^7.32.0",
    "eslint-plugin-vue": "^8.0.3",
    "jsdom": "^26.0.0",
    "sass-loader": "^14.0.0",
    "ts-loader": "^9.5.2",
    "typescript": "^5.8.2",
    "vitest": "^1.6.1"
  },
  "eslintConfig": {
    "root": true,
    "env": {
      "node": true
    },
    "extends": [
      "plugin:vue/vue3-essential",
      "eslint:recommended"
    ],
    "parserOptions": {
      "parser": "@babel/eslint-parser"
    },
    "rules": {}
  },
  "browserslist": [
    "> 1%",
    "last 2 versions",
    "not dead",
    "not ie 11"
  ]
}
</file>

<file path="README.md">
# PathfindersJourney
  All Claude Sonnet 3.7 Generated via Windsurf Ai. Primary rule of development thall shal not code line by line.
</file>

<file path="src/assets/scss/_variables.scss">
// Color Palette
$primary-color: #2c5530;  // Forest green
$secondary-color: #8b4513;  // Saddle brown
$accent-color: #9c7c38;  // Celtic gold
$light-color: #f5f0e1;  // Parchment
$dark-color: #2b2b2b;  // Almost black

// Season Colors
$samhain-color: #4a235a;  // Deep purple
$winter-color: #1b4f72;  // Deep blue
$imbolc-color: #117a65;  // Emerald green
$beltane-color: #b9770e;  // Golden amber
$lughnasadh-color: #b03a2e;  // Rusty red

// Challenge Type Colors
$physical-color: #c0392b;  // Crimson
$mental-color: #2980b9;  // Blue
$social-color: #f39c12;  // Orange
$spiritual-color: #8e44ad;  // Purple

// Card Type Colors
$landscape-color: #27ae60;  // Green
$animal-companion-color: #d35400;  // Burnt orange
$resource-color: #f1c40f;  // Yellow
$crafted-item-color: #7f8c8d;  // Silver
$character-color: #3498db;  // Blue

// Status Colors
$success-color: #2ecc71;  // Green
$warning-color: #f39c12;  // Orange
$danger-color: #e74c3c;  // Red
$info-color: #3498db;  // Blue

// Border Colors
$border-color: rgba(0, 0, 0, 0.2);  // Light gray for borders

// Typography
$font-family-base: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
$font-family-display: 'Cinzel', serif;
$font-family-handwritten: 'Tangerine', cursive;

$font-size-base: 16px;
$font-size-xs: 12px;
$font-size-sm: 14px;
$font-size-md: 16px;
$font-size-lg: 18px;
$font-size-xl: 24px;
$font-size-xxl: 32px;

// Spacing
$spacing-xs: 4px;
$spacing-sm: 8px;
$spacing-md: 16px;
$spacing-lg: 24px;
$spacing-xl: 32px;
$spacing-xxl: 48px;

// Border Radius
$border-radius-sm: 4px;
$border-radius-md: 8px;
$border-radius-lg: 12px;
$border-radius-xl: 16px;
$border-radius-circle: 50%;

// Box Shadow
$shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.1);
$shadow-md: 0 4px 8px rgba(0, 0, 0, 0.12);
$shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.15);
$shadow-xl: 0 12px 24px rgba(0, 0, 0, 0.2);

// Transitions
$transition-fast: 150ms ease-in-out;
$transition-normal: 250ms ease-in-out;
$transition-slow: 350ms ease-in-out;

// Z-index
$z-index-dropdown: 1000;
$z-index-sticky: 1020;
$z-index-fixed: 1030;
$z-index-modal-backdrop: 1040;
$z-index-modal: 1050;
$z-index-popover: 1060;
$z-index-tooltip: 1070;

// Game-specific
$card-width: 180px;
$card-height: 250px;
$card-width-sm: 140px;
$card-height-sm: 200px;

// Breakpoints
$breakpoint-sm: 576px;
$breakpoint-md: 768px;
$breakpoint-lg: 992px;
$breakpoint-xl: 1200px;
</file>

<file path="src/assets/scss/main.scss">
// Import all partials
@import 'variables';
@import 'typography';
@import 'animations';

// Base Styles
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  background-color: $light-color;
  color: $dark-color;
  font-family: $font-family-base;
  font-size: $font-size-base;
  line-height: 1.5;
  min-height: 100vh;
  overflow-x: hidden;
}

// Game Container
.game-container {
  max-width: 1200px;
  margin: 0 auto;
  padding: $spacing-lg;
  
  @media (max-width: $breakpoint-md) {
    padding: $spacing-md;
  }
}

// Game Header
.game-header {
  text-align: center;
  margin-bottom: $spacing-xl;
  padding: $spacing-md;
  border-bottom: 2px solid $accent-color;
}

// Game Card
.game-card {
  background-color: white;
  border-radius: $border-radius-md;
  box-shadow: $shadow-md;
  overflow: hidden;
  transition: transform $transition-normal, box-shadow $transition-normal;
  margin-bottom: $spacing-md;
  
  &:hover {
    transform: translateY(-5px);
    box-shadow: $shadow-lg;
  }
  
  &__header {
    padding: $spacing-md;
    background-color: $primary-color;
    color: white;
  }
  
  &__body {
    padding: $spacing-md;
  }
  
  &__footer {
    padding: $spacing-md;
    border-top: 1px solid rgba(0, 0, 0, 0.1);
    background-color: rgba(0, 0, 0, 0.02);
  }
  
  // Card Types
  &--landscape {
    border-left: 5px solid $landscape-color;
  }
  
  &--animal-companion {
    border-left: 5px solid $animal-companion-color;
  }
  
  &--resource {
    border-left: 5px solid $resource-color;
  }
  
  &--crafted-item {
    border-left: 5px solid $crafted-item-color;
  }
  
  &--character {
    border-left: 5px solid $character-color;
  }
  
  &--season {
    &.samhain {
      border-left: 5px solid $samhain-color;
    }
    
    &.winter {
      border-left: 5px solid $winter-color;
    }
    
    &.imbolc {
      border-left: 5px solid $imbolc-color;
    }
    
    &.beltane {
      border-left: 5px solid $beltane-color;
    }
    
    &.lughnasadh {
      border-left: 5px solid $lughnasadh-color;
    }
  }
}

// Button Styles
.btn {
  display: inline-block;
  font-weight: 600;
  text-align: center;
  white-space: nowrap;
  vertical-align: middle;
  user-select: none;
  border: 1px solid transparent;
  padding: $spacing-sm $spacing-md;
  font-size: $font-size-base;
  line-height: 1.5;
  border-radius: $border-radius-md;
  transition: all $transition-fast;
  cursor: pointer;
  
  &:focus, &:hover {
    text-decoration: none;
    outline: 0;
  }
  
  &:disabled {
    opacity: 0.65;
    cursor: not-allowed;
  }
  
  &--primary {
    background-color: $primary-color;
    color: white;
    
    &:hover, &:focus {
      background-color: darken($primary-color, 10%);
    }
  }
  
  &--secondary {
    background-color: $secondary-color;
    color: white;
    
    &:hover, &:focus {
      background-color: darken($secondary-color, 10%);
    }
  }
  
  &--accent {
    background-color: $accent-color;
    color: white;
    
    &:hover, &:focus {
      background-color: darken($accent-color, 10%);
    }
  }
  
  &--success {
    background-color: $success-color;
    color: white;
    
    &:hover, &:focus {
      background-color: darken($success-color, 10%);
    }
  }
  
  &--danger {
    background-color: $danger-color;
    color: white;
    
    &:hover, &:focus {
      background-color: darken($danger-color, 10%);
    }
  }
  
  &--outline {
    background-color: transparent;
    
    &.btn--primary {
      border-color: $primary-color;
      color: $primary-color;
      
      &:hover, &:focus {
        background-color: $primary-color;
        color: white;
      }
    }
    
    &.btn--secondary {
      border-color: $secondary-color;
      color: $secondary-color;
      
      &:hover, &:focus {
        background-color: $secondary-color;
        color: white;
      }
    }
    
    &.btn--accent {
      border-color: $accent-color;
      color: $accent-color;
      
      &:hover, &:focus {
        background-color: $accent-color;
        color: white;
      }
    }
  }
  
  &--lg {
    padding: $spacing-md $spacing-lg;
    font-size: $font-size-lg;
  }
  
  &--sm {
    padding: $spacing-xs $spacing-sm;
    font-size: $font-size-sm;
  }
}

// Game Board
.game-board {
  display: grid;
  grid-template-columns: 1fr 3fr;
  grid-gap: $spacing-lg;
  
  @media (max-width: $breakpoint-lg) {
    grid-template-columns: 1fr;
  }
}

// Player Dashboard
.player-dashboard {
  background-color: white;
  border-radius: $border-radius-md;
  box-shadow: $shadow-md;
  padding: $spacing-md;
  
  &__header {
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: $spacing-md;
    padding-bottom: $spacing-md;
  }
  
  &__stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-gap: $spacing-sm;
    margin-bottom: $spacing-md;
  }
  
  &__inventory {
    margin-top: $spacing-lg;
  }
}

// Game Play Area
.game-play-area {
  background-color: white;
  border-radius: $border-radius-md;
  box-shadow: $shadow-md;
  padding: $spacing-md;
  
  &__landscape {
    margin-bottom: $spacing-lg;
  }
  
  &__actions {
    display: flex;
    flex-wrap: wrap;
    gap: $spacing-sm;
    margin-bottom: $spacing-lg;
  }
  
  &__log {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: $border-radius-sm;
    padding: $spacing-sm;
    background-color: rgba(0, 0, 0, 0.02);
  }
}

// Character Selection
.character-selection {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  grid-gap: $spacing-lg;
  margin-bottom: $spacing-xl;
  
  &__option {
    cursor: pointer;
    border: 2px solid transparent;
    border-radius: $border-radius-md;
    padding: $spacing-md;
    transition: all $transition-normal;
    
    &:hover {
      transform: translateY(-5px);
      box-shadow: $shadow-md;
    }
    
    &.selected {
      border-color: $accent-color;
      background-color: rgba($accent-color, 0.1);
    }
  }
}

// Resource List
.resource-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  grid-gap: $spacing-sm;
  margin-bottom: $spacing-md;
  
  &__item {
    background-color: rgba($resource-color, 0.1);
    border: 1px solid rgba($resource-color, 0.3);
    border-radius: $border-radius-sm;
    padding: $spacing-sm;
    text-align: center;
    font-size: $font-size-sm;
  }
}

// Companion List
.companion-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  grid-gap: $spacing-sm;
  margin-bottom: $spacing-md;
  
  &__item {
    background-color: rgba($animal-companion-color, 0.1);
    border: 1px solid rgba($animal-companion-color, 0.3);
    border-radius: $border-radius-sm;
    padding: $spacing-sm;
    
    &.wary {
      opacity: 0.6;
    }
  }
}

// Crafted Items List
.crafted-items-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  grid-gap: $spacing-sm;
  margin-bottom: $spacing-md;
  
  &__item {
    background-color: rgba($crafted-item-color, 0.1);
    border: 1px solid rgba($crafted-item-color, 0.3);
    border-radius: $border-radius-sm;
    padding: $spacing-sm;
  }
}

// Journey Progress
.journey-progress {
  margin: $spacing-lg 0;
  
  &__track {
    height: 10px;
    background-color: rgba(0, 0, 0, 0.1);
    border-radius: $border-radius-circle;
    overflow: hidden;
  }
  
  &__fill {
    height: 100%;
    background-color: $primary-color;
    border-radius: $border-radius-circle;
    transition: width $transition-normal;
  }
  
  &__markers {
    display: flex;
    justify-content: space-between;
    margin-top: $spacing-xs;
  }
  
  &__marker {
    width: 15px;
    height: 15px;
    border-radius: $border-radius-circle;
    background-color: rgba(0, 0, 0, 0.1);
    
    &.visited {
      background-color: $primary-color;
    }
    
    &.current {
      background-color: $accent-color;
      transform: scale(1.2);
    }
  }
}

// Seasonal Wheel
.seasonal-wheel {
  position: relative;
  width: 200px;
  height: 200px;
  margin: $spacing-lg auto;
  
  &__circle {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: conic-gradient(
      $samhain-color 0% 20%,
      $winter-color 20% 40%,
      $imbolc-color 40% 60%,
      $beltane-color 60% 80%,
      $lughnasadh-color 80% 100%
    );
    transform: rotate(0deg);
    transition: transform $transition-slow;
  }
  
  &__marker {
    position: absolute;
    top: -10px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 15px solid $accent-color;
  }
  
  &__labels {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    
    span {
      position: absolute;
      font-size: $font-size-sm;
      font-weight: 600;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      
      &:nth-child(1) {
        top: 15%;
        left: 50%;
        transform: translateX(-50%);
      }
      
      &:nth-child(2) {
        top: 50%;
        left: 15%;
        transform: translateY(-50%);
      }
      
      &:nth-child(3) {
        bottom: 15%;
        left: 50%;
        transform: translateX(-50%);
      }
      
      &:nth-child(4) {
        top: 50%;
        right: 15%;
        transform: translateY(-50%);
      }
      
      &:nth-child(5) {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
    }
  }
}

// Game Over Screen
.game-over {
  text-align: center;
  padding: $spacing-xl;
  
  &--victory {
    color: $success-color;
  }
  
  &--defeat {
    color: $danger-color;
  }
  
  &__title {
    font-size: $font-size-xxl;
    margin-bottom: $spacing-lg;
  }
  
  &__stats {
    display: inline-block;
    margin: $spacing-lg auto;
    text-align: left;
  }
  
  &__actions {
    margin-top: $spacing-xl;
  }
}

// Debug Component Outlines
.debug-component {
  border: 2px solid rgba(173, 216, 230, 0.3) !important;
  position: relative !important;
  background-color: transparent !important;
  
  &::before {
    content: attr(data-component-name);
    position: absolute;
    top: -20px;
    left: 0;
    background-color: rgba(173, 216, 230, 0.5);
    padding: 2px 6px;
    font-size: 12px;
    color: #333;
    z-index: 1070;
    pointer-events: none;
  }
}

// Utility Classes
.mt-1 { margin-top: $spacing-xs; }
.mt-2 { margin-top: $spacing-sm; }
.mt-3 { margin-top: $spacing-md; }
.mt-4 { margin-top: $spacing-lg; }
.mt-5 { margin-top: $spacing-xl; }

.mb-1 { margin-bottom: $spacing-xs; }
.mb-2 { margin-bottom: $spacing-sm; }
.mb-3 { margin-bottom: $spacing-md; }
.mb-4 { margin-bottom: $spacing-lg; }
.mb-5 { margin-bottom: $spacing-xl; }

.ml-1 { margin-left: $spacing-xs; }
.ml-2 { margin-left: $spacing-sm; }
.ml-3 { margin-left: $spacing-md; }
.ml-4 { margin-left: $spacing-lg; }
.ml-5 { margin-left: $spacing-xl; }

.mr-1 { margin-right: $spacing-xs; }
.mr-2 { margin-right: $spacing-sm; }
.mr-3 { margin-right: $spacing-md; }
.mr-4 { margin-right: $spacing-lg; }
.mr-5 { margin-right: $spacing-xl; }

.p-1 { padding: $spacing-xs; }
.p-2 { padding: $spacing-sm; }
.p-3 { padding: $spacing-md; }
.p-4 { padding: $spacing-lg; }
.p-5 { padding: $spacing-xl; }

.d-flex { display: flex; }
.flex-column { flex-direction: column; }
.justify-content-center { justify-content: center; }
.align-items-center { align-items: center; }
.flex-wrap { flex-wrap: wrap; }
.flex-grow-1 { flex-grow: 1; }

.text-center { text-align: center; }
.text-right { text-align: right; }
.text-left { text-align: left; }

.w-100 { width: 100%; }
.h-100 { height: 100%; }

.rounded { border-radius: $border-radius-md; }
.shadow { box-shadow: $shadow-md; }
.shadow-lg { box-shadow: $shadow-lg; }
</file>

<file path="src/main.ts">
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router/index'

// Create the app instance
const app = createApp(App)

// Use Pinia for state management
app.use(createPinia())

// Use Vue Router
app.use(router)

// Set up global error handler
app.config.errorHandler = (err, instance, info) => {
  console.error('Global error:', err)
  console.error('Error info:', info)
}

// Mount the app
app.mount('#app')
</file>

<file path="src/models/data/seasons.d.ts">
// Type definitions for seasons.js
import { SeasonCard } from '@/models/types/cards';

export const seasons: SeasonCard[];
</file>

<file path="src/models/enums/cardTypes.ts">
export enum CardType {
  CHARACTER = 'CHARACTER',
  LANDSCAPE = 'LANDSCAPE',
  ANIMAL_COMPANION = 'ANIMAL_COMPANION',
  RESOURCE = 'RESOURCE',
  CRAFTED_ITEM = 'CRAFTED_ITEM',
  SEASON = 'SEASON',
  ACTION = 'ACTION'
}

export enum ChallengeType {
  STRENGTH = 'STRENGTH',
  WISDOM = 'WISDOM',
  AGILITY = 'AGILITY',
  DIPLOMACY = 'DIPLOMACY',
  SURVIVAL = 'SURVIVAL'
}
</file>

<file path="src/models/enums/phases.ts">
export enum GamePhase {
  SETUP = 'SETUP',
  CHARACTER_SELECTION = 'CHARACTER_SELECTION',
  SEASONAL_ASSESSMENT = 'SEASONAL_ASSESSMENT',
  THREAT_LEVEL_CHECK = 'THREAT_LEVEL_CHECK',
  LANDSCAPE_CHALLENGE = 'LANDSCAPE_CHALLENGE',
  CHALLENGE_RESOLUTION = 'CHALLENGE_RESOLUTION',
  RESOURCE_MANAGEMENT = 'RESOURCE_MANAGEMENT',
  ANIMAL_COMPANION = 'ANIMAL_COMPANION',
  CRAFTING = 'CRAFTING',
  JOURNEY_PROGRESSION = 'JOURNEY_PROGRESSION',
  EXPLORATION = 'EXPLORATION',
  GAME_OVER = 'GAME_OVER'
}
</file>

<file path="src/models/types/player.ts">
import { PlayerAction } from '@/models/enums/actions';

export interface PlayerEffect {
  id: string;
  name: string;
  description: string;
  duration: number;
  magnitude: number;
  type: string;
  target: string;
}

export enum CompanionState {
  LOYAL = 'LOYAL',
  WARY = 'WARY',
  LEAVING = 'LEAVING'
}

export interface CompanionStatus {
  loyalty: number;
  state: CompanionState;
  turnsSinceLastFed: number;
  turnsWary: number;
}

export interface PlayerState {
  characterId: string;
  health: number;
  maxHealth: number;
  resources: string[];
  resourceCapacity: number;
  animalCompanions: string[];
  craftedItems: string[];
  experience: number;
  knowledgeDiscovered: string[];
  specialAbilityUsed: boolean;
  activeEffects: PlayerEffect[];
  hasCraftedLegendaryItem: boolean;
  uniqueCraftedItemsCount: number;
  companionLoyalty: { [companionId: string]: CompanionStatus };
  wisdom: number;
}

export interface PlayerActionResult {
  success: boolean;
  message: string;
  type: PlayerAction;
  data?: any;
}
</file>

<file path="src/router/index.ts">
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';

// Import views
import GameSetupView from '@/views/GameSetupView.vue';
import GameBoardView from '@/views/GameBoardView.vue';

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    name: 'setup',
    component: GameSetupView
  },
  {
    path: '/game',
    name: 'game',
    component: GameBoardView
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

// Add a flag for tracking page refreshes
let isInitialPageLoad = true;

// Add sessionStorage to track page refresh
router.beforeEach((to, from, next) => {
  // Set a random key in sessionStorage
  const randomKey = 'pathfinder_session_' + Math.random().toString(36).substring(2, 15);
  
  // On initial page load (or after refresh), isInitialPageLoad will be true
  if (isInitialPageLoad) {
    isInitialPageLoad = false;
    
    // If we're not already going to the setup page, redirect there
    if (to.path !== '/') {
      return next({ path: '/' });
    }
  }
  
  next();
});

export default router;
</file>

<file path="src/services/CardRepository.ts">
import { 
  CharacterCard, 
  LandscapeCard, 
  ResourceCard, 
  AnimalCompanionCard, 
  CraftedItemCard, 
  SeasonCard,
  ChallengeCard
} from '@/models/types/cards';
import { CardType, ChallengeType } from '@/models/enums/cardTypes';
import { Season } from '@/models/enums/seasons';
import { getStandardizedChallengeType } from '@/utils/typeMapping';

// Import the data from models/data directory
import characters from '@/models/data/characters';
import landscapes from '@/models/data/landscapes';
import resources from '@/models/data/resources';
import companions from '@/models/data/companions';
import craftedItems from '@/models/data/crafted-items';
import { seasons } from '@/models/data/seasons';

/**
 * Repository for managing all card data in the game
 * Responsible for loading, validating, and providing access to card data
 */
export class CardRepository {
  private _characters: CharacterCard[];
  private _landscapes: LandscapeCard[];
  private _resources: ResourceCard[];
  private _animalCompanions: AnimalCompanionCard[];
  private _craftedItems: CraftedItemCard[];
  private _seasons: SeasonCard[];

  constructor() {
    this._characters = this._initializeCharacters();
    this._landscapes = this._initializeLandscapes();
    this._resources = this._initializeResources();
    this._animalCompanions = this._initializeAnimalCompanions();
    this._craftedItems = this._initializeCraftedItems();
    this._seasons = this._initializeSeasons();
  }

  /**
   * Generic base mapper function that handles common card properties
   * @param sourceData The source data object
   * @param cardType The type of card being created
   * @param defaultImage Default image to use if none is provided
   * @returns Base card object with common properties
   */
  private _createBaseCard<T>(sourceData: any, cardType: CardType, defaultImage: string): T {
    return {
      id: sourceData.id,
      name: sourceData.name,
      description: sourceData.description || '',
      type: cardType,
      image: sourceData.image || defaultImage
    } as unknown as T;
  }

  /**
   * Initialize character cards from raw data
   * @returns Array of processed character cards
   */
  private _initializeCharacters(): CharacterCard[] {
    return characters.map(char => ({
      ...this._createBaseCard<CharacterCard>(char, CardType.CHARACTER, 'default_character.jpg'),
      healthPoints: char.healthPoints || 0,
      strength: char.strength || 0,
      wisdom: char.wisdom || 0,
      agility: char.agility || 0,
      diplomacy: char.diplomacy || 0,
      survival: char.survival || 0,
      resourceCapacity: char.resourceCapacity || 5,
      specialAbility: {
        name: char.specialAbility?.name || '',
        description: char.specialAbility?.description || ''
      },
      startingResources: char.startingResources || [],
      startingCompanion: char.startingCompanion,
      startingCompanions: char.startingCompanions
    }));
  }

  /**
   * Initialize landscape cards from raw data
   * @returns Array of processed landscape cards
   */
  private _initializeLandscapes(): LandscapeCard[] {
    return landscapes.map(land => ({
      ...this._createBaseCard<LandscapeCard>(land, CardType.LANDSCAPE, 'default_landscape.jpg'),
      challenge: land.challenge || '',
      challengeType: land.challengeType || '',
      difficulty: land.difficulty || 0,
      challenges: land.challenges ? land.challenges.map(challenge => ({
        type: challenge.type || '',
        difficulty: challenge.difficulty || 0
      })) : [],
      availableResources: land.availableResources || [],
      specialFeature: land.specialFeature,
      animalCompanions: land.animalCompanions,
      providesShelter: land.providesShelter,
      entryEffect: land.entryEffect,
      craftingBonuses: land.craftingBonuses,
      hasCraftingFacilities: land.hasCraftingFacilities
    }));
  }

  /**
   * Initialize resource cards from raw data
   * @returns Array of processed resource cards
   */
  private _initializeResources(): ResourceCard[] {
    return resources.map(res => ({
      ...this._createBaseCard<ResourceCard>(res, CardType.RESOURCE, 'default_resource.jpg'),
      resourceType: res.type || '',
      effect: {
        name: res.effect?.name || '',
        description: res.effect?.description || ''
      },
      season: res.season || '',
      rarity: res.rarity || 'common',
      seasonalAbundance: res.seasonalAbundance || [],
      specialEffect: res.specialEffect
    }));
  }

  /**
   * Initialize animal companion cards from raw data
   * @returns Array of processed animal companion cards
   */
  private _initializeAnimalCompanions(): AnimalCompanionCard[] {
    return companions.map(comp => ({
      ...this._createBaseCard<AnimalCompanionCard>(comp, CardType.ANIMAL_COMPANION, 'default_companion.jpg'),
      ability: {
        name: comp.ability?.name || '',
        description: comp.ability?.description || ''
      },
      affinitySeasons: comp.affinitySeasons || [],
      preferredResources: comp.preferredResources || [],
      challengeBonuses: comp.challengeBonuses,
      seasonalBonuses: comp.seasonalBonuses,
      bondingEffect: comp.bondingEffect,
      loyaltyEffects: comp.loyaltyEffects
    }));
  }

  /**
   * Initialize crafted item cards from raw data
   * @returns Array of processed crafted item cards
   */
  private _initializeCraftedItems(): CraftedItemCard[] {
    return craftedItems.map(item => ({
      ...this._createBaseCard<CraftedItemCard>(item, CardType.CRAFTED_ITEM, 'default_crafted_item.jpg'),
      requiredResources: item.requiredResources || [],
      complexity: item.complexity || 1,
      ability: {
        name: item.ability?.name || '',
        description: item.ability?.description || '',
        type: item.ability?.type
      },
      drawback: item.drawback,
      isLegendary: item.isLegendary,
      challengeBonuses: item.challengeBonuses
    }));
  }

  /**
   * Initialize season cards from raw data and convert string season IDs to enum values
   * @returns Array of processed season cards
   */
  private _initializeSeasons(): SeasonCard[] {
    return seasons.map(season => {
      // Convert string season id to Season enum value
      const seasonEnum = this._mapSeasonStringToEnum(season.id);
      
      return {
        ...this._createBaseCard<SeasonCard>(season, CardType.SEASON, 'default_season.jpg'),
        effect: season.effect || '',
        benefit: season.benefit || '',
        season: seasonEnum,
        resourceAbundance: season.resourceAbundance || [],
        resourceScarcity: season.resourceScarcity || [],
        animalAffinity: season.animalAffinity || [],
        abundantResources: season.resourceAbundance || [],
        scarceResources: season.resourceScarcity || [],
        animalAffinities: season.animalAffinity || [],
        effects: season.effects || [],
        modifiers: season.modifiers || { spiritual: 0, physical: 0, mental: 0, social: 0 },
        quest: season.quest
      };
    });
  }

  /**
   * Helper function to convert season string ID to Season enum
   * @param seasonId The string ID of the season
   * @returns The corresponding Season enum value
   */
  private _mapSeasonStringToEnum(seasonId: string): Season {
    switch(seasonId) {
      case 'samhain':
        return Season.SAMHAIN;
      case 'wintersDepth':
        return Season.WINTERS_DEPTH;
      case 'imbolc':
        return Season.IMBOLC;
      case 'beltane':
        return Season.BELTANE;
      case 'lughnasadh':
        return Season.LUGHNASADH;
      default:
        console.warn(`Unknown season id: ${seasonId}, defaulting to Samhain`);
        return Season.SAMHAIN;
    }
  }

  /**
   * Factory method to create a card of the specified type
   * @param type The type of card to create
   * @param data Raw data for the card
   * @returns The created card
   */
  public createCard<T>(type: CardType, data: any): T {
    switch (type) {
      case CardType.CHARACTER:
        return this._createCharacterCard(data) as unknown as T;
      case CardType.LANDSCAPE:
        return this._createLandscapeCard(data) as unknown as T;
      case CardType.RESOURCE:
        return this._createResourceCard(data) as unknown as T;
      case CardType.ANIMAL_COMPANION:
        return this._createAnimalCompanionCard(data) as unknown as T;
      case CardType.CRAFTED_ITEM:
        return this._createCraftedItemCard(data) as unknown as T;
      case CardType.SEASON:
        return this._createSeasonCard(data) as unknown as T;
      default:
        throw new Error(`Unsupported card type: ${type}`);
    }
  }

  /**
   * Factory method for creating a character card
   * @param data Raw character data
   * @returns Processed character card
   */
  private _createCharacterCard(data: any): CharacterCard {
    return {
      ...this._createBaseCard<CharacterCard>(data, CardType.CHARACTER, 'default_character.jpg'),
      healthPoints: data.healthPoints || 0,
      strength: data.strength || 0,
      wisdom: data.wisdom || 0,
      agility: data.agility || 0,
      diplomacy: data.diplomacy || 0,
      survival: data.survival || 0,
      resourceCapacity: data.resourceCapacity || 5,
      specialAbility: {
        name: data.specialAbility?.name || '',
        description: data.specialAbility?.description || ''
      },
      startingResources: data.startingResources || [],
      startingCompanion: data.startingCompanion,
      startingCompanions: data.startingCompanions
    };
  }

  /**
   * Factory method for creating a landscape card
   * @param data Raw landscape data
   * @returns Processed landscape card
   */
  private _createLandscapeCard(data: any): LandscapeCard {
    return {
      ...this._createBaseCard<LandscapeCard>(data, CardType.LANDSCAPE, 'default_landscape.jpg'),
      challenge: data.challenge || '',
      challengeType: data.challengeType || '',
      difficulty: data.difficulty || 0,
      challenges: data.challenges ? data.challenges.map(challenge => ({
        type: challenge.type || '',
        difficulty: challenge.difficulty || 0
      })) : [],
      availableResources: data.availableResources || [],
      specialFeature: data.specialFeature,
      animalCompanions: data.animalCompanions,
      providesShelter: data.providesShelter,
      entryEffect: data.entryEffect,
      craftingBonuses: data.craftingBonuses,
      hasCraftingFacilities: data.hasCraftingFacilities
    };
  }

  /**
   * Factory method for creating a resource card
   * @param data Raw resource data
   * @returns Processed resource card
   */
  private _createResourceCard(data: any): ResourceCard {
    return {
      ...this._createBaseCard<ResourceCard>(data, CardType.RESOURCE, 'default_resource.jpg'),
      resourceType: data.type || '',
      effect: {
        name: data.effect?.name || '',
        description: data.effect?.description || ''
      },
      season: data.season || '',
      rarity: data.rarity || 'common',
      seasonalAbundance: data.seasonalAbundance || [],
      specialEffect: data.specialEffect
    };
  }

  /**
   * Factory method for creating an animal companion card
   * @param data Raw animal companion data
   * @returns Processed animal companion card
   */
  private _createAnimalCompanionCard(data: any): AnimalCompanionCard {
    return {
      ...this._createBaseCard<AnimalCompanionCard>(data, CardType.ANIMAL_COMPANION, 'default_companion.jpg'),
      ability: {
        name: data.ability?.name || '',
        description: data.ability?.description || ''
      },
      affinitySeasons: data.affinitySeasons || [],
      preferredResources: data.preferredResources || [],
      challengeBonuses: data.challengeBonuses,
      seasonalBonuses: data.seasonalBonuses,
      bondingEffect: data.bondingEffect,
      loyaltyEffects: data.loyaltyEffects
    };
  }

  /**
   * Factory method for creating a crafted item card
   * @param data Raw crafted item data
   * @returns Processed crafted item card
   */
  private _createCraftedItemCard(data: any): CraftedItemCard {
    return {
      ...this._createBaseCard<CraftedItemCard>(data, CardType.CRAFTED_ITEM, 'default_crafted_item.jpg'),
      requiredResources: data.requiredResources || [],
      complexity: data.complexity || 1,
      ability: {
        name: data.ability?.name || '',
        description: data.ability?.description || '',
        type: data.ability?.type
      },
      drawback: data.drawback,
      isLegendary: data.isLegendary,
      challengeBonuses: data.challengeBonuses
    };
  }

  /**
   * Factory method for creating a season card
   * @param data Raw season data
   * @returns Processed season card
   */
  private _createSeasonCard(data: any): SeasonCard {
    const seasonEnum = this._mapSeasonStringToEnum(data.id);
    
    return {
      ...this._createBaseCard<SeasonCard>(data, CardType.SEASON, 'default_season.jpg'),
      effect: data.effect || '',
      benefit: data.benefit || '',
      season: seasonEnum,
      resourceAbundance: data.resourceAbundance || [],
      resourceScarcity: data.resourceScarcity || [],
      animalAffinity: data.animalAffinity || [],
      abundantResources: data.resourceAbundance || [],
      scarceResources: data.resourceScarcity || [],
      animalAffinities: data.animalAffinity || [],
      effects: data.effects || [],
      modifiers: data.modifiers || { spiritual: 0, physical: 0, mental: 0, social: 0 },
      quest: data.quest
    };
  }

  /**
   * Gets all character cards
   */
  public get characters(): CharacterCard[] {
    return this._characters;
  }

  /**
   * Gets all landscape cards
   */
  public get landscapes(): LandscapeCard[] {
    return this._landscapes;
  }

  /**
   * Gets all animal companion cards
   */
  public get animalCompanions(): AnimalCompanionCard[] {
    return this._animalCompanions;
  }

  /**
   * Gets all resource cards
   */
  public get resources(): ResourceCard[] {
    return this._resources;
  }

  /**
   * Gets all crafted item cards
   */
  public get craftedItems(): CraftedItemCard[] {
    return this._craftedItems;
  }

  /**
   * Gets all season cards
   */
  public get seasons(): SeasonCard[] {
    return this._seasons;
  }

  /**
   * Gets resources that are abundant in a specific season
   * @param season The season to check for abundance
   * @returns Array of resources abundant in the given season
   */
  public getResourcesBySeason(season: Season): ResourceCard[] {
    return this._resources.filter(resource => 
      resource.seasonalAbundance.includes(season)
    );
  }

  /**
   * Gets animal companions with affinity for a specific season
   * @param season The season to check for affinity
   * @returns Array of animal companions with affinity for the given season
   */
  public getCompanionsBySeason(season: Season): AnimalCompanionCard[] {
    return this._animalCompanions.filter(companion => 
      companion.affinitySeasons.includes(season)
    );
  }

  /**
   * Gets a challenge by ID
   * @param id The ID of the challenge to find
   * @returns The challenge card or undefined if not found
   */
  public getChallengeById(id: string): ChallengeCard | undefined {
    const allChallenges = this._landscapes.reduce((challenges, landscape) => {
      // Convert single challenge to a challenge card format for compatibility
      const landscapeChallenge = {
        id: `${landscape.id}_${landscape.challengeType?.toLowerCase() || 'challenge'}`,
        name: `${landscape.name} ${landscape.challenge || 'Challenge'}`,
        description: `A ${landscape.challengeType || 'unknown'} challenge at ${landscape.name}`,
        type: landscape.challengeType as ChallengeType || ChallengeType.WISDOM,
        difficulty: landscape.difficulty || 5,
        rewards: {
          resources: [],
          experience: 10,
          knowledge: landscape.id
        }
      };
      return [...challenges, landscapeChallenge];
    }, [] as ChallengeCard[]);
    
    return allChallenges.find(challenge => challenge.id === id);
  }

  /**
   * Gets all character cards
   * @returns Array of all character cards
   */
  public getAllCharacters(): CharacterCard[] {
    return this._characters;
  }

  /**
   * Gets a specific character by ID
   * @param id The ID of the character to find
   * @returns The character card or undefined if not found
   */
  public getCharacterById(id: string): CharacterCard | undefined {
    return this._characters.find(character => character.id === id);
  }

  /**
   * Gets the health points of a specific character
   * @param id The ID of the character
   * @returns The character's health points or 0 if character not found
   */
  public getCharacterHealth(id: string): number {
    const character = this.getCharacterById(id);
    return character ? character.healthPoints : 0;
  }

  /**
   * Gets all landscape cards
   * @returns Array of all landscape cards
   */
  public getAllLandscapes(): LandscapeCard[] {
    return this._landscapes;
  }

  /**
   * Gets a specific landscape by ID
   * @param id The ID of the landscape to find
   * @returns The landscape card or undefined if not found
   */
  public getLandscapeById(id: string): LandscapeCard | undefined {
    return this._landscapes.find(landscape => landscape.id === id);
  }

  /**
   * Gets all resource cards
   * @returns Array of all resource cards
   */
  public getAllResources(): ResourceCard[] {
    return this._resources;
  }

  /**
   * Gets a specific resource by ID
   * @param id The ID of the resource to find
   * @returns The resource card or undefined if not found
   */
  public getResourceById(id: string): ResourceCard | undefined {
    return this._resources.find(resource => resource.id === id);
  }

  /**
   * Gets resources that are abundant in a specific season
   * @param season The season to check for abundance
   * @returns Array of resources abundant in the given season
   */
  public getResourcesBySeasonalAbundance(season: string): ResourceCard[] {
    return this._resources.filter(resource => 
      resource.seasonalAbundance.includes(season as any)
    );
  }

  /**
   * Gets all animal companion cards
   * @returns Array of all animal companion cards
   */
  public getAllAnimalCompanions(): AnimalCompanionCard[] {
    return this._animalCompanions;
  }

  /**
   * Gets a specific animal companion by ID
   * @param id The ID of the animal companion to find
   * @returns The animal companion card or undefined if not found
   */
  public getAnimalCompanionById(id: string): AnimalCompanionCard | undefined {
    return this._animalCompanions.find(companion => companion.id === id);
  }

  /**
   * Gets animal companions with affinity for a specific season
   * @param season The season to check for affinity
   * @returns Array of animal companions with affinity for the given season
   */
  public getAnimalCompanionsBySeasonAffinity(season: string): AnimalCompanionCard[] {
    return this._animalCompanions.filter(companion => 
      companion.affinitySeasons.includes(season as any)
    );
  }

  /**
   * Gets all crafted item cards
   * @returns Array of all crafted item cards
   */
  public getAllCraftedItems(): CraftedItemCard[] {
    return this._craftedItems;
  }

  /**
   * Gets a specific crafted item by ID
   * @param id The ID of the crafted item to find
   * @returns The crafted item card or undefined if not found
   */
  public getCraftedItemById(id: string): CraftedItemCard | undefined {
    return this._craftedItems.find(item => item.id === id);
  }

  /**
   * Gets all season cards
   * @returns Array of all season cards
   */
  public getAllSeasons(): SeasonCard[] {
    return this._seasons;
  }

  /**
   * Gets a specific season by ID
   * @param id The ID of the season to find
   * @returns The season card or undefined if not found
   */
  public getSeasonById(id: string): SeasonCard | undefined {
    return this._seasons.find(season => season.id === id);
  }

  /**
   * Gets all season cards (alias for getAllSeasons)
   * @returns Array of all season cards
   */
  public getSeasons(): SeasonCard[] {
    return this._seasons;
  }

  /**
   * Gets cards of a specific type
   * @param type The card type to filter by
   * @returns Array of cards of the specified type
   */
  public getCardsByType(type: CardType): any[] {
    switch (type) {
      case CardType.CHARACTER:
        return this._characters;
      case CardType.LANDSCAPE:
        return this._landscapes;
      case CardType.RESOURCE:
        return this._resources;
      case CardType.ANIMAL_COMPANION:
        return this._animalCompanions;
      case CardType.CRAFTED_ITEM:
        return this._craftedItems;
      case CardType.SEASON:
        return this._seasons;
      default:
        return [];
    }
  }

  /**
   * Validates that all data references across the game are valid
   * Returns array of error messages if any issues are found
   * @returns Array of error messages, empty if no issues found
   */
  public validateReferentialIntegrity(): string[] {
    const errors: string[] = [];

    // Validate crafted items have valid resources
    this._craftedItems.forEach(item => {
      if (item.requiredResources) {
        item.requiredResources.forEach(resourceId => {
          const resource = this.getResourceById(resourceId);
          if (!resource) {
            errors.push(`Crafted item ${item.name} (${item.id}) requires resource ${resourceId} which doesn't exist`);
          }
        });
      }
    });

    // Validate landscapes have valid challenge types
    this._landscapes.forEach(landscape => {
      if (landscape.challenges && landscape.challenges.length > 0) {
        landscape.challenges.forEach(challenge => {
          try {
            // Verify challenge type is standardized
            getStandardizedChallengeType(challenge.type);
          } catch (error) {
            errors.push(`Landscape ${landscape.name} (${landscape.id}) has invalid challenge type: ${challenge.type}`);
          }
        });
      }
      
      // Validate landscape companions
      if (landscape.animalCompanions) {
        landscape.animalCompanions.forEach(companionId => {
          const companion = this.getAnimalCompanionById(companionId);
          if (!companion) {
            errors.push(`Landscape ${landscape.name} (${landscape.id}) references companion ${companionId} which doesn't exist`);
          }
        });
      }
      
      // Validate landscape available resources
      if (landscape.availableResources) {
        landscape.availableResources.forEach(resourceId => {
          const resource = this.getResourceById(resourceId);
          if (!resource) {
            errors.push(`Landscape ${landscape.name} (${landscape.id}) offers resource ${resourceId} which doesn't exist`);
          }
        });
      }
    });

    // Validate seasons have valid resource/companion references
    this._seasons.forEach(season => {
      // Validate season ID matches enum values
      const matchesEnumValue = Object.values(Season).some(
        enumValue => enumValue === season.id
      );
      
      if (!matchesEnumValue) {
        errors.push(`Season ${season.name} (${season.id}) doesn't match any Season enum value - expected format like 'samhain' or 'wintersDepth'`);
      }
      
      // Check resource abundance references
      if (season.resourceAbundance) {
        season.resourceAbundance.forEach(resourceId => {
          const resource = this.getResourceById(resourceId);
          if (!resource) {
            errors.push(`Season ${season.name} (${season.id}) lists abundant resource ${resourceId} which doesn't exist`);
          }
        });
      }
      
      // Check resource scarcity references
      if (season.resourceScarcity) {
        season.resourceScarcity.forEach(resourceId => {
          const resource = this.getResourceById(resourceId);
          if (!resource) {
            errors.push(`Season ${season.name} (${season.id}) lists scarce resource ${resourceId} which doesn't exist`);
          }
        });
      }
      
      // Check animal affinity references
      if (season.animalAffinity) {
        season.animalAffinity.forEach(companionId => {
          const companion = this.getAnimalCompanionById(companionId);
          if (!companion) {
            errors.push(`Season ${season.name} (${season.id}) has affinity for companion ${companionId} which doesn't exist`);
          }
        });
      }
    });

    // Validate characters have valid starting resources and companions
    this._characters.forEach(character => {
      if (character.startingResources) {
        character.startingResources.forEach(resourceId => {
          const resource = this.getResourceById(resourceId);
          if (!resource) {
            errors.push(`Character ${character.name} (${character.id}) starts with resource ${resourceId} which doesn't exist`);
          }
        });
      }
      
      if (character.startingCompanions) {
        character.startingCompanions.forEach(companionId => {
          const companion = this.getAnimalCompanionById(companionId);
          if (!companion) {
            errors.push(`Character ${character.name} (${character.id}) starts with companion ${companionId} which doesn't exist`);
          }
        });
      }
    });

    // Validate animal companions have valid resource preferences
    this._animalCompanions.forEach(companion => {
      if (companion.preferredResources) {
        companion.preferredResources.forEach(resourceId => {
          const resource = this.getResourceById(resourceId);
          if (!resource) {
            errors.push(`Animal companion ${companion.name} (${companion.id}) prefers resource ${resourceId} which doesn't exist`);
          }
        });
      }
      
      // Check companion affinity seasons match enum values
      if (companion.affinitySeasons) {
        companion.affinitySeasons.forEach(seasonVal => {
          if (!Object.values(Season).includes(seasonVal as Season)) {
            errors.push(`Animal companion ${companion.name} (${companion.id}) has invalid season affinity: ${seasonVal}`);
          }
        });
      }
    });

    return errors;
  }

  /**
   * Resets the repository state
   * Reloads all card data from source
   */
  public reset(): void {
    this._characters = this._initializeCharacters();
    this._landscapes = this._initializeLandscapes();
    this._resources = this._initializeResources();
    this._animalCompanions = this._initializeAnimalCompanions();
    this._craftedItems = this._initializeCraftedItems();
    this._seasons = this._initializeSeasons();
  }
}

// Export a singleton instance for use throughout the application
export const cardRepository = new CardRepository();
</file>

<file path="src/services/journeyService.ts">
/**
 * Journey Service
 * Handles journey path initialization and landscape navigation
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { Season } from '@/models/enums/seasons';
import { LandscapeCard } from '@/models/types/cards';
import { useJourneyStore } from '@/stores/journeyStore';
import { useLogStore } from '@/stores/logStore';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';

class JourneyService {
  /**
   * Initialize journey path with landscapes
   * @returns Array of landscape IDs representing the journey path
   */
  initializeJourney(): string[] {
    const cardStore = useCardStore();
    const allLandscapes = cardStore.landscapes;
    
    // Ensure we have enough landscapes
    if (!allLandscapes || allLandscapes.length < 15) {
      console.error('Not enough landscapes to create journey path');
      return [];
    }
    
    // Shuffle landscapes to create a random path
    const shuffled = [...allLandscapes].sort(() => 0.5 - Math.random());
    
    // Select 15 landscapes for the journey
    const selectedLandscapes = shuffled.slice(0, 15);
    
    // Get landscape IDs for the path
    const journeyPath = selectedLandscapes.map(landscape => landscape.id);
    
    // Update game store
    const gameStore = useGameStore() as any as ExtendedGameStore;
    gameStore.journeyPath = journeyPath;
    
    // Set initial landscape
    if (journeyPath.length > 0) {
      gameStore.currentLandscapeId = journeyPath[0];
      gameStore.visitedLandscapes = [journeyPath[0]];
      
      // Log journey start
      gameStore.addToGameLog(`Your journey begins at ${this.getLandscapeName(journeyPath[0])}`);
    }
    
    return journeyPath;
  }
  
  /**
   * Get the name of a landscape by its ID
   * @param landscapeId The ID of the landscape
   * @returns The name of the landscape
   */
  getLandscapeName(landscapeId: string): string {
    const cardStore = useCardStore();
    const landscape = cardStore.getLandscapeById(landscapeId);
    return landscape?.name || 'Unknown Location';
  }
  
  /**
   * Move to the next landscape in the journey path
   * @returns The ID of the new current landscape
   */
  moveToNextLandscape(): string | null {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const journeyStore = useJourneyStore();
    
    // Get current position in journey
    const currentIndex = gameStore.journeyPath.indexOf(gameStore.currentLandscapeId);
    const nextIndex = currentIndex + 1;
    
    // Check if we're at the end of the journey
    if (nextIndex >= gameStore.journeyPath.length) {
      console.log('Reached the end of the journey path');
      return null;
    }
    
    // Get the next landscape ID
    const nextLandscapeId = gameStore.journeyPath[nextIndex];
    
    // Update game state
    gameStore.currentLandscapeId = nextLandscapeId;
    
    // Add to visited landscapes if not already visited
    if (!gameStore.visitedLandscapes.includes(nextLandscapeId)) {
      gameStore.visitedLandscapes.push(nextLandscapeId);
      // Apply effects when entering a new landscape
      this.applyLandscapeEntryEffects(nextLandscapeId);
    }
    
    return nextLandscapeId;
  }
  
  /**
   * Start a new turn and handles all turn-related updates
   * @returns The ID of the new current landscape
   */
  startNewTurn(): string | null {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    
    // Move to the next landscape
    const newLandscapeId = this.moveToNextLandscape();
    
    // Reset per-turn player actions
    playerStore.hasResourceForagingAction = true;
    playerStore.hasPerformedCrafting = false;
    
    // Increment turn counter
    gameStore.currentTurn++;
    
    return newLandscapeId;
  }
  
  /**
   * Get the ID of the next landscape in the journey path
   * @returns The ID of the next landscape or null if at the end
   */
  getNextLandscapeId(): string | null {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const journeyStore = useJourneyStore();
    
    // Get current position in journey
    const currentIndex = gameStore.journeyPath.indexOf(gameStore.currentLandscapeId);
    const nextIndex = currentIndex + 1;
    
    // Check if we're at the end of the journey
    if (nextIndex >= gameStore.journeyPath.length) {
      return null;
    }
    
    return gameStore.journeyPath[nextIndex];
  }
  
  /**
   * Check if the current location provides shelter
   * @param gameStore The game store instance
   * @returns True if the current location provides shelter
   */
  isCurrentLocationShelter(gameStore = useGameStore() as any as ExtendedGameStore): boolean {
    const cardStore = useCardStore();
    const landscape = cardStore.getLandscapeById(gameStore.currentLandscapeId);
    
    return landscape?.providesShelter || false;
  }
  
  /**
   * Get available landscape options to move to
   * @returns Array of available landscape IDs to move to
   */
  getAvailableMovementOptions(): string[] {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const journeyStore = useJourneyStore();
    
    // Get current position in journey
    const currentIndex = gameStore.journeyPath.indexOf(gameStore.currentLandscapeId);
    
    // Only allow forward movement in this implementation
    const result = [];
    if (currentIndex + 1 < gameStore.journeyPath.length) {
      result.push(gameStore.journeyPath[currentIndex + 1]);
    }
    
    return result;
  }
  
  /**
   * Get the next landscape object in the journey path
   * @returns The next landscape object or null if at the end
   */
  getNextLandscape(): LandscapeCard | null {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const cardStore = useCardStore();
    const journeyStore = useJourneyStore();
    
    const nextLandscapeId = this.getNextLandscapeId();
    if (!nextLandscapeId) {
      return null;
    }
    
    return cardStore.getLandscapeById(nextLandscapeId);
  }
  
  /**
   * Get the current landscape object
   * @returns The current landscape object
   */
  getCurrentLandscape(): LandscapeCard | null {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const cardStore = useCardStore();
    
    return cardStore.getLandscapeById(gameStore.currentLandscapeId);
  }
  
  /**
   * Apply effects when entering a new landscape
   */
  private applyLandscapeEntryEffects(landscapeId: string): void {
    const cardStore = useCardStore();
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const logStore = useLogStore();
    const landscape = cardStore.getLandscapeById(landscapeId);
    
    if (!landscape) {
      return;
    }
    
    // Log entry to new landscape
    gameStore.addToGameLog(`You have arrived at ${landscape.name}`);
    
    // Apply landscape effects
    if (landscape.difficulty > 0) {
      // Dangerous landscapes add threat tokens based on difficulty
      const threatTokens = Math.min(landscape.difficulty, 3);
      gameStore.addThreatTokens(threatTokens);
      gameStore.addToGameLog(`The danger of this area adds ${threatTokens} threat token(s)`);
    }
    
    // Apply landscape challenge if it has one
    if (landscape.challengeType) {
      gameStore.addToGameLog(`This area presents a ${landscape.challengeType} challenge`);
      
      // Set the challenge in the game state
      // Use a dummy challenge ID based on landscape for now
      const challengeId = `${landscape.id}_challenge`;
      gameStore.setCurrentChallenge(challengeId);
    }
    
    // Apply landscape special effects
    if (landscape.specialFeature) {
      gameStore.addTempEffect(
        landscape.specialFeature.name, 
        landscape.specialFeature.description,
        landscape.specialFeature.effect,
        1
      );
      gameStore.addToGameLog(`The landscape applies ${landscape.specialFeature.name}`);
    }
    
    // Apply entry effects if defined
    if (landscape.entryEffect) {
      gameStore.addToGameLog(`Entry Effect: ${landscape.entryEffect.description}`);
    }
  }
  
  /**
   * Advance to the next season in the seasonal cycle
   * @returns The new current season
   */
  advanceToNextSeason(): Season {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    
    // Use the proper Season enum values
    const seasons = [Season.SAMHAIN, Season.WINTERS_DEPTH, Season.IMBOLC, Season.BELTANE, Season.LUGHNASADH];
    
    // Find current season index
    const currentIndex = seasons.indexOf(gameStore.currentSeason);
    const nextIndex = (currentIndex + 1) % seasons.length;
    
    // Set the new season
    const newSeason = seasons[nextIndex];
    gameStore.currentSeason = newSeason;
    
    // Apply effects for the seasonal transition
    this.applySeasonalTransitionEffects(newSeason);
    
    // Log season change
    gameStore.addToGameLog(`The season has changed to ${this.getSeasonName(newSeason)}`);
    
    return newSeason;
  }
  
  /**
   * Apply effects when transitioning to a new season
   * @param season The new season
   */
  private applySeasonalTransitionEffects(season: Season): void {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const logStore = useLogStore();
    const cardStore = useCardStore();
    
    // Different seasons have different effects
    switch (season) {
      case Season.WINTERS_DEPTH:
        // Winter is harsh, add threat tokens
        gameStore.addThreatTokens(2);
        gameStore.addToGameLog('The harsh winter adds 2 threat tokens');
        break;
      case Season.IMBOLC:
        // Early spring brings hope, no effect
        break;
      case Season.BELTANE:
        // Summer is bountiful, no threat
        break;
      case Season.LUGHNASADH:
        // Harvest time, no effect
        break;
      case Season.SAMHAIN:
        // The veil thins, add threat
        gameStore.addThreatTokens(1);
        gameStore.addToGameLog('The thinning veil adds 1 threat token');
        break;
    }
  }
  
  /**
   * Get the name of a season
   * @param season The season enum value
   * @returns The display name of the season
   */
  getSeasonName(season: Season): string {
    switch (season) {
      case Season.WINTERS_DEPTH:
        return "Winter's Depth";
      case Season.IMBOLC:
        return "Imbolc";
      case Season.BELTANE:
        return "Beltane";
      case Season.LUGHNASADH:
        return "Lughnasadh";
      case Season.SAMHAIN:
        return "Samhain";
      default:
        return "Unknown Season";
    }
  }
}

export const journeyService = new JourneyService();
</file>

<file path="src/services/resourceService.ts">
/**
 * Resource Service
 * Handles resource collection and management
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { Season } from '@/models/enums/seasons';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';

class ResourceService {
  /**
   * Check if player can collect a resource
   * @param resourceId The ID of the resource to collect
   * @returns True if the resource can be collected
   */
  canCollectResource(resourceId: string): boolean {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    
    // Check capacity limits
    if (playerStore.isResourceCapacityReached) {
      return false;
    }
    
    return true;
  }
  
  /**
   * Collect a specific resource
   * @param resourceId The ID of the resource to collect
   * @returns True if the resource was collected successfully
   */
  collectResource(resourceId: string): boolean {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    const cardStore = useCardStore();
    
    if (!this.canCollectResource(resourceId)) {
      return false;
    }
    
    // Get resource card
    const resource = cardStore.getResourceById(resourceId);
    if (!resource) {
      return false;
    }
    
    // Add to player resources
    playerStore.addResource(resourceId);
    return true;
  }
  
  /**
   * Collect random resources from current landscape
   * @param count Number of resources to collect
   * @returns Array of collected resource IDs
   */
  collectLandscapeResources(count: number): string[] {
    const gameStore = useGameStore() as any as ExtendedGameStore;
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    const cardStore = useCardStore();
    
    const landscape = cardStore.getLandscapeById(gameStore.currentLandscapeId);
    if (!landscape || !landscape.availableResources) {
      return [];
    }
    
    // Get available resources at this landscape
    const availableResources = landscape.availableResources;
    
    // Apply seasonal abundance/scarcity
    const seasonallyAdjusted = this.applySeasonalResourceEffects(
      availableResources,
      gameStore.currentSeason as Season
    );
    
    // Randomly select resources up to count
    const shuffled = [...seasonallyAdjusted].sort(() => 0.5 - Math.random());
    const selectedResources = shuffled.slice(0, count);
    
    // Add to player inventory
    const collected = [];
    for (const resourceId of selectedResources) {
      if (this.collectResource(resourceId)) {
        collected.push(resourceId);
      }
    }
    
    return collected;
  }
  
  /**
   * Use a resource
   * @param resourceId The ID of the resource to use
   * @returns True if the resource was used successfully
   */
  useResource(resourceId: string): boolean {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    return playerStore.removeResource(resourceId);
  }
  
  /**
   * Get resources by type
   * @param type The type of resources to get
   * @returns Array of resource IDs of the specified type
   */
  getResourcesByType(type: string): string[] {
    const playerStore = usePlayerStore() as any as ExtendedPlayerStore;
    const cardStore = useCardStore();
    
    return playerStore.resources.filter(resourceId => {
      const resource = cardStore.getResourceById(resourceId);
      return resource && resource.type === type;
    });
  }
  
  /**
   * Apply seasonal abundance/scarcity effects
   * @param resourceIds Array of resource IDs
   * @param season The current season
   * @returns Modified array of resource IDs
   */
  applySeasonalResourceEffects(resourceIds: string[], season: Season): string[] {
    // Define seasonal abundance/scarcity
    const seasonalEffects = {
      [Season.SAMHAIN]: {
        abundant: ['barrow_dust', 'standing_stone_chips'],
        scarce: ['woven_reeds', 'rowan_wood']
      },
      [Season.WINTERS_DEPTH]: {
        abundant: ['forge_cinders', 'bog_iron'],
        scarce: ['sacred_water', 'horse_hair']
      },
      [Season.IMBOLC]: {
        abundant: ['silver_mistletoe', 'sacred_water'],
        scarce: ['barrow_dust', 'forge_cinders']
      },
      [Season.BELTANE]: {
        abundant: ['rowan_wood', 'oak_galls'],
        scarce: ['standing_stone_chips', 'amber_shards']
      },
      [Season.LUGHNASADH]: {
        abundant: ['horse_hair', 'woven_reeds', 'ogham_sticks'],
        scarce: ['bog_iron', 'silver_mistletoe']
      }
    };
    
    // If no seasonal effects for current season, return original
    if (!seasonalEffects[season]) {
      return resourceIds;
    }
    
    // Make abundant resources more likely, scarce less likely
    let adjusted = [...resourceIds];
    
    // Double abundant resources (increase probability)
    for (const resourceId of resourceIds) {
      if (seasonalEffects[season].abundant.includes(resourceId)) {
        adjusted.push(resourceId);
      }
    }
    
    // Remove scarce resources (decrease probability)
    adjusted = adjusted.filter(resourceId => 
      !seasonalEffects[season].scarce.includes(resourceId)
    );
    
    return adjusted;
  }

  /**
   * Format season name for display
   * @param season The season name/id
   * @returns Formatted season name
   */
  formatSeasonName(season: string | null): string {
    if (!season) return '';
    
    return season.replace('_', ' ')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join(' ');
  }
  
  /**
   * Convert season value to a CSS class name
   * @param season The season name/id
   * @returns CSS class name
   */
  getSeasonClassName(season: string): string {
    if (typeof season === 'string') {
      return season.toLowerCase().replace(/_/g, '-');
    }
    return '';
  }
  
  /**
   * Truncate description to keep card content concise
   * @param text The text to truncate
   * @param maxLength Maximum length before truncation
   * @returns Truncated text
   */
  truncateDescription(text: string, maxLength = 60): string {
    if (!text) return '';
    return text.length > maxLength 
      ? text.substring(0, maxLength) + '...' 
      : text;
  }
}

export const resourceService = new ResourceService();
</file>

<file path="src/stores/playerStore.ts">
import { defineStore } from 'pinia';
import { PlayerState, PlayerEffect, CompanionState } from '@/models/types/player';
import { CharacterCard } from '@/models/types/cards';
import { useCardStore } from './cardStore';
import { useGameStore } from './gameStore';
import { useLogStore } from './logStore';
import { victoryService } from '@/services/victoryService';

export const usePlayerStore = defineStore('player', {
  state: (): PlayerState => ({
    characterId: '',
    health: 10,
    maxHealth: 10,
    resources: [],
    resourceCapacity: 5,
    animalCompanions: [],
    craftedItems: [],
    experience: 0,
    knowledgeDiscovered: [],
    specialAbilityUsed: false,
    activeEffects: [],
    hasCraftedLegendaryItem: false,
    uniqueCraftedItemsCount: 0,
    companionLoyalty: {},
    wisdom: 0,  // Add missing wisdom property
  }),
  
  getters: {
    character(): CharacterCard | null {
      const cardStore = useCardStore();
      const character = cardStore.getCharacterById(this.characterId);
      return character || null;
    },
    
    resourceCount(): number {
      return this.resources.length;
    },
    
    isResourceCapacityReached(): boolean {
      return this.resources.length >= this.resourceCapacity;
    },
    
    companionCount(): number {
      return this.animalCompanions.length;
    },
    
    craftedItemCount(): number {
      return this.craftedItems.length;
    },
    
    experienceLevel(): number {
      // Calculate level based on experience points
      // Every 3 experience points = 1 level
      return Math.floor(this.experience / 3) + 1;
    },
    
    hasEffect(): (effectId: string) => boolean {
      return (effectId: string) => {
        return this.activeEffects.some(effect => effect.id === effectId && effect.duration > 0);
      };
    },
    
    getEffectStrength(): (effectId: string) => number {
      return (effectId: string) => {
        const effect = this.activeEffects.find(effect => effect.id === effectId && effect.duration > 0);
        return effect ? effect.magnitude : 0;
      };
    }
  },
  
  actions: {
    setCharacter(characterId: string): void {
      const cardStore = useCardStore();
      const character = cardStore.getCharacterById(characterId);
      
      if (character) {
        this.characterId = characterId;
        this.health = character.healthPoints;
        this.maxHealth = character.healthPoints;
        this.resourceCapacity = character.resourceCapacity;
        
        // Add starting resources if any
        if (character.startingResources) {
          character.startingResources.forEach(resourceId => {
            this.addResource(resourceId);
          });
        }
        
        // Add starting companions if any
        if (character.startingCompanion) {
          this.addAnimalCompanion(character.startingCompanion);
        }
        
        if (character.startingCompanions) {
          character.startingCompanions.forEach(companionId => {
            this.addAnimalCompanion(companionId);
          });
        }
      }
    },
    
    selectCharacter(characterId: string): boolean {
      this.setCharacter(characterId);
      return true;
    },
    
    addResource(resourceId: string) {
      if (this.resources.length < this.resourceCapacity) {
        this.resources.push(resourceId);
        return true;
      }
      return false;
    },
    
    removeResource(resourceId: string) {
      const index = this.resources.indexOf(resourceId);
      if (index !== -1) {
        this.resources.splice(index, 1);
        return true;
      }
      return false;
    },
    
    addAnimalCompanion(companionId: string) {
      if (!this.animalCompanions.includes(companionId)) {
        this.animalCompanions.push(companionId);
        
        // Initialize companion loyalty status
        this.companionLoyalty[companionId] = {
          loyalty: 5, // Initial loyalty level (1-10 scale)
          state: CompanionState.LOYAL,
          turnsSinceLastFed: 0,
          turnsWary: 0
        };
        
        return true;
      }
      return false;
    },
    
    removeAnimalCompanion(companionId: string) {
      const index = this.animalCompanions.indexOf(companionId);
      if (index !== -1) {
        this.animalCompanions.splice(index, 1);
        
        // Clean up companion loyalty data
        if (this.companionLoyalty[companionId]) {
          delete this.companionLoyalty[companionId];
        }
        
        return true;
      }
      return false;
    },
    
    // Feed an animal companion
    feedCompanion(companionId: string, resourceId: string): boolean {
      // Check if the companion exists
      if (!this.animalCompanions.includes(companionId)) {
        return false;
      }
      
      // Check if the player has the resource
      if (!this.resources.includes(resourceId)) {
        return false;
      }
      
      // Remove the resource
      this.removeResource(resourceId);
      
      // Get companion status
      const status = this.companionLoyalty[companionId];
      if (!status) {
        // Initialize if missing
        this.companionLoyalty[companionId] = {
          loyalty: 5,
          state: CompanionState.LOYAL,
          turnsSinceLastFed: 0,
          turnsWary: 0
        };
      }
      
      // Update companion status
      const updatedStatus = this.companionLoyalty[companionId];
      
      // Reset feeding counter
      updatedStatus.turnsSinceLastFed = 0;
      
      // Increase loyalty (max 10)
      updatedStatus.loyalty = Math.min(10, updatedStatus.loyalty + 1);
      
      // If companion was wary, restore to loyal state
      if (updatedStatus.state === CompanionState.WARY) {
        updatedStatus.state = CompanionState.LOYAL;
        updatedStatus.turnsWary = 0;
      }
      
      const logStore = useLogStore();
      const cardStore = useCardStore();
      
      // Get the resource name for better log messages
      const resource = cardStore.getResourceById(resourceId);
      logStore.addToGameLog(`You fed your animal companion with ${resource ? resource.name : resourceId}.`, true, 'companion');
      
      return true;
    },
    
    // Handle companions at end of turn
    updateCompanionStatus(): void {
      const logStore = useLogStore();
      const cardStore = useCardStore();
      
      // Iterate through all companions
      this.animalCompanions.forEach(companionId => {
        const status = this.companionLoyalty[companionId];
        
        // Skip if no status is recorded
        if (!status) return;
        
        // Increment turns since last fed
        status.turnsSinceLastFed++;
        
        // Get companion card for better logging
        const companion = cardStore.getAnimalCompanionById(companionId);
        const companionName = companion ? companion.name : 'Animal companion';
        
        // Check if companion should become wary (3 turns without food)
        if (status.state === CompanionState.LOYAL && status.turnsSinceLastFed >= 3) {
          status.state = CompanionState.WARY;
          status.turnsWary = 0;
          logStore.addToGameLog(`${companionName} has become wary due to lack of food.`, true, 'companion');
        }
        
        // If already wary, update wary counter
        if (status.state === CompanionState.WARY) {
          status.turnsWary++;
          
          // If wary for 2 turns, mark as leaving
          if (status.turnsWary >= 2) {
            status.state = CompanionState.LEAVING;
            logStore.addToGameLog(`${companionName} is leaving you due to continued neglect.`, true, 'companion');
          }
        }
        
        // If companion is marked as leaving, remove it
        if (status.state === CompanionState.LEAVING) {
          this.removeAnimalCompanion(companionId);
          logStore.addToGameLog(`${companionName} has left you.`, true, 'companion');
        }
      });
    },
    
    // Check if a companion is in a specific state
    isCompanionInState(companionId: string, state: CompanionState): boolean {
      if (!this.animalCompanions.includes(companionId)) {
        return false;
      }
      
      const status = this.companionLoyalty[companionId];
      return status ? status.state === state : false;
    },
    
    // Get all companions in a specific state
    getCompanionsInState(state: CompanionState): string[] {
      return this.animalCompanions.filter(id => {
        const status = this.companionLoyalty[id];
        return status && status.state === state;
      });
    },
    
    addCraftedItem(itemId: string) {
      if (!this.craftedItems.includes(itemId)) {
        this.craftedItems.push(itemId);
        return true;
      }
      return false;
    },
    
    removeCraftedItem(itemId: string) {
      const index = this.craftedItems.indexOf(itemId);
      if (index !== -1) {
        this.craftedItems.splice(index, 1);
        return true;
      }
      return false;
    },
    
    // Add experience points to the player
    addExperience(amount: number): number {
      this.experience += amount;
      return this.experience;
    },
    
    // For backward compatibility with tests
    gainExperience(amount: number): number {
      return this.addExperience(amount);
    },
    
    loseHealth(amount: number) {
      this.health = Math.max(0, this.health - amount);
      
      // Check if player has died
      if (this.health <= 0) {
        // Check defeat conditions and get the reason
        const defeatResult = victoryService.checkDefeatConditions();
        
        // Process defeat using the victory service
        if (defeatResult.isDefeat) {
          victoryService.processDefeat(defeatResult.reason || 'Your health has reached zero.');
        }
      }
      
      return this.health > 0;
    },
    
    healHealth(amount: number) {
      this.health = Math.min(this.maxHealth, this.health + amount);
      return this.health;
    },
    
    discoverKnowledge(knowledgeId: string) {
      if (!this.knowledgeDiscovered.includes(knowledgeId)) {
        this.knowledgeDiscovered.push(knowledgeId);
        return true;
      }
      return false;
    },
    
    useSpecialAbility() {
      if (!this.specialAbilityUsed) {
        this.specialAbilityUsed = true;
        return true;
      }
      return false;
    },
    
    resetSpecialAbility() {
      this.specialAbilityUsed = false;
      return true;
    },
    
    resetPlayer() {
      this.characterId = '';
      this.health = 10;
      this.maxHealth = 10;
      this.resources = [];
      this.resourceCapacity = 5;
      this.animalCompanions = [];
      this.craftedItems = [];
      this.experience = 0;
      this.knowledgeDiscovered = [];
      this.specialAbilityUsed = false;
      this.activeEffects = [];
      this.hasCraftedLegendaryItem = false;
      this.uniqueCraftedItemsCount = 0;
      this.companionLoyalty = {};
    },
    
    addCompanion(companionId: string) {
      if (!this.animalCompanions.includes(companionId)) {
        this.animalCompanions.push(companionId);
        if (!this.companionLoyalty) {
          this.companionLoyalty = {};
        }
        this.companionLoyalty[companionId] = 1;
      }
    },
    
    removeCompanion(companionId: string) {
      this.animalCompanions = this.animalCompanions.filter(id => id !== companionId);
      if (this.companionLoyalty && this.companionLoyalty[companionId]) {
        delete this.companionLoyalty[companionId];
      }
    },
    
    setCompanionLoyalty(companionId: string, loyalty: number) {
      if (!this.companionLoyalty) {
        this.companionLoyalty = {};
      }
      this.companionLoyalty[companionId] = loyalty;
    },
    
    // New methods for threat management
    takeDamage(amount: number) {
      const gameStore = useGameStore();
      const logStore = useLogStore();
      const alive = this.loseHealth(amount);
      
      logStore.addToGameLog(`You take ${amount} damage. Health: ${this.health}/${this.maxHealth}`);
      
      if (!alive) {
        logStore.addToGameLog('You have been defeated!', true);
        gameStore.endGame(false);
      }
      
      return alive;
    },
    
    loseRandomResources(amount: number) {
      const gameStore = useGameStore();
      const logStore = useLogStore();
      let lostCount = 0;
      
      // Don't try to remove more resources than the player has
      amount = Math.min(amount, this.resources.length);
      
      for (let i = 0; i < amount; i++) {
        if (this.resources.length > 0) {
          // Get a random resource index
          const randomIndex = Math.floor(Math.random() * this.resources.length);
          const resourceId = this.resources[randomIndex];
          
          // Get resource name for logging
          const cardStore = useCardStore();
          const resource = cardStore.getResourceById(resourceId);
          
          // Remove the resource
          this.resources.splice(randomIndex, 1);
          lostCount++;
          
          logStore.addToGameLog(`You lost ${resource ? resource.name : 'a resource'}.`);
        }
      }
      
      return lostCount;
    },
    
    addEffect(effect: PlayerEffect) {
      const logStore = useLogStore();
      
      // Check if effect already exists
      const existingEffectIndex = this.activeEffects.findIndex(e => e.id === effect.id);
      
      if (existingEffectIndex !== -1) {
        // Update existing effect
        this.activeEffects[existingEffectIndex].magnitude = effect.magnitude;
        this.activeEffects[existingEffectIndex].duration = effect.duration;
        logStore.addToGameLog(`Effect renewed: ${effect.name}`, true);
      } else {
        // Add new effect
        this.activeEffects.push(effect);
        logStore.addToGameLog(`New effect gained: ${effect.name} - ${effect.description}`, true);
      }
      
      return true;
    },
    
    removeEffect(effectId: string) {
      const logStore = useLogStore();
      const index = this.activeEffects.findIndex(effect => effect.id === effectId);
      
      if (index !== -1) {
        const effect = this.activeEffects[index];
        logStore.addToGameLog(`Effect ended: ${effect.name}`, true);
        this.activeEffects.splice(index, 1);
        return true;
      }
      
      return false;
    },
    
    processEffects() {
      // Reduce duration of all effects
      this.activeEffects.forEach((effect, index) => {
        if (effect.duration > 0) {
          effect.duration--;
          
          if (effect.duration === 0) {
            const logStore = useLogStore();
            logStore.addToGameLog(`Effect ended: ${effect.name}`, true);
            this.activeEffects.splice(index, 1);
          }
        }
      });
    },
    
    // Use a companion's special ability
    useCompanionAbility(companionId: string): boolean {
      // Check if the companion exists and is in a loyal state
      if (!this.animalCompanions.includes(companionId)) {
        return false;
      }
      
      const status = this.companionLoyalty[companionId];
      if (!status || status.state !== CompanionState.LOYAL) {
        return false;
      }
      
      // Get companion info from card store to perform ability
      const cardStore = useCardStore();
      const logStore = useLogStore();
      const companion = cardStore.getCompanionById(companionId);
      
      if (!companion) {
        return false;
      }
      
      logStore.addToGameLog(`You use ${companion.name}'s special ability: ${companion.ability.description}`, true, 'companion');
      
      // Apply ability effects based on companion type
      // (In a real implementation, this would have specific logic for each companion)
      
      return true;
    },
    
    // Get the loyalty status of a companion
    getCompanionStatus(companionId: string): CompanionState {
      if (!this.animalCompanions.includes(companionId)) {
        return CompanionState.LEAVING;
      }
      
      const status = this.companionLoyalty[companionId];
      if (!status) {
        return CompanionState.LOYAL; // Default to loyal if no status is found
      }
      
      return status.state;
    },
    
    // Use a crafted item's effect
    useCraftedItem(itemId: string): boolean {
      // Check if the player has the item
      if (!this.craftedItems.includes(itemId)) {
        return false;
      }
      
      // Get item details from card store
      const cardStore = useCardStore();
      const logStore = useLogStore();
      const item = cardStore.getCraftedItemById(itemId);
      
      if (!item) {
        return false;
      }
      
      logStore.addToGameLog(`You use ${item.name}: ${item.description}`, true, 'crafting');
      
      // Apply item effects based on the type
      // (In a real implementation, this would have specific logic for each item)
      
      // Track item usage - some items might be single-use
      // For now, we'll keep items after use
      
      return true;
    },
    
    // Use a companion to help with a challenge
    useCompanionForChallenge(companionId: string): boolean {
      // Check if the companion exists and is in a loyal state
      if (!this.animalCompanions.includes(companionId)) {
        return false;
      }
      
      const status = this.companionLoyalty[companionId];
      if (!status || status.state !== CompanionState.LOYAL) {
        return false;
      }
      
      // Get companion info from card store
      const cardStore = useCardStore();
      const logStore = useLogStore();
      const companion = cardStore.getCompanionById(companionId);
      
      if (!companion) {
        return false;
      }
      
      logStore.addToGameLog(`${companion.name} helps you with the challenge.`, true, 'companion');
      
      // In a real implementation, this could reduce companion loyalty or have other effects
      
      return true;
    },
    
    // Use a companion to keep watch during the night
    useCompanionForNight(companionId: string): boolean {
      // Check if the companion exists and is in a loyal state
      if (!this.animalCompanions.includes(companionId)) {
        return false;
      }
      
      const status = this.companionLoyalty[companionId];
      if (!status || status.state !== CompanionState.LOYAL) {
        return false;
      }
      
      // Get companion info from card store
      const cardStore = useCardStore();
      const logStore = useLogStore();
      const companion = cardStore.getCompanionById(companionId);
      
      if (!companion) {
        return false;
      }
      
      logStore.addToGameLog(`${companion.name} keeps watch over you during the night.`, true, 'companion');
      
      // In a real implementation, this could reduce companion loyalty or have other effects
      
      return true;
    },
    
    // Get a list of items that can be crafted with current resources
    getCraftableItems(): string[] {
      const cardStore = useCardStore();
      const allCraftableItems = cardStore.getAllCraftedItems().map(item => item.id);
      const craftableItems: string[] = [];
      
      for (const itemId of allCraftableItems) {
        const item = cardStore.getCraftedItemById(itemId);
        if (!item || !item.requiredResources) continue;
        
        // Check if we have all the required resources
        let canCraft = true;
        for (const resourceId of item.requiredResources) {
          if (!this.resources.includes(resourceId)) {
            canCraft = false;
            break;
          }
        }
        
        if (canCraft) {
          craftableItems.push(itemId);
        }
      }
      
      return craftableItems;
    },

    // Craft an item from resources
    craftItem(itemId: string): boolean {
      const cardStore = useCardStore();
      const logStore = useLogStore();
      const item = cardStore.getCraftedItemById(itemId);
      
      if (!item || !item.requiredResources) {
        return false;
      }
      
      // Check if we have all the resources needed
      for (const resourceId of item.requiredResources) {
        if (!this.resources.includes(resourceId)) {
          return false;
        }
      }
      
      // Remove resources used in crafting
      for (const resourceId of item.requiredResources) {
        this.removeResource(resourceId);
      }
      
      // Add the crafted item
      this.addCraftedItem(itemId);
      
      logStore.addToGameLog(`You crafted ${item.name}.`, true, 'crafting');
      
      return true;
    },

    // Rest to recover health
    rest(): boolean {
      const logStore = useLogStore();
      
      // Heal 1 health point when resting
      this.healHealth(1);
      
      logStore.addToGameLog(`You rest and recover. Health is now ${this.health}/${this.maxHealth}.`, true, 'system');
      
      return true;
    },
    
    // Use a companion to help with gathering resources
    useCompanionForGathering(companionId: string): boolean {
      // Check if the companion exists and is in a loyal state
      if (!this.animalCompanions.includes(companionId)) {
        return false;
      }
      
      const status = this.companionLoyalty[companionId];
      if (!status || status.state !== CompanionState.LOYAL) {
        return false;
      }
      
      // Get companion info from card store
      const cardStore = useCardStore();
      const logStore = useLogStore();
      const companion = cardStore.getCompanionById(companionId);
      
      if (!companion) {
        return false;
      }
      
      logStore.addToGameLog(`${companion.name} helps you gather resources.`, true, 'companion');
      
      // In a real implementation, this could reduce companion loyalty or have other effects
      
      return true;
    },
  }
});
</file>

<file path=".gitignore">
/node_modules
/cypress
src/repomix-output.xml
src/components/repomix-output.xml
</file>

<file path="src/models/data/companions.js">
// Animal Companions data based on the game rules
const companions = [
  {
    id: 'raven',
    name: 'Raven Scout',
    ability: 'Reveal next Landscape card',
    abilityDescription: 'The Raven flies ahead to scout the path, revealing the next landscape you will encounter.',
    preferredResources: ['standing_stone_chips', 'barrow_dust', 'ogham_sticks', 'sacred_water', 'amber_shards', 'horse_hair'],
    seasonalAffinity: ['samhain', 'winters_depth'],
    image: 'raven.jpg',
    findLocation: 'ancient_stone_circle',
    abilityFunction: (gameState) => {
      // Implementation would reveal the next landscape in the journey path
      return {
        success: true,
        message: 'The Raven scouts ahead, revealing the next landscape on your journey.'
      }
    }
  },
  {
    id: 'wolf',
    name: 'Wolf Guardian',
    ability: '+2 to combat-related challenges',
    abilityDescription: 'The Wolf stands by your side during combat, lending its strength and ferocity.',
    preferredResources: ['bog_iron'],
    seasonalAffinity: ['samhain', 'winters_depth'],
    image: 'wolf.jpg',
    findLocation: 'sacred_oak_grove',
    abilityFunction: (gameState, challengeType) => {
      if (['physical', 'combat'].includes(challengeType)) {
        return {
          bonus: 2,
          success: true,
          message: 'The Wolf Guardian stands beside you, adding its strength to yours.'
        }
      }
      return {
        bonus: 0,
        success: true,
        message: 'The Wolf Guardian watches but cannot help with this type of challenge.'
      }
    }
  },
  {
    id: 'deer',
    name: 'Deer Guide',
    ability: 'Move an extra Landscape without challenge',
    abilityDescription: 'The Deer knows hidden paths through the wilderness, allowing you to bypass a challenge.',
    preferredResources: ['silver_mistletoe', 'oak_galls', 'ogham_sticks'],
    seasonalAffinity: ['imbolc'],
    image: 'deer.jpg',
    findLocation: 'sacred_oak_grove',
    abilityFunction: (gameState) => {
      // Implementation would allow skipping a landscape challenge
      return {
        success: true,
        message: 'The Deer Guide leads you along a hidden path, bypassing the challenge ahead.'
      }
    }
  },
  {
    id: 'bear',
    name: 'Bear Protector',
    ability: 'Prevent up to 3 damage from one challenge',
    abilityDescription: 'The Bear shields you from harm, absorbing damage that would otherwise injure you.',
    preferredResources: ['forge_cinders'],
    seasonalAffinity: ['beltane'],
    image: 'bear.jpg',
    findLocation: 'sacred_oak_grove',
    abilityFunction: (gameState, damage) => {
      const preventedDamage = Math.min(damage, 3)
      return {
        preventedDamage,
        success: true,
        message: `The Bear Protector shields you, preventing ${preventedDamage} damage.`
      }
    }
  },
  {
    id: 'hare',
    name: 'Hare Pathfinder',
    ability: 'Re-roll one failed challenge roll',
    abilityDescription: 'The Hare\'s quick thinking and agility inspire you to try again after a failure.',
    preferredResources: ['woven_reeds'],
    seasonalAffinity: ['imbolc'],
    image: 'hare.jpg',
    findLocation: 'faerie_knoll',
    abilityFunction: (gameState) => {
      // Implementation would allow re-rolling a challenge
      return {
        success: true,
        message: 'The Hare Pathfinder inspires you to try a different approach. You may re-roll your challenge.'
      }
    }
  },
  {
    id: 'boar',
    name: 'Boar Digger',
    ability: 'Collect one extra Resource card',
    abilityDescription: 'The Boar\'s keen sense for finding hidden treasures helps you discover additional resources.',
    preferredResources: ['oak_galls'],
    seasonalAffinity: ['lughnasadh'],
    image: 'boar.jpg',
    findLocation: 'sacred_oak_grove',
    abilityFunction: (gameState) => {
      // Implementation would add an extra resource
      return {
        success: true,
        message: 'The Boar Digger roots around and uncovers an additional resource for you.'
      }
    }
  },
  {
    id: 'fox',
    name: 'Fox Trickster',
    ability: 'Manipulate one die roll by 2',
    abilityDescription: 'The Fox\'s cunning allows you to manipulate fate, adjusting a die roll in your favor.',
    preferredResources: ['amber_shards'],
    seasonalAffinity: ['beltane'],
    image: 'fox.jpg',
    findLocation: 'faerie_knoll',
    abilityFunction: (gameState, rollValue, adjustment) => {
      // Ensure adjustment is within 2
      const validAdjustment = Math.max(-2, Math.min(2, adjustment))
      return {
        adjustedRoll: rollValue + validAdjustment,
        success: true,
        message: `The Fox Trickster uses its cunning to adjust your roll by ${validAdjustment}.`
      }
    }
  },
  {
    id: 'owl',
    name: 'Owl Sage',
    ability: 'Gain insight to bypass one challenge without rolling',
    abilityDescription: 'The Owl\'s wisdom reveals the solution to a challenge, allowing you to bypass it entirely.',
    preferredResources: ['barrow_dust'],
    seasonalAffinity: ['samhain', 'winters_depth'],
    image: 'owl.jpg',
    findLocation: 'moonlit_loch',
    abilityFunction: (gameState, challengeType) => {
      if (challengeType === 'mental' || challengeType === 'knowledge') {
        return {
          bypass: true,
          success: true,
          message: 'The Owl Sage shares ancient wisdom, allowing you to bypass this challenge without rolling.'
        }
      }
      return {
        bypass: false,
        success: true,
        message: 'The Owl Sage offers advice, but this challenge requires more than wisdom alone.'
      }
    }
  },
  {
    id: 'salmon',
    name: 'Salmon Journeyer',
    ability: 'Return to a previous Landscape instantly',
    abilityDescription: 'The Salmon knows how to swim against the current, guiding you back to a place you\'ve visited before.',
    preferredResources: ['sacred_water'],
    seasonalAffinity: ['imbolc'],
    image: 'salmon.jpg',
    findLocation: 'moonlit_loch',
    abilityFunction: (gameState, targetLandscapeIndex) => {
      // Implementation would move player to a previous landscape
      if (targetLandscapeIndex < gameState.journeyProgress) {
        return {
          success: true,
          message: 'The Salmon Journeyer guides you back upstream to a previous landscape.'
        }
      }
      return {
        success: false,
        message: 'The Salmon Journeyer cannot guide you to a place you haven\'t yet visited.'
      }
    }
  },
  {
    id: 'horse',
    name: 'Horse Carrier',
    ability: 'Carry 3 extra Resource cards temporarily',
    abilityDescription: 'The Horse\'s strength allows you to carry more resources than you normally could.',
    preferredResources: ['horse_hair'],
    seasonalAffinity: ['beltane'],
    image: 'horse.jpg',
    findLocation: 'wild_horse_plain',
    abilityFunction: (gameState) => {
      // Implementation would temporarily increase resource capacity
      return {
        extraCapacity: 3,
        success: true,
        message: 'The Horse Carrier allows you to carry 3 additional resources temporarily.'
      }
    }
  }
]

export default companions;
</file>

<file path="src/models/data/resources.js">
// Resource data based on the game rules
export const resources = [
  {
    id: 'rowan_wood',
    name: 'Rowan Wood',
    effect: 'Wards against supernatural threats',
    type: 'protective',
    description: 'Sacred wood that provides protection against supernatural entities.',
    image: 'rowan_wood.jpg',
    useEffect: 'Prevent 1 additional Threat token accumulation'
  },
  {
    id: 'bog_iron',
    name: 'Bog Iron',
    effect: 'Strengthens crafted items',
    type: 'crafting_base',
    description: 'Iron extracted from bogs, known for its unique properties in crafting.',
    image: 'bog_iron.jpg',
    preferredBy: ['wolf']
  },
  {
    id: 'silver_mistletoe',
    name: 'Silver Mistletoe',
    effect: 'Opens pathways between worlds',
    type: 'spiritual',
    description: 'Rare mistletoe with silver-tinted leaves that can bridge the gap between worlds.',
    image: 'silver_mistletoe.jpg',
    preferredBy: ['deer']
  },
  {
    id: 'standing_stone_chips',
    name: 'Standing Stone Chips',
    effect: 'Enhances divination abilities',
    type: 'mystic',
    description: 'Small fragments from ancient standing stones, imbued with divinatory power.',
    image: 'stone_chips.jpg',
    preferredBy: ['raven']
  },
  {
    id: 'woven_reeds',
    name: 'Woven Reeds',
    effect: 'Creates protective barriers',
    type: 'protective',
    description: 'Specially woven reeds that can create magical barriers when properly arranged.',
    image: 'woven_reeds.jpg',
    preferredBy: ['hare']
  },
  {
    id: 'horse_hair',
    name: 'Horse Hair',
    effect: 'Binds magical energies',
    type: 'binding',
    description: 'Hair from wild horses that can bind magical energies when woven into patterns.',
    image: 'horse_hair.jpg',
    preferredBy: ['horse']
  },
  {
    id: 'oak_galls',
    name: 'Oak Galls',
    effect: 'Preserves magical properties',
    type: 'crafting_base',
    description: 'Growths from oak trees that preserve the magical properties of other materials.',
    image: 'oak_galls.jpg',
    preferredBy: ['boar']
  },
  {
    id: 'amber_shards',
    name: 'Amber Shards',
    effect: 'Stores spiritual energy',
    type: 'binding',
    description: 'Fragments of amber that can store spiritual energy for later use.',
    image: 'amber_shards.jpg',
    preferredBy: ['fox']
  },
  {
    id: 'barrow_dust',
    name: 'Barrow Dust',
    effect: 'Communes with ancestral spirits',
    type: 'spiritual',
    description: 'Dust gathered from ancient burial mounds, allowing communion with ancestral spirits.',
    image: 'barrow_dust.jpg',
    useEffect: 'Commune with spirits for hints',
    preferredBy: ['owl']
  },
  {
    id: 'forge_cinders',
    name: 'Forge Cinders',
    effect: 'Transforms magical properties',
    type: 'elemental',
    description: 'Cinders from a sacred forge that can transform the magical properties of other materials.',
    image: 'forge_cinders.jpg',
    preferredBy: ['bear']
  },
  {
    id: 'sacred_water',
    name: 'Sacred Water',
    effect: 'Purifies corrupted elements',
    type: 'elemental',
    description: 'Water from sacred springs that can purify corrupted elements and heal wounds.',
    image: 'sacred_water.jpg',
    useEffect: 'Remove 1 Threat token or heal 1 Health',
    preferredBy: ['salmon']
  },
  {
    id: 'ogham_sticks',
    name: 'Ogham Sticks',
    effect: 'Deciphers magical writing',
    type: 'mystic',
    description: 'Wooden sticks inscribed with Ogham symbols, used to decipher magical writings.',
    image: 'ogham_sticks.jpg',
    preferredBy: ['deer']
  },
  {
    id: 'ancient_crystal',
    name: 'Ancient Crystal',
    effect: 'Amplifies spiritual energy',
    type: 'mystic',
    description: 'A valuable crystal with properties that can amplify magical energies.',
    image: 'ancient_crystal.jpg',
    preferredBy: ['owl']
  }
]

export default resources;
</file>

<file path="src/models/data/landscapes.js">
// Landscape data based on the game rules
const landscapes = [
  {
    id: 'ancient_stone_circle',
    name: 'Ancient Stone Circle',
    challenge: 'Spectral Guardians',
    challengeType: 'mental',
    difficulty: 5,
    description: 'A circle of towering stones, humming with ancient power and guarded by spectral entities.',
    availableResources: ['standing_stone_chips', 'barrow_dust', 'amber_shards', 'ancient_crystal'],
    image: 'stone_circle.jpg',
    companions: ['raven']
  },
  {
    id: 'misty_barrow_downs',
    name: 'Misty Barrow Downs',
    challenge: 'Ancestral Spirits',
    challengeType: 'spiritual',
    difficulty: 6,
    description: 'Rolling hills shrouded in mist, dotted with ancient burial mounds where ancestral spirits linger.',
    availableResources: ['barrow_dust', 'ogham_sticks', 'amber_shards'],
    image: 'barrow_downs.jpg'
  },
  {
    id: 'sacred_oak_grove',
    name: 'Sacred Oak Grove',
    challenge: 'Wild Beasts',
    challengeType: 'physical',
    difficulty: 4,
    description: 'A grove of ancient oaks where wild beasts roam and protect the sacred trees.',
    availableResources: ['rowan_wood', 'oak_galls', 'silver_mistletoe'],
    image: 'oak_grove.jpg',
    companions: ['wolf', 'deer', 'bear', 'boar']
  },
  {
    id: 'thatched_village',
    name: 'Thatched Village',
    challenge: 'Suspicious Elders',
    challengeType: 'social',
    difficulty: 5,
    description: 'A small settlement of thatched roundhouses where elders are wary of outsiders.',
    availableResources: ['woven_reeds', 'horse_hair', 'rowan_wood'],
    image: 'village.jpg'
  },
  {
    id: 'iron_forge_dell',
    name: 'Iron Forge Dell',
    challenge: 'Molten Trials',
    challengeType: 'physical',
    difficulty: 7,
    description: 'A smoky valley where smiths work their forges, testing visitors with trials of heat and metal.',
    availableResources: ['bog_iron', 'forge_cinders', 'standing_stone_chips'],
    image: 'forge.jpg',
    craftingBonus: ['bog_iron']
  },
  {
    id: 'moonlit_loch',
    name: 'Moonlit Loch',
    challenge: 'Water Spirits',
    challengeType: 'spiritual',
    difficulty: 5,
    description: 'A serene lake reflecting the moon, home to mysterious water spirits.',
    availableResources: ['sacred_water', 'woven_reeds', 'silver_mistletoe'],
    image: 'loch.jpg',
    companions: ['salmon', 'owl'],
    craftingBonus: ['sacred_water'],
    healing: 2
  },
  {
    id: 'menhir_path',
    name: 'Menhir Path',
    challenge: 'Stone Sentinels',
    challengeType: 'perception',
    difficulty: 6,
    description: 'A path lined with standing stones that seem to shift positions when not observed directly.',
    availableResources: ['standing_stone_chips', 'barrow_dust', 'ogham_sticks'],
    image: 'menhir.jpg'
  },
  {
    id: 'faerie_knoll',
    name: 'Faerie Knoll',
    challenge: 'Trickster Beings',
    challengeType: 'cunning',
    difficulty: 7,
    description: 'A small hill where the veil between worlds is thin and trickster faeries delight in confounding travelers.',
    availableResources: ['silver_mistletoe', 'amber_shards', 'horse_hair'],
    image: 'faerie_knoll.jpg',
    companions: ['fox', 'hare']
  },
  {
    id: 'whispering_heath',
    name: 'Whispering Heath',
    challenge: 'Deceptive Paths',
    challengeType: 'navigation',
    difficulty: 5,
    description: 'A vast heathland where whispers on the wind lead travelers astray.',
    availableResources: ['woven_reeds', 'rowan_wood', 'oak_galls'],
    image: 'heath.jpg',
    companions: ['raven']
  },
  {
    id: 'blackthorn_maze',
    name: 'Blackthorn Maze',
    challenge: 'Thorny Barriers',
    challengeType: 'endurance',
    difficulty: 6,
    description: 'A labyrinth of thorny blackthorn bushes that test a traveler\'s endurance and determination.',
    availableResources: ['rowan_wood', 'horse_hair', 'bog_iron'],
    image: 'blackthorn.jpg'
  },
  {
    id: 'boggy_lowlands',
    name: 'Boggy Lowlands',
    challenge: 'Sinking Ground',
    challengeType: 'agility',
    difficulty: 5,
    description: 'Treacherous wetlands where the ground may give way beneath your feet at any moment.',
    availableResources: ['bog_iron', 'sacred_water', 'woven_reeds'],
    image: 'bog.jpg'
  },
  {
    id: 'gathering_fair',
    name: 'Gathering Fair',
    challenge: 'Rival Seekers',
    challengeType: 'trade',
    difficulty: 4,
    description: 'A bustling market where various Celtic tribes gather to trade goods and stories.',
    availableResources: ['horse_hair', 'woven_reeds', 'ogham_sticks'],
    image: 'fair.jpg'
  },
  {
    id: 'elder_bridge',
    name: 'Elder Bridge',
    challenge: 'Guardian Toll',
    challengeType: 'sacrifice',
    difficulty: 7,
    description: 'An ancient bridge guarded by spirits who demand a toll from all who wish to cross.',
    availableResources: ['standing_stone_chips', 'amber_shards', 'barrow_dust'],
    image: 'bridge.jpg'
  },
  {
    id: 'druids_sanctuary',
    name: 'Druid\'s Sanctuary',
    challenge: 'Wisdom Trial',
    challengeType: 'knowledge',
    difficulty: 8,
    description: 'A sacred grove where druids test visitors with trials of wisdom and knowledge.',
    availableResources: ['silver_mistletoe', 'oak_galls', 'ogham_sticks'],
    image: 'sanctuary.jpg',
    craftingBonus: ['standing_stone_chips'],
    healing: 2
  },
  {
    id: 'wild_horse_plain',
    name: 'Wild Horse Plain',
    challenge: 'Untamed Spirits',
    challengeType: 'connection',
    difficulty: 6,
    description: 'Vast grasslands where wild horses run free, embodying the untamed spirit of the land.',
    availableResources: ['horse_hair', 'woven_reeds', 'rowan_wood'],
    image: 'horse_plain.jpg',
    companions: ['horse']
  }
]

export default landscapes;
</file>

<file path="src/services/companionService.ts">
/**
 * Companion Service
 * Handles animal companion bonding and management
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { CompanionState } from '@/models/types/player';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';
import { AnimalCompanionCard } from '@/models/types/cards';

class CompanionService {
  private _lastBondedCompanionId: string | null = null;

  /**
   * Bond with a new companion
   * @param companionId The ID of the companion to bond with
   * @param resourceId The ID of the resource used for bonding
   * @returns True if bonding was successful
   */
  bondWithCompanion(companionId: string, resourceId: string): boolean {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    // Check if player already has this companion
    if (playerStore.animalCompanions.includes(companionId)) {
      return false;
    }
    
    // Get companion card
    const companion = cardStore.getCompanionById(companionId);
    if (!companion) {
      return false;
    }
    
    // Check if resource is appropriate for bonding
    if (!this.isResourceSuitableForBonding(resourceId, companionId)) {
      return false;
    }
    
    // Use the resource
    if (!playerStore.removeResource(resourceId)) {
      return false;
    }
    
    // Add companion to player
    playerStore.addCompanion(companionId);
    
    // Apply bonding effects
    this.applyBondingEffects(companionId);
    
    return true;
  }

  /**
   * Feed a companion to increase loyalty
   * @param companionId ID of the companion
   * @param resourceId ID of the resource to feed
   * @returns True if feeding was successful
   */
  feedCompanion(companionId: string, resourceId: string): boolean {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Check if player has this companion
    if (!playerStore.animalCompanions.includes(companionId)) {
      return false;
    }
    
    // Check if player has the resource
    if (!playerStore.resources.includes(resourceId)) {
      return false;
    }
    
    // Use feedAnimalCompanion from playerStore
    return playerStore.feedAnimalCompanion(companionId, resourceId);
  }

  /**
   * Get the loyalty level of a companion
   * @param companionId ID of the companion
   * @returns The loyalty level (0-5) or -1 if not found
   */
  getLoyalty(companionId: string): number {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Check if the companion exists
    if (!playerStore.animalCompanions.includes(companionId)) {
      return -1;
    }
    
    return playerStore.companionLoyalty(companionId);
  }

  /**
   * Increase the loyalty of a companion by 1
   * @param companionId ID of the companion
   * @returns New loyalty level
   */
  increaseLoyalty(companionId: string): number {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Check if the companion exists
    if (!playerStore.animalCompanions.includes(companionId)) {
      return -1;
    }
    
    // Get current loyalty
    const currentLoyalty = playerStore.companionLoyalty(companionId);
    
    // Max loyalty is 5
    if (currentLoyalty >= 5) {
      return currentLoyalty;
    }
    
    // Set new loyalty
    const newLoyalty = currentLoyalty + 1;
    playerStore.setCompanionLoyalty(companionId, newLoyalty);
    
    // Apply effects for reaching new loyalty level
    this.applyLoyaltyEffects(companionId, newLoyalty);
    
    return newLoyalty;
  }

  /**
   * Decrease the loyalty of a companion by 1
   * @param companionId ID of the companion
   * @returns New loyalty level
   */
  decreaseLoyalty(companionId: string): number {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Check if the companion exists
    if (!playerStore.animalCompanions.includes(companionId)) {
      return -1;
    }
    
    // Get current loyalty
    const currentLoyalty = playerStore.companionLoyalty(companionId);
    
    // Min loyalty is 0 (companion leaves when it hits 0)
    if (currentLoyalty <= 0) {
      // Remove companion
      playerStore.removeCompanion(companionId);
      return -1;
    }
    
    // Set new loyalty
    const newLoyalty = currentLoyalty - 1;
    playerStore.setCompanionLoyalty(companionId, newLoyalty);
    
    return newLoyalty;
  }

  /**
   * Get a list of companions that provide bonuses for a challenge type
   * @param challengeType Type of challenge to check
   * @returns Array of companion IDs that provide bonuses
   */
  getCompanionsForChallengeType(challengeType: string): string[] {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    return playerStore.animalCompanions.filter(companionId => {
      const companion = cardStore.getCompanionById(companionId);
      // Companion must exist and provide a bonus for this challenge type
      return companion && 
             companion.challengeBonuses && 
             companion.challengeBonuses[challengeType] > 0;
    });
  }

  /**
   * Select a random companion based on current location and season
   */
  selectRandomCompanion(): string {
    const cardStore = useCardStore();
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const gameStore = useGameStore() as unknown as ExtendedGameStore;

    // Get current location ID and season
    const locationId = gameStore.currentLandscapeId;
    const season = gameStore.currentSeason;
    
    // Get all available companions for this location/season
    const availableCompanions = cardStore.animalCompanions.filter(companion => {
      // Filter by season
      if (companion.affinitySeasons && companion.affinitySeasons.length > 0) {
        if (!companion.affinitySeasons.includes(season)) {
          return false;
        }
      }
      
      // Player doesn't already have this companion
      return !playerStore.animalCompanions.includes(companion.id);
    });
    
    // No available companions
    if (availableCompanions.length === 0) {
      return '';
    }
    
    // Select random companion
    const randomIndex = Math.floor(Math.random() * availableCompanions.length);
    const selectedCompanion = availableCompanions[randomIndex];
    
    this._lastBondedCompanionId = selectedCompanion.id;
    
    return selectedCompanion.id;
  }

  /**
   * Check if a companion is in a wary state (loyalty < 3)
   * @param companionId ID of the companion
   * @returns True if the companion is wary
   */
  isCompanionWary(companionId: string): boolean {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Check if the companion exists
    if (!playerStore.animalCompanions.includes(companionId)) {
      return false;
    }
    
    // Get loyalty
    const loyalty = playerStore.companionLoyalty(companionId);
    
    // Wary if loyalty < 3
    return loyalty < 3;
  }

  /**
   * Apply effects when bonding with a companion
   * @param companionId ID of the companion
   */
  private applyBondingEffects(companionId: string): void {
    const cardStore = useCardStore();
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    const companion = cardStore.getCompanionById(companionId);
    if (!companion || !companion.bondingEffect) {
      return;
    }
    
    // Apply bonding effect (which is a function)
    companion.bondingEffect(playerStore);
  }

  /**
   * Apply effects when reaching a new loyalty level
   * @param companionId ID of the companion
   * @param loyaltyLevel New loyalty level reached
   */
  private applyLoyaltyEffects(companionId: string, loyaltyLevel: number): void {
    const cardStore = useCardStore();
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    const companion = cardStore.getCompanionById(companionId);
    if (!companion || !companion.loyaltyEffects) {
      return;
    }
    
    // Get the loyalty effect for this level (using object access)
    const effect = companion.loyaltyEffects[loyaltyLevel];
    
    // Apply effect if it exists
    if (effect) {
      effect(playerStore);
    }
  }

  /**
   * Get a list of resources from the player's inventory that
   * are compatible with a specific companion
   * @param companionId ID of the companion
   * @returns Array of resource objects
   */
  getCompatibleResources(companionId: string): any[] {
    const cardStore = useCardStore();
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Get all player resources
    const playerResourceIds = playerStore.resources;
    
    // Get the companion
    const companion = cardStore.getCompanionById(companionId);
    if (!companion || !companion.preferredResources) {
      return [];
    }
    
    // Filter resources that match companion's preferred resources
    return playerResourceIds
      .map(id => cardStore.getResourceById(id))
      .filter(resource => {
        if (!resource) return false;
        
        // Extract base resource type from the resourceId
        const resourceType = resource.id.split('_').slice(0, -1).join('_');
        
        // Check if resource type is in companion's preferred resources
        return companion.preferredResources.some(prefResource => 
          resourceType === prefResource || resource.id === prefResource
        );
      });
  }

  /**
   * Get the best food resource for a companion from player inventory
   * @param companionId ID of the companion
   * @returns Resource ID or null if none available
   */
  getBestFoodResource(companionId: string): string | null {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Get compatible resources
    const compatibleResources = this.getCompatibleResources(companionId);
    
    // No compatible resources
    if (compatibleResources.length === 0) {
      return null;
    }
    
    // Return the first one (could be improved to return best match)
    return compatibleResources[0].id;
  }
  
  /**
   * Check if a resource is suitable for bonding with a specific companion
   * @param resourceId ID of the resource
   * @param companionId ID of the companion
   * @returns True if the resource is suitable
   */
  isResourceSuitableForBonding(resourceId: string, companionId: string): boolean {
    const cardStore = useCardStore();
    
    // Get companion and resource cards
    const companion = cardStore.getCompanionById(companionId);
    const resource = cardStore.getResourceById(resourceId);
    
    if (!companion || !resource) {
      return false;
    }
    
    // Extract base resource type from the resourceId
    const resourceType = resource.id.split('_').slice(0, -1).join('_');
    
    // Check if resource type is in companion's preferred resources
    return companion.preferredResources && companion.preferredResources.some(prefResource => 
      resourceType === prefResource || resource.id === prefResource
    );
  }
  
  /**
   * Get all potential companions for the current location and season
   * @returns Array of companion cards
   */
  getPotentialCompanions(): AnimalCompanionCard[] {
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    // Get current location ID and season
    const locationId = gameStore.currentLandscapeId;
    const season = gameStore.currentSeason;
    
    // Filter companions based on season only
    return cardStore.animalCompanions.filter(companion => {
      // Match season
      if (companion.affinitySeasons && companion.affinitySeasons.length > 0) {
        if (!companion.affinitySeasons.includes(season)) {
          return false;
        }
      }
      
      return true;
    });
  }
  
  /**
   * Check if a player can potentially bond with any companions
   * in the current location/season
   * @returns True if potential companions are available
   */
  hasPotentialCompanions(): boolean {
    const cardStore = useCardStore();
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    // Get all potential companions for current location and season
    const potentialCompanions = this.getPotentialCompanions();
    
    // No potential companions
    if (potentialCompanions.length === 0) {
      return false;
    }
    
    // Check if player has any compatible resources for bonding
    for (const companion of potentialCompanions) {
      for (const resourceId of playerStore.resources) {
        const resource = cardStore.getResourceById(resourceId);
        if (resource && companion.preferredResources && companion.preferredResources.some(prefResource => {
          const resourceType = resource.id.split('_').slice(0, -1).join('_');
          return resourceType === prefResource || resource.id === prefResource;
        })) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  /**
   * Reset the service state
   */
  reset(): void {
    this._lastBondedCompanionId = null;
  }
}

export const companionService = new CompanionService();
</file>

<file path="src/services/craftingService.ts">
/**
 * Crafting Service
 * Handles crafting mechanics and resource requirements
 */
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import { ThreatService } from '@/services/threatService';
import { ExtendedGameStore, ExtendedPlayerStore } from '@/types/store-extensions';
import { Season } from '@/models/enums/seasons';

// Define interfaces to extend existing types
interface ExtendedLandscape {
  hasCraftingFacilities?: boolean;
  craftingBonuses?: Record<string, number>;
  specialCraftingCapabilities?: number;
}

// Complexity tiers with their numeric values for difficulty calculation
const COMPLEXITY_TIERS = {
  SIMPLE: 1,
  COMPLEX: 2,
  ADVANCED: 3,
  LEGENDARY: 4
};

// Map string complexity values to numeric tier values
const getComplexityValue = (complexity: string | number): number => {
  // If it's already a number, return it
  if (typeof complexity === 'number') {
    return complexity;
  }
  
  switch(complexity.toLowerCase()) {
    case 'simple': return COMPLEXITY_TIERS.SIMPLE;
    case 'complex': return COMPLEXITY_TIERS.COMPLEX;
    case 'advanced': return COMPLEXITY_TIERS.ADVANCED;
    case 'legendary': return COMPLEXITY_TIERS.LEGENDARY;
    default: return COMPLEXITY_TIERS.SIMPLE;
  }
};

class CraftingService {
  private gameStore = useGameStore() as unknown as ExtendedGameStore;
  private playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
  private cardStore = useCardStore();
  private threatService = new ThreatService();
  
  /**
   * Check if player can craft an item
   * @param itemId The ID of the item to craft
   * @returns Object with canCraft flag and missing resources
   */
  canCraftItem(itemId: string): {
    canCraft: boolean;
    missingResources: string[];
    landscapeSupported: boolean;
    playerSkill: boolean;
  } {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    // Get crafted item
    const item = cardStore.getCraftedItemById(itemId);
    if (!item) {
      return { canCraft: false, missingResources: [], landscapeSupported: false, playerSkill: false };
    }
    
    // Check if player already has this item
    if (playerStore.craftedItems.includes(itemId)) {
      return { canCraft: false, missingResources: [], landscapeSupported: false, playerSkill: false };
    }
    
    // Check required resources
    const missingResources = [];
    for (const resourceId of item.requiredResources) {
      if (!playerStore.resources.includes(resourceId)) {
        missingResources.push(resourceId);
      }
    }
    
    // Check if current landscape supports crafting this item complexity
    const landscapeSupported = this.isComplexitySupportedByLandscape(
      getComplexityValue(item.complexity),
      gameStore.currentLandscapeId
    );
    
    // Check if player has sufficient skill level for this item
    const playerSkill = this.playerHasSkillForComplexity(
      getComplexityValue(item.complexity)
    );
    
    return {
      canCraft: missingResources.length === 0,
      missingResources,
      landscapeSupported,
      playerSkill
    };
  }
  
  /**
   * Check if the current landscape supports crafting at the given complexity tier
   * @param complexityTier The numeric complexity tier value
   * @param landscapeId The current landscape ID
   * @returns True if the landscape supports this complexity
   */
  isComplexitySupportedByLandscape(complexityTier: number, landscapeId: string): boolean {
    const cardStore = useCardStore();
    const landscape = cardStore.getLandscapeById(landscapeId) as unknown as ExtendedLandscape;
    
    if (!landscape) {
      return false;
    }
    
    // Basic landscapes may only support simple crafting
    if (!landscape.hasCraftingFacilities && complexityTier > COMPLEXITY_TIERS.SIMPLE) {
      return false;
    }
    
    // Specialized crafting landscapes (with facilities) support up to complex items
    if (landscape.hasCraftingFacilities && complexityTier <= COMPLEXITY_TIERS.COMPLEX) {
      return true;
    }
    
    // Check for special crafting landscapes that support advanced or legendary
    if (landscape.specialCraftingCapabilities) {
      return complexityTier <= landscape.specialCraftingCapabilities;
    }
    
    // Default case: simple items can be crafted anywhere
    return complexityTier === COMPLEXITY_TIERS.SIMPLE;
  }
  
  /**
   * Check if player has sufficient skill for crafting at the given complexity tier
   * @param complexityTier The numeric complexity tier value
   * @returns True if player has the necessary skill
   */
  playerHasSkillForComplexity(complexityTier: number): boolean {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Number of crafted items can indicate skill level
    const craftedItemCount = playerStore.craftedItemCount;
    
    // Simple items require no prior crafting
    if (complexityTier === COMPLEXITY_TIERS.SIMPLE) {
      return true;
    }
    
    // Complex items require at least 1 prior crafted item
    if (complexityTier === COMPLEXITY_TIERS.COMPLEX) {
      return craftedItemCount >= 1;
    }
    
    // Advanced items require at least 3 prior crafted items
    if (complexityTier === COMPLEXITY_TIERS.ADVANCED) {
      return craftedItemCount >= 3;
    }
    
    // Legendary items require at least 5 prior crafted items
    if (complexityTier === COMPLEXITY_TIERS.LEGENDARY) {
      return craftedItemCount >= 5;
    }
    
    return false;
  }
  
  /**
   * Craft an item if possible
   * @param itemId ID of the item to craft
   * @returns True if the item was crafted, false otherwise
   */
  public craftItem(itemId: string): boolean {
    const { canCraft, missingResources, landscapeSupported, playerSkill } = this.canCraftItem(itemId);
    
    if (!canCraft) {
      if (missingResources.length > 0) {
        const gameStore = useGameStore() as unknown as ExtendedGameStore;
        gameStore.addToGameLog(`Cannot craft item: missing resources - ${missingResources.join(', ')}`, true);
      } else if (!landscapeSupported) {
        const gameStore = useGameStore() as unknown as ExtendedGameStore;
        gameStore.addToGameLog('Cannot craft item: current landscape does not support this complexity of crafting', true);
      } else if (!playerSkill) {
        const gameStore = useGameStore() as unknown as ExtendedGameStore;
        gameStore.addToGameLog('Cannot craft item: insufficient crafting experience', true);
      } else {
        const gameStore = useGameStore() as unknown as ExtendedGameStore;
        gameStore.addToGameLog('Cannot craft item: unknown reason', true);
      }
      return false;
    }
    
    const item = this.cardStore.getCraftedItemById(itemId);
    if (!item) {
      const gameStore = useGameStore() as unknown as ExtendedGameStore;
      gameStore.addToGameLog(`Cannot craft item: item with ID ${itemId} not found`, true);
      return false;
    }
    
    // Validate each required resource exists in the game data
    const invalidResources = [];
    for (const resourceId of item.requiredResources) {
      if (!this.cardStore.getResourceById(resourceId)) {
        invalidResources.push(resourceId);
      }
    }
    
    if (invalidResources.length > 0) {
      const gameStore = useGameStore() as unknown as ExtendedGameStore;
      gameStore.addToGameLog(`Crafting failed: invalid resource references - ${invalidResources.join(', ')}`, true);
      return false;
    }
    
    // Remove required resources
    for (const resourceId of item.requiredResources) {
      const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
      playerStore.removeResource(resourceId);
    }
    
    // Add the crafted item to inventory
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    playerStore.addCraftedItem(itemId);
    
    // Update unique crafted items count for skill progression
    if (!playerStore.craftedItems.includes(itemId)) {
      playerStore.uniqueCraftedItemsCount++;
    }
    
    // Check for legendary item
    if (item.isLegendary) {
      const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
      playerStore.hasCraftedLegendaryItem = true;
    }
    
    // Apply threat cost based on item complexity
    const threatCost = this.threatService.getThreatForCraftedItem(itemId);
    if (threatCost > 0) {
      this.threatService.addThreatTokens(threatCost);
      const gameStore = useGameStore() as unknown as ExtendedGameStore;
      gameStore.addToGameLog(`Crafting this powerful item has increased threat by ${threatCost}.`, true);
    }
    
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    gameStore.addToGameLog(`Successfully crafted ${item.name}!`, true);
    return true;
  }
  
  /**
   * Calculate crafting difficulty for an item
   * @param itemId The ID of the item to craft
   * @returns The calculated difficulty
   */
  calculateCraftingDifficulty(itemId: string): number {
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    
    // Get crafted item
    const item = cardStore.getCraftedItemById(itemId);
    if (!item) {
      return 10; // High difficulty if item not found
    }
    
    // Base difficulty from item complexity
    let complexity = item.complexity || 'simple';
    let difficulty = getComplexityValue(complexity);
    
    // Apply location bonus/penalty
    const locationBonus = this.getLocationCraftingBonus(itemId, gameStore.currentLandscapeId);
    difficulty -= locationBonus * 2; // Increase the impact of location bonuses
    
    // Apply seasonal effects
    const seasonalModifier = this.getSeasonalCraftingModifier(gameStore.currentSeason);
    difficulty += seasonalModifier;
    
    // Apply threat level effects
    const threatLevel = Math.floor(gameStore.threatTokens / 3);
    difficulty += threatLevel;
    
    // Apply player's crafting experience bonus
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const experienceBonus = Math.floor(playerStore.craftedItemCount / 2);
    difficulty -= experienceBonus;
    
    // Ensure minimum difficulty of 1
    return Math.max(1, difficulty);
  }
  
  /**
   * Get crafting bonus for current location
   * @param itemId The ID of the item to craft
   * @param locationId The ID of the current location
   * @returns The location bonus (positive is beneficial)
   */
  getLocationCraftingBonus(itemId: string, locationId: string): number {
    const cardStore = useCardStore();
    
    const item = cardStore.getCraftedItemById(itemId);
    const landscape = cardStore.getLandscapeById(locationId) as unknown as ExtendedLandscape;
    
    if (!item || !landscape) {
      return 0;
    }
    
    // Check if location has crafting facilities
    if (landscape.hasCraftingFacilities) {
      return 1;
    }
    
    // Check if location has special bonus for this item type
    if (landscape.craftingBonuses && item.type && landscape.craftingBonuses[item.type]) {
      return landscape.craftingBonuses[item.type];
    }
    
    // Check if landscape has special affinity for the item's complexity
    if (landscape.specialCraftingCapabilities && 
        getComplexityValue(item.complexity) <= landscape.specialCraftingCapabilities) {
      return 2; // Bigger bonus for specialized crafting locations
    }
    
    return 0;
  }
  
  /**
   * Get seasonal modifier for crafting
   * @param season The current season
   * @returns The seasonal modifier (negative is beneficial)
   */
  getSeasonalCraftingModifier(season: Season): number {
    // Different seasons have different effects on crafting
    switch(season) {
      case Season.SAMHAIN:
        return 1; // Slightly more difficult
      case Season.WINTERS_DEPTH:
        return 2; // More difficult in winter
      case Season.IMBOLC:
        return 0; // Neutral
      case Season.BELTANE:
        return -1; // Easier in spring
      case Season.LUGHNASADH:
        return -2; // Easiest in harvest season
      default:
        return 0;
    }
  }
  
  /**
   * Get recipe suggestions based on available resources
   * @returns Array of craftable item IDs
   */
  getRecipeSuggestions(): string[] {
    const cardStore = useCardStore();
    const craftableItems = cardStore.getAllCraftedItems();
    
    // Filter to items that can be crafted
    return craftableItems
      .filter(item => item.requiredResources && item.requiredResources.length > 0)
      .map(item => item.id);
  }
  
  /**
   * Get recipe suggestions filtered by complexity (number of required resources)
   * @param maxComplexity The maximum number of resources required for a recipe
   * @returns An array of item IDs for craftable items that meet the complexity requirement
   */
  getRecipeSuggestionsByComplexity(maxComplexity: number): string[] {
    const cardStore = useCardStore();
    const craftableItems = cardStore.getAllCraftedItems();
    
    // Filter to items that can be crafted and match complexity
    return craftableItems
      .filter(item => 
        item.requiredResources && 
        item.requiredResources.length > 0 && 
        item.requiredResources.length <= maxComplexity
      )
      .map(item => item.id);
  }
  
  /**
   * Get detailed crafting requirements and restrictions for an item
   * @param itemId The ID of the item to check
   * @returns Detailed crafting requirements object
   */
  getCraftingRequirements(itemId: string): {
    item: any,
    requiredResources: string[],
    missingResources: string[],
    landscapeSupported: boolean,
    playerSkill: boolean,
    difficulty: number,
    locationBonus: number,
    seasonalModifier: number
  } | null {
    const cardStore = useCardStore();
    const gameStore = useGameStore() as unknown as ExtendedGameStore;
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    const item = cardStore.getCraftedItemById(itemId);
    if (!item) {
      return null;
    }
    
    const { missingResources, landscapeSupported, playerSkill } = this.canCraftItem(itemId);
    const difficulty = this.calculateCraftingDifficulty(itemId);
    const locationBonus = this.getLocationCraftingBonus(itemId, gameStore.currentLandscapeId);
    const seasonalModifier = this.getSeasonalCraftingModifier(gameStore.currentSeason);
    
    return {
      item,
      requiredResources: item.requiredResources,
      missingResources,
      landscapeSupported,
      playerSkill,
      difficulty,
      locationBonus,
      seasonalModifier
    };
  }
  
  /**
   * Apply effects when an item is crafted
   * @param itemId The ID of the crafted item
   */
  applyItemEffect(itemId: string) {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    const cardStore = useCardStore();
    
    const item = cardStore.getCraftedItemById(itemId);
    if (!item || !item.ability || typeof item.ability !== 'object') {
      return;
    }
    
    // Apply the item's ability effects based on its type
    // In a real implementation, this would include specific logic for each item
    
    if (item.ability.type === 'healing') {
      // Example: Healing items restore health
      playerStore.healHealth(2);
    } else if (item.ability.type === 'protection') {
      // Example: Protection items add temporary effects
      const gameStore = useGameStore() as unknown as ExtendedGameStore;
      gameStore.addTempEffect(
        `${itemId}_protection`,
        `${item.name} Protection`,
        item.ability.description || '',
        2,
        3
      );
    }
    
    // If the item has a drawback, apply it
    if (item.drawback) {
      // Example: Some drawbacks could reduce health or add threat
      const gameStore = useGameStore() as unknown as ExtendedGameStore;
      gameStore.addThreatTokens(1);
    }
  }
  
  /**
   * Check if crafting this item satisfies any victory conditions
   */
  private checkCraftingVictoryConditions(): void {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    
    // Example: Check if player has crafted a legendary item
    const cardStore = useCardStore();
    const hasLegendaryItem = playerStore.craftedItems.some(itemId => {
      const item = cardStore.getCraftedItemById(itemId);
      return item && item.isLegendary;
    });
    
    if (hasLegendaryItem) {
      playerStore.hasCraftedLegendaryItem = true;
    }
    
    // Check for number of unique crafted items
    const uniqueItemTypes = new Set(
      playerStore.craftedItems.map(itemId => {
        const item = cardStore.getCraftedItemById(itemId);
        return item ? item.type : null;
      }).filter(Boolean)
    );
    
    playerStore.uniqueCraftedItemsCount = uniqueItemTypes.size;
  }

  /**
   * Check if player has a specific resource
   * @param resourceId The ID of the resource
   * @returns True if the player has the resource
   */
  hasResource(resourceId: string): boolean {
    const playerStore = usePlayerStore() as unknown as ExtendedPlayerStore;
    return playerStore.resources.includes(resourceId);
  }

  /**
   * Get resource name by ID
   * @param resourceId The ID of the resource
   * @returns The name of the resource or 'Unknown' if not found
   */
  getResourceName(resourceId: string): string {
    const cardStore = useCardStore();
    const resource = cardStore.getResourceById(resourceId);
    return resource ? resource.name : 'Unknown';
  }

  /**
   * Truncate description to keep card content concise
   * @param text The text to truncate
   * @param maxLength Maximum length before truncation
   * @returns Truncated text
   */
  truncateDescription(text: string, maxLength = 60): string {
    if (!text) return '';
    return text.length > maxLength 
      ? text.substring(0, maxLength) + '...' 
      : text;
  }
}

// Create a singleton instance for use throughout the application
export const craftingService = new CraftingService();
</file>

<file path="src/stores/gameStore.ts">
import { defineStore } from 'pinia';
import { GamePhase } from '@/models/enums/phases';
import { VictoryConditions } from '@/models/types/game';
import { usePlayerStore } from './playerStore';
import { useSeasonStore } from './seasonStore';
import { useJourneyStore } from './journeyStore';
import { useChallenge } from './challengeStore';
import { useLogStore } from './logStore';
import { useCardStore } from './cardStore';
import { victoryService } from '@/services/victoryService';

interface GameState {
  currentPhase: GamePhase;
  currentTurn: number;
  gameStarted: boolean;
  gameOver: boolean;
  isVictory: boolean;
  victoryConditions: VictoryConditions;
  currentLandscapeId: string;
}

/**
 * Main game store for overall game state management
 * Coordinates between other domain-specific stores
 */
export const useGameStore = defineStore('game', {
  state: (): GameState => ({
    currentPhase: GamePhase.SEASONAL_ASSESSMENT,
    currentTurn: 1,
    gameStarted: false,
    gameOver: false,
    isVictory: false,
    victoryConditions: {
      journeyCompleted: false,
      balanceMaintained: false,
      knowledgeAcquired: false,
      bondsFormed: false,
      questFulfilled: false,
      landscapesTraversed: false,
      seasonsExperienced: false,
      challengesOvercome: false
    },
    currentLandscapeId: ''
  }),
  
  getters: {
    /**
     * Check if the game is over
     */
    isGameOver(): boolean {
      return this.gameOver;
    },
    
    /**
     * Check if the player has won
     */
    hasWon(): boolean {
      return this.isVictory;
    }
  },
  
  actions: {
    /**
     * Start a new game
     */
    startGame(): void {
      const seasonStore = useSeasonStore();
      const logStore = useLogStore();
      
      this.gameStarted = true;
      this.currentPhase = GamePhase.SEASONAL_ASSESSMENT;
      this.currentTurn = 1;
      
      // Reset all domain-specific stores
      seasonStore.reset();
      useJourneyStore().reset();
      useChallenge().reset();
      
      logStore.addToGameLog('Your journey begins in the season of Samhain, when the veil between worlds is thinnest.', true);
    },
    
    /**
     * Reset the game state
     */
    resetGame(): void {
      // Reset main game state
      this.currentPhase = GamePhase.SEASONAL_ASSESSMENT;
      this.currentTurn = 1;
      this.gameStarted = false;
      this.gameOver = false;
      this.isVictory = false;
      this.victoryConditions = {
        journeyCompleted: false,
        balanceMaintained: false,
        knowledgeAcquired: false,
        bondsFormed: false,
        questFulfilled: false,
        landscapesTraversed: false,
        seasonsExperienced: false,
        challengesOvercome: false
      };
      this.currentLandscapeId = '';
      
      // Reset all domain-specific stores
      useSeasonStore().reset();
      useJourneyStore().reset();
      useChallenge().reset();
      useLogStore().reset();
      usePlayerStore().resetPlayer();
    },
    
    /**
     * End the game
     */
    endGame(isVictory: boolean): void {
      const logStore = useLogStore();
      
      this.gameOver = true;
      this.isVictory = isVictory;
      
      if (isVictory) {
        logStore.addToGameLog('Congratulations! You have completed your journey through the Celtic Realm.', true);
      } else {
        logStore.addToGameLog('Your journey has come to an end. The Celtic Realm remains shrouded in mystery.', true);
      }
      
      this.currentPhase = GamePhase.GAME_OVER;
    },
    
    /**
     * Set the current game phase
     */
    setPhase(phase: GamePhase): void {
      const logStore = useLogStore();
      
      this.currentPhase = phase;
      logStore.addToGameLog(`Entering the ${this._formatPhase(phase)} phase.`);
    },
    
    /**
     * Advance to the next game phase
     */
    advancePhase(): void {
      const logStore = useLogStore();
      
      const phaseOrder = [
        GamePhase.SEASONAL_ASSESSMENT,
        GamePhase.THREAT_LEVEL_CHECK,
        GamePhase.LANDSCAPE_CHALLENGE,
        GamePhase.CHALLENGE_RESOLUTION,
        GamePhase.RESOURCE_MANAGEMENT,
        GamePhase.ANIMAL_COMPANION,
        GamePhase.CRAFTING,
        GamePhase.JOURNEY_PROGRESSION
      ];
      
      const currentIndex = phaseOrder.indexOf(this.currentPhase);
      if (currentIndex !== -1) {
        const previousPhase = this.currentPhase;
        this.currentPhase = phaseOrder[(currentIndex + 1) % phaseOrder.length];
        
        logStore.addToGameLog(`Entering the ${this._formatPhase(this.currentPhase)} phase.`, true, 'phase', {
          previousPhase,
          newPhase: this.currentPhase
        });
        
        // If we've completed a full cycle, advance the turn
        if (this.currentPhase === GamePhase.SEASONAL_ASSESSMENT) {
          this.advanceTurn();
        }
      }
    },
    
    /**
     * Advance to the next turn
     */
    advanceTurn(): void {
      const logStore = useLogStore();
      const seasonStore = useSeasonStore();
      
      this.currentTurn++;
      logStore.addToGameLog(`Turn ${this.currentTurn} has begun.`, true, 'system', {
        newTurn: this.currentTurn,
        currentSeason: this._formatSeason(seasonStore.currentSeason)
      });
      
      // Process any temporary effects
      seasonStore.processTempEffects();
      
      // Check if we need to advance the season
      if (this.currentTurn % 3 === 0) {
        seasonStore.advanceSeason();
      }
      
      // Check victory conditions
      this.checkVictoryConditions();
    },
    
    /**
     * Check if victory conditions have been met
     */
    checkVictoryConditions(): boolean {
      // Use the victory service to check all conditions
      const result = victoryService.checkVictoryConditions();
      this.victoryConditions = result;
      
      // Check if all required victory conditions are met
      const allConditionsMet = Object.values(result).every(condition => condition);
      
      if (allConditionsMet) {
        this.endGame(true);
        return true;
      }
      
      return false;
    },
    
    /**
     * Set the current landscape ID
     * @param landcapeId The ID of the landscape to set as current
     */
    setCurrentLandscapeId(landcapeId: string): void {
      const logStore = useLogStore();
      const cardStore = useCardStore();
      
      this.currentLandscapeId = landcapeId;
      
      const landscape = cardStore.getLandscapeById(landcapeId);
      if (landscape) {
        logStore.addToGameLog(`You have arrived at ${landscape.name}.`, true, 'landscape');
      }
    },
    
    /**
     * Handle all phases of a turn
     */
    processTurn(): void {
      const challengeStore = useChallenge();
      const playerStore = usePlayerStore();
      
      // Handle each phase based on the current phase
      switch (this.currentPhase) {
        case GamePhase.SEASONAL_ASSESSMENT:
          // Check seasonal effects
          this._handleSeasonalAssessment();
          break;
          
        case GamePhase.THREAT_LEVEL_CHECK:
          // Check threat level and potential events
          challengeStore.handleThreatLevelCheck();
          break;
          
        case GamePhase.LANDSCAPE_CHALLENGE:
          // Generate or process landscape challenge
          this._handleLandscapeChallenge();
          break;
          
        case GamePhase.CHALLENGE_RESOLUTION:
          // Resolve any active challenges
          this._handleChallengeResolution();
          break;
          
        case GamePhase.RESOURCE_MANAGEMENT:
          // Handle resource gathering and management
          this._handleResourceManagement();
          break;
          
        case GamePhase.ANIMAL_COMPANION:
          // Handle animal companion care and abilities
          playerStore.updateCompanionStatus();
          break;
          
        case GamePhase.CRAFTING:
          // Handle crafting opportunities
          // Do nothing by default - player initiates crafting
          break;
          
        case GamePhase.JOURNEY_PROGRESSION:
          // Handle journey movement and progression
          this._handleJourneyProgression();
          break;
          
        default:
          break;
      }
      
      // After processing, advance to next phase
      this.advancePhase();
    },
    
    /**
     * Format phase name for display
     * @private
     */
    _formatPhase(phase: GamePhase): string {
      const phaseNames: Record<GamePhase, string> = {
        [GamePhase.SEASONAL_ASSESSMENT]: 'Seasonal Assessment',
        [GamePhase.THREAT_LEVEL_CHECK]: 'Threat Level Check',
        [GamePhase.LANDSCAPE_CHALLENGE]: 'Landscape Challenge',
        [GamePhase.CHALLENGE_RESOLUTION]: 'Challenge Resolution',
        [GamePhase.RESOURCE_MANAGEMENT]: 'Resource Management',
        [GamePhase.ANIMAL_COMPANION]: 'Animal Companion',
        [GamePhase.CRAFTING]: 'Crafting',
        [GamePhase.JOURNEY_PROGRESSION]: 'Journey Progression',
        [GamePhase.GAME_OVER]: 'Game Over'
      };
      
      return phaseNames[phase] || 'Unknown Phase';
    },
    
    /**
     * Format season name for display
     * @private
     */
    _formatSeason(season: string): string {
      const nameMap: Record<string, string> = {
        'samhain': 'Samhain',
        'winters_depth': 'Winter\'s Depth',
        'imbolc': 'Imbolc',
        'beltane': 'Beltane',
        'lughnasadh': 'Lughnasadh'
      };
      
      return nameMap[season] || 'Unknown Season';
    },
    
    /**
     * Handle seasonal assessment phase
     * @private
     */
    _handleSeasonalAssessment(): void {
      // Process any seasonal effects, such as resource scarcity
      this._handleHealingRecovery();
    },
    
    /**
     * Handle landscape challenge phase
     * @private
     */
    _handleLandscapeChallenge(): void {
      const journeyStore = useJourneyStore();
      const challengeStore = useChallenge();
      const logStore = useLogStore();
      
      // If no current landscape, nothing to do
      if (!journeyStore.currentLandscapeId) {
        logStore.addToGameLog('You must choose a landscape before facing challenges.', false, 'system');
        return;
      }
      
      // If no active challenge, create one
      if (!challengeStore.currentChallenge) {
        const landscape = journeyStore.currentLandscape;
        if (landscape) {
          const challengeId = `${landscape.id}_${landscape.challengeType?.toLowerCase() || 'challenge'}`;
          challengeStore.setCurrentChallenge(challengeId);
        }
      }
    },
    
    /**
     * Handle challenge resolution phase
     * @private
     */
    _handleChallengeResolution(): void {
      // Usually handled by player action, this is just a placeholder
      const challengeStore = useChallenge();
      const logStore = useLogStore();
      
      if (!challengeStore.currentChallenge) {
        logStore.addToGameLog('No active challenge to resolve.', false, 'system');
      }
    },
    
    /**
     * Handle resource management phase
     * @private
     */
    _handleResourceManagement(): void {
      // Usually handled by player action, this is just a placeholder
      const logStore = useLogStore();
      logStore.addToGameLog('You may gather resources or manage your inventory.', false, 'system');
    },
    
    /**
     * Handle journey progression phase
     * @private
     */
    _handleJourneyProgression(): void {
      // Usually handled by player action, this is just a placeholder
      const logStore = useLogStore();
      logStore.addToGameLog('You may continue your journey to a new location.', false, 'system');
    },
    
    /**
     * Handle healing and recovery phase
     * @private
     */
    _handleHealingRecovery(): void {
      const playerStore = usePlayerStore();
      const seasonStore = useSeasonStore();
      const logStore = useLogStore();
      
      // Basic recovery varies by season
      let recoveryChance = 0;
      switch (seasonStore.currentSeason) {
        case 'beltane':
          recoveryChance = 0.75; // 75% chance in Beltane (spring)
          break;
        case 'lughnasadh':
          recoveryChance = 0.5; // 50% chance in Lughnasadh (summer)
          break;
        case 'samhain':
          recoveryChance = 0.25; // 25% chance in Samhain (autumn)
          break;
        case 'winters_depth':
          recoveryChance = 0; // No natural recovery in Winter's Depth
          break;
        case 'imbolc':
          recoveryChance = 0.4; // 40% chance in Imbolc (late winter/early spring)
          break;
        default:
          recoveryChance = 0.3;
      }
      
      // Check for healing
      if (playerStore.health < playerStore.maxHealth && Math.random() < recoveryChance) {
        playerStore.healHealth(1);
        logStore.addToGameLog('You recover 1 health from rest.', false, 'system');
      }
      
      // Process player effects
      playerStore.processEffects();
    },
  }
});
</file>

<file path="src/views/GameSetupView.vue">
<template>
  <div class="game-setup">
    <div class="game-container">
      <div class="game-header">
        <h1 class="game-title">Game Setup</h1>
        <p class="game-subtitle">Choose your character and begin your journey through the mystical Celtic landscape.</p>
      </div>
      
      <div class="celtic-quote">
        "The journey through the Celtic Realm is one of discovery, challenge, and transformation."
      </div>
      
      <h2>Select Your Character</h2>
      <p class="character-intro mb-4">
        Each character brings unique abilities and challenges to your journey. Choose wisely, as your character's strengths and weaknesses will shape your path through the Celtic Realm.
      </p>
      
      <div class="character-selection">
        <!-- Debug info to check character data -->
        <div v-if="characters.length === 0" style="color: red; font-weight: bold;">
          No characters found! Please check character data initialization.
        </div>
        
        <GameCard 
          v-for="character in characters" 
          :key="character.id" 
          :title="character.name"
          cardType="CHARACTER"
          :class="{ 'selected': selectedCharacter && selectedCharacter.id === character.id }"
          @click="startGame(character)"
        >
          <p style="font-size: 10pt;">{{ character.description }}</p>
          
          <div class="character-stats" style="font-size: 10pt; background: transparent;">
            <div class="stat" style="background: transparent;"><span class="stat-label" style="font-size: 9pt;">Health:</span> <span style="font-size: 9pt;">{{ character.healthPoints }}</span></div>
            <div class="stat" style="background: transparent;"><span class="stat-label" style="font-size: 9pt;">Capacity:</span> <span style="font-size: 9pt;">{{ character.resourceCapacity }}</span></div>
          </div>
          
          <div class="character-abilities" style="font-size: 10pt;">
            <strong>{{ getAbilityName(character) }}:</strong> {{ getAbilityDescription(character) }}
          </div>
        </GameCard>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { usePlayerStore } from '@/stores/playerStore';
import { useGameStore } from '@/stores/gameStore';
import { useCardStore } from '@/stores/cardStore';
import { GamePhase } from '@/models/enums/phases';
import { Season } from '@/models/enums/seasons';
import { CardType } from '@/models/enums/cardTypes';
import type { CharacterCard } from '@/models/types/cards';
import GameCard from '@/components/core/GameCard.vue'; // Import the GameCard component

// Initialize stores and router
const router = useRouter();
const playerStore = usePlayerStore();
const gameStore = useGameStore();
const cardStore = useCardStore();

// Initialize state
const characters = ref<CharacterCard[]>([]);
const selectedCharacter = ref<CharacterCard | null>(null);

// Load characters when component is mounted
const loadCharacters = () => {
  // Always initialize the cards to ensure we have the latest data
  cardStore.initializeCards();
  characters.value = cardStore.characters;
  console.log('Characters loaded:', characters.value.length);
};

// Select a character
const selectCharacter = (character: CharacterCard) => {
  selectedCharacter.value = character;
};

// Get the ability name for a character
const getAbilityName = (character: CharacterCard) => {
  return character.specialAbility?.name || '';
};

// Get the ability description for a character
const getAbilityDescription = (character: CharacterCard) => {
  return character.specialAbility?.description || '';
};

// Start the game with the selected character
const startGame = (character: CharacterCard) => {
  try {
    console.log('Starting game with character:', character.name);
    
    // Set the player's character
    playerStore.selectCharacter(character.id);
    
    // Initialize game state
    gameStore.startGame();
    gameStore.setPhase(GamePhase.SEASONAL_ASSESSMENT);
    
    // Add initial game log entry
    gameStore.addToGameLog(`You begin your journey as ${character.name}.`, true, 'system');
    
    // Set initial landscape if not already set
    if (!gameStore.currentLandscapeId) {
      const landscapes = cardStore.landscapes;
      if (landscapes.length > 0) {
        // Find the Ancient Stone Circle landscape
        const ancientStoneCircle = landscapes.find(landscape => landscape.id === 'ancient_stone_circle');
        
        if (ancientStoneCircle) {
          // Start at the Ancient Stone Circle
          gameStore.setCurrentLandscape(ancientStoneCircle.id);
          gameStore.addToGameLog(`You begin your journey at the Ancient Stone Circle.`, true, 'system');
          
          // Set a challenge from this landscape
          if (ancientStoneCircle.challenges && ancientStoneCircle.challenges.length > 0) {
            const firstChallenge = ancientStoneCircle.challenges[0];
            gameStore.setCurrentChallenge(firstChallenge.id);
            console.log('Set initial challenge:', firstChallenge.name);
          }
        } else {
          // Fallback to first landscape if Ancient Stone Circle is not found
          const firstLandscape = landscapes[0];
          gameStore.setCurrentLandscape(firstLandscape.id);
          
          // Set a challenge from this landscape
          if (firstLandscape.challenges && firstLandscape.challenges.length > 0) {
            const firstChallenge = firstLandscape.challenges[0];
            gameStore.setCurrentChallenge(firstChallenge.id);
            console.log('Set initial challenge:', firstChallenge.name);
          }
        }
      }
    }
    
    // Navigate to the game board - use a slight delay to ensure all state changes are processed
    console.log('Navigating to game board');
    setTimeout(() => {
      router.push('/game');
    }, 50);
  } catch (error) {
    console.error('Error starting game:', error);
    alert('There was an error starting your adventure. Please try again.');
  }
};

// Load characters when component is mounted
onMounted(() => {
  // Reset game state when setup view is loaded (handles browser refresh)
  gameStore.resetGame();
  playerStore.resetPlayer();
  
  // Then load characters
  loadCharacters();
});
</script>

<style lang="scss" scoped>
.game-setup {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 2rem;
  
  .game-container {
    max-width: 1200px;
    width: 100%;
  }
  
  .game-header {
    text-align: center;
    margin-bottom: 1rem;
  }
  
  .game-title {
    font-size: 2.5rem;
    color: #5c3d2e;
    margin-bottom: 0.25rem;
  }
  
  .game-subtitle {
    font-size: 1.2rem;
    color: #6a5d4d;
  }
  
  .celtic-quote {
    font-family: 'Tangerine', cursive;
    font-size: 1.8rem;
    text-align: center;
    color: #5c3d2e;
    margin: 1rem 0;
    font-style: italic;
  }
  
  h2 {
    font-size: 1.8rem;
    color: #5c3d2e;
    text-align: center;
    margin-bottom: 0.5rem;
  }
  
  .character-intro {
    text-align: center;
    max-width: 800px;
    margin: 0 auto;
    color: #6a5d4d;
  }
  
  .character-selection {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 1rem;
    margin-top: 1rem;
  }
  
  .character-stats {
    display: flex;
    justify-content: space-between;
    margin-bottom: 0.25rem;
    
    .stat {
      background-color: rgba(92, 61, 46, 0.1);
      padding: 0.2rem;
      border-radius: 5px;
      font-size: 1.3rem;
      
      .stat-label {
        font-weight: bold;
        color: #5c3d2e;
      }
    }
  }
  
  .character-abilities {
    margin-bottom: 0.25rem;
    font-size: 1.3rem;
    color: #6a5d4d;
    
    strong {
      color: #5c3d2e;
    }
  }
}
</style>
</file>

<file path=".windsurfrules">
mportant Restrictions
All tests are made in the @tests directory
No mocking tests
do not run or build the application
do not execute git commands
Minimise starting and stopping the npm server
do not create new files
do not create new css styles
work with the existing design
use existing componets
do not run tests
minial descricptions of work performed back to the user
maintain consistancy with models in src\models\data use using 
Do not hard code game values. They are in src\models\data.
minimize ruinning shell commands
</file>

<file path="src/stores/cardStore.ts">
import { defineStore } from 'pinia';
import { CardType, ChallengeType } from '@/models/enums/cardTypes';
import { Season } from '@/models/enums/seasons';
import { 
  CharacterCard, 
  LandscapeCard, 
  AnimalCompanionCard, 
  ResourceCard, 
  CraftedItemCard, 
  SeasonCard,
  ChallengeCard
} from '@/models/types/cards';
import { cardRepository } from '@/services/CardRepository';

interface CardStoreState {
  initialized: boolean;
}

export const useCardStore = defineStore('card', {
  state: (): CardStoreState => ({
    initialized: false
  }),
  
  getters: {
    characters: () => {
      return cardRepository.characters;
    },
    
    landscapes: () => {
      return cardRepository.landscapes;
    },
    
    animalCompanions: () => {
      return cardRepository.animalCompanions;
    },
    
    resources: () => {
      return cardRepository.resources;
    },
    
    craftedItems: () => {
      return cardRepository.craftedItems;
    },
    
    seasons: () => {
      return cardRepository.seasons;
    },
    
    getCharacterById: () => (id: string) => {
      return cardRepository.getCharacterById(id);
    },
    
    getLandscapeById: () => (id: string) => {
      return cardRepository.getLandscapeById(id);
    },
    
    getAnimalCompanionById: () => (id: string) => {
      return cardRepository.getAnimalCompanionById(id);
    },
    
    getCompanionById: () => (id: string) => {
      return cardRepository.getAnimalCompanionById(id);
    },
    
    getResourceById: () => (id: string) => {
      return cardRepository.getResourceById(id);
    },
    
    getCraftedItemById: () => (id: string) => {
      return cardRepository.getCraftedItemById(id);
    },
    
    getSeasonById: () => (id: string) => {
      return cardRepository.getSeasonById(id);
    },
    
    getChallengeById: () => (id: string) => {
      return cardRepository.getChallengeById(id);
    },
    
    getResourcesBySeason: () => (season: Season) => {
      return cardRepository.getResourcesBySeason(season);
    },
    
    getCompanionsBySeason: () => (season: Season) => {
      return cardRepository.getCompanionsBySeason(season);
    },
    
    getAllCraftedItems: () => () => {
      return cardRepository.craftedItems;
    },
    
    getCraftableItems: () => () => {
      return cardRepository.craftedItems.map(item => item.id);
    }
  },
  
  actions: {
    initializeCards() {
      // Card initialization is now handled by CardRepository
      // This method is kept for backward compatibility
      this.initialized = true;
    }
  }
});
</file>

<file path="src/views/GameBoardView.vue">
<template>
  <div class="game-board" style="border: 2px solid lightblue; position: relative;">
    <main class="game-content">
      <!-- Phase-specific content using PhaseFactory -->
      <section class="phase-content">
        <PhaseFactory />
      </section>
    </main>
    
    <aside class="game-log">
      <PlayerDashboard />
      <GameLog />
    </aside>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useGameStore } from '@/stores/gameStore';
import { usePlayerStore } from '@/stores/playerStore';
import { useCardStore } from '@/stores/cardStore';
import GameMap from '@/components/game/GameMap.vue';
import ResourceManagement from '@/components/game/ResourceManagement.vue';
import CraftingStation from '@/components/game/CraftingStation.vue';
import PlayerDashboard from '@/components/game/PlayerDashboard.vue';
import AnimalCompanionSelection from '@/components/game/AnimalCompanionSelection.vue';
import CompanionManagement from '@/components/game/CompanionManagement.vue';
import GameLog from '@/components/game/GameLog.vue';
import GameCard from '@/components/core/GameCard.vue';
import { GamePhase } from '@/models/enums/phases';
import { CardType } from '@/models/enums/cardTypes';
import { CraftingService } from '@/services/craftingService';
import type { ResourceCard } from '@/models/types/cards';
import type { LandscapeCard } from '@/models/types/cards';
import { Season } from '@/models/enums/seasons';
import { ChallengeType } from '@/models/enums/cardTypes';
import PhaseFactory from '@/components/phases/PhaseFactory.vue';

// Interface for challenge result
interface ChallengeResult {
  success: boolean;
  partialSuccess?: boolean;
  partialSuccessExperience?: number;
  partialSuccessSetback?: string;
  message: string;
  damage?: number;
  rewards?: any;
}

// Initialize router and stores
const router = useRouter();
const playerStore = usePlayerStore();
const gameStore = useGameStore();
const cardStore = useCardStore();

// Reactive references
const lastChallengeResult = ref<ChallengeResult | null>(null);
const selectedCompanion = ref<string | null>(null);
const craftingService = ref<CraftingService | null>(null);

// Track seasonal quests
const seasonalQuests = ref([
  { id: 'SAMHAIN', completed: false },
  { id: 'WINTERS_DEPTH', completed: false },
  { id: 'IMBOLC', completed: false },
  { id: 'BELTANE', completed: false },
  { id: 'LUGHNASADH', completed: false }
]);

// Initialize services after component is mounted
onMounted(() => {
  // Make sure the CraftingService is initialized correctly
  try {
    craftingService.value = new CraftingService();
    console.log('CraftingService initialized successfully');
  } catch (error) {
    console.error('Error initializing CraftingService:', error);
  }
});

// Game state
const currentLandscape = computed<LandscapeCard | null>(() => {
  return gameStore.currentLandscape;
});

const currentCharacter = computed(() => {
  if (!playerStore.characterId) return null;
  return cardStore.characters.find(char => char.id === playerStore.characterId);
});

// Computed properties
const currentChallenge = computed(() => {
  if (!gameStore.currentChallenge) return null;
  return cardStore.getChallengeById(gameStore.currentChallenge);
});

const nextLandscape = computed(() => {
  const cardStore = useCardStore();
  // Get the next landscape index
  const nextIndex = gameStore.journeyProgress + 1;
  if (nextIndex < gameStore.journeyPath.length) {
    const nextLandscapeId = gameStore.journeyPath[nextIndex];
    return cardStore.getLandscapeById(nextLandscapeId);
  }
  return null;
});

// State for challenge resolution

// Companion selection for ANIMAL_COMPANION phase

const selectCompanion = (companionId: string) => {
  selectedCompanion.value = companionId;
};

const clearSelectedCompanion = () => {
  selectedCompanion.value = null;
};

// Check if current location is a healing location
const isHealingLocation = computed(() => {
  if (!currentLandscape.value) return false;
  return ['Sacred Oak Grove', 'Druid\'s Sanctuary', 'Moonlit Loch'].includes(currentLandscape.value.name);
});

// Crafting computed properties
const craftableItems = computed(() => {
  if (!playerStore.resources.length) return [];
  
  // Get list of craftable items based on player's resources
  const craftableItemIds = playerStore.getCraftableItems();
  
  // Get full item objects for display
  return craftableItemIds
    .map(id => cardStore.getCraftedItemById(id))
    .filter(item => item !== undefined);
});

const currentLandscapeCraftingBonus = computed(() => {
  if (!currentLandscape.value) return null;
  
  // Check if landscape has crafting bonuses
  const landscape = currentLandscape.value;
  
  // Special crafting locations from game rules
  if (landscape.name === 'Iron Forge Dell') return 1;
  if (landscape.name === 'Sacred Oak Grove') return 1;
  if (landscape.name === 'Druid\'s Sanctuary') return 1;
  if (landscape.name === 'Moonlit Loch') return 1;
  
  return null;
});

// Game actions
const resolveChallenge = () => {
  if (!currentChallenge.value || !gameStore.currentChallenge) {
    gameStore.addToGameLog("No active challenge to resolve.", true);
    return;
  }
  
  console.log('Resolving challenge:', currentChallenge.value.name);
  
  // Calculate challenge difficulty including threat level
  const baseDifficulty = currentChallenge.value.difficulty || 5;
  const threatModifier = gameStore.threatTokens;
  const seasonModifier = 0; // TODO: Add seasonal modifiers
  const totalDifficulty = baseDifficulty + threatModifier + seasonModifier;
  
  // Calculate player's bonus
  let playerBonus = 0;
  
  // Add bonuses from character
  if (currentCharacter.value?.specialAbility) {
    // Apply specific character bonuses if applicable
    playerBonus += 1;
  }
  
  // Add bonuses from animal companions
  const animalBonus = playerStore.animalCompanions.length > 0 ? 1 : 0;
  playerBonus += animalBonus;
  
  // Add bonuses from crafted items
  const itemBonus = playerStore.craftedItems.length > 0 ? 1 : 0;
  playerBonus += itemBonus;

  // Helper function to format season names
  const formatSeason = (season: Season): string => {
    if (!season) return 'Unknown';
    
    // Convert enum value to readable format (e.g., SPRING to Spring)
    const seasonName = season.toString();
    return seasonName.charAt(0) + seasonName.slice(1).toLowerCase();
  };

  // Simulate rolling the 8-sided die
  const dieRoll = Math.floor(Math.random() * 8) + 1;
  const totalRoll = dieRoll + playerBonus;
  
  let success = false;
  let partialSuccess = false;
  let damage = 0;
  
  // Natural 8 always succeeds
  if (dieRoll === 8) {
    success = true;
    gameStore.addToGameLog("Natural 8! Automatic success regardless of modifiers.", true);
  } else {
    // Check for full success
    success = totalRoll >= totalDifficulty;
    
    // Check for partial success (exactly one point below difficulty)
    partialSuccess = !success && totalRoll === totalDifficulty - 1;
  }
  
  if (success) {
    // Handle success
    lastChallengeResult.value = {
      success: true,
      message: `You successfully resolved the challenge! Roll: ${dieRoll} + ${playerBonus} = ${totalRoll} vs difficulty ${totalDifficulty}`
    };
    
    gameStore.addToGameLog(`Success! You rolled ${dieRoll} + ${playerBonus} = ${totalRoll} vs difficulty ${totalDifficulty}.`, true);
    
    // Award experience
    playerStore.gainExperience(1);
    gameStore.addToGameLog("You gained 1 experience point!", true);
    
    // Award resources (2 for full success)
    if (currentLandscape.value && currentLandscape.value.availableResources && currentLandscape.value.availableResources.length > 0) {
      let resourcesAwarded = 0;
      while (resourcesAwarded < 2 && !playerStore.isResourceCapacityReached) {
        const randomIndex = Math.floor(Math.random() * currentLandscape.value.availableResources.length);
        const resourceId = currentLandscape.value.availableResources[randomIndex];
        
        // Verify that the resource exists in cardStore before adding it
        const resourceExists = cardStore.getResourceById(resourceId);
        if (!resourceExists) {
          console.error(`Resource with ID ${resourceId} not found in cardStore`);
          gameStore.addToGameLog(`You attempted to gather a resource, but it was unidentifiable.`, true);
          continue;
        }
        
        // Add resource to player inventory
        const addResult = playerStore.addResource(resourceId);
        
        if (addResult) {
          const resource = cardStore.getResourceById(resourceId);
          if (resource) {
            gameStore.addToGameLog(`You gathered ${resource.name}.`, true);
            resourcesAwarded++;
          }
        } else if (playerStore.isResourceCapacityReached) {
          gameStore.addToGameLog(`Your resource capacity is reached. You cannot gather more resources.`, true);
          break;
        }
      }
    }
    
    // Clear the current challenge
    gameStore.setCurrentChallenge(null);
  } else if (partialSuccess) {
    // Handle partial success
    lastChallengeResult.value = {
      success: false,
      partialSuccess: true,
      message: `You partially resolved the challenge. Roll: ${dieRoll} + ${playerBonus} = ${totalRoll} vs difficulty ${totalDifficulty}`
    };
    
    gameStore.addToGameLog(`Partial success! You rolled ${dieRoll} + ${playerBonus} = ${totalRoll}, just one point below difficulty ${totalDifficulty}.`, true);
    
    // Award experience (half for partial success)
    if (Math.random() < 0.5) {
      playerStore.gainExperience(1);
      gameStore.addToGameLog("You gained 1 experience point for your effort!", true);
    }
    
    // Award 1 resource for partial success
    if (currentLandscape.value && currentLandscape.value.availableResources && currentLandscape.value.availableResources.length > 0) {
      const randomIndex = Math.floor(Math.random() * currentLandscape.value.availableResources.length);
      const resourceId = currentLandscape.value.availableResources[randomIndex];
      
      // Verify that the resource exists in cardStore before adding it
      const resourceExists = cardStore.getResourceById(resourceId);
      if (!resourceExists) {
        console.error(`Resource with ID ${resourceId} not found in cardStore`);
        gameStore.addToGameLog(`You attempted to gather a resource, but it was unidentifiable.`, true);
      } else {
        const addResult = playerStore.addResource(resourceId);
        if (addResult) {
          const resource = cardStore.getResourceById(resourceId);
          if (resource) {
            gameStore.addToGameLog(`You gathered ${resource.name}.`, true);
          }
        }
      }
    }
    
    // Apply a minor setback based on challenge type
    if (currentChallenge.value) {
      const challengeType = currentChallenge.value.type;
      let setbackMessage = "";
      
      switch (challengeType) {
        case ChallengeType.STRENGTH:
        case ChallengeType.AGILITY:
          // Physical challenges
          damage = 1;
          playerStore.loseHealth(damage);
          setbackMessage = `You suffer a minor injury. You lost ${damage} health point.`;
          break;
        case ChallengeType.WISDOM:
          // Mental challenges
          gameStore.addThreatTokens(1);
          setbackMessage = "Your confidence wavers. You gained 1 Threat token.";
          break;
        case ChallengeType.DIPLOMACY:
          // Social challenges
          // Temporarily lose access to one random resource type
          if (currentLandscape.value && currentLandscape.value.availableResources && currentLandscape.value.availableResources.length > 0) {
            const randomIndex = Math.floor(Math.random() * currentLandscape.value.availableResources.length);
            const resourceId = currentLandscape.value.availableResources[randomIndex];
            const resource = cardStore.getResourceById(resourceId);
            if (resource) {
              gameStore.addTempEffect(`resource_block_${resourceId}`, "Resource Unavailable", `Cannot gather ${resource.name}`, 1, 1);
              setbackMessage = `The local community withholds ${resource.name} from you for now.`;
            }
          }
          break;
        case ChallengeType.SURVIVAL:
          // Survival/spiritual challenges
          // Animal companions become wary
          if (playerStore.animalCompanions.length > 0) {
            const companionId = playerStore.animalCompanions[0];
            // Mark companion as wary (will be implemented in Phase 4)
            setbackMessage = "Your animal companion becomes wary of this place.";
          } else {
            gameStore.addThreatTokens(1);
            setbackMessage = "The spiritual imbalance increases. You gained 1 Threat token.";
          }
          break;
        default:
          damage = 1;
          playerStore.loseHealth(damage);
          setbackMessage = `You encounter an unexpected setback. You lost ${damage} health point.`;
      }
      
      gameStore.addToGameLog(`Setback: ${setbackMessage}`, true);
    }
    
    // Clear the current challenge
    gameStore.setCurrentChallenge(null);
  } else {
    // Handle failure
    damage = 1; // Basic damage from failing challenge
    
    lastChallengeResult.value = {
      success: false,
      message: `You failed to resolve the challenge. Roll: ${dieRoll} + ${playerBonus} = ${totalRoll} vs difficulty ${totalDifficulty}`,
      damage
    };
    
    gameStore.addToGameLog(`Failure! You rolled ${dieRoll} + ${playerBonus} = ${totalRoll} vs difficulty ${totalDifficulty}.`, true);
    
    // Apply consequences - lose health
    playerStore.loseHealth(damage);
    gameStore.addToGameLog(`You lost ${damage} health point${damage > 1 ? 's' : ''}.`, true);
    
    // Check if player is still alive
    if (playerStore.health <= 0) {
      gameStore.addToGameLog("Your journey has come to an end...", true);
      endJourney();
      return;
    }
  }
  
  // Move to the Challenge Resolution phase
  gameStore.setPhase(GamePhase.CHALLENGE_RESOLUTION);
};

const avoidChallenge = () => {
  // It costs 1 health to avoid a challenge
  playerStore.loseHealth(1);
  gameStore.addToGameLog("You chose to avoid the challenge, losing 1 health in the process.", true);
  
  // Skip directly to Resource Management
  gameStore.setPhase(GamePhase.RESOURCE_MANAGEMENT);
};

const getChallengeDifficulty = () => {
  if (!currentLandscape.value) return 5;
  
  const baseDifficulty = currentLandscape.value.challenges?.[0]?.difficulty || 5;
  const threatModifier = Math.floor(gameStore.threatTokens / 3);
  
  // Calculate season modifier based on current season
  const seasonModifiers = {
    [Season.SAMHAIN]: 0,
    [Season.WINTERS_DEPTH]: -2,
    [Season.IMBOLC]: -1,
    [Season.BELTANE]: 1,
    [Season.LUGHNASADH]: 2
  };
  const seasonModifier = seasonModifiers[gameStore.currentSeason] || 0;
  
  return baseDifficulty + threatModifier + seasonModifier;
};

const getItemBonuses = () => {
  // Safely calculate item bonuses
  return playerStore.equippedItems?.reduce((total, item) => {
    return total + (item?.challengeBonus || 0);
  }, 0) || 0;
};

const getTotalBonus = () => {
  // Character ability modifier
  const characterBonus = playerStore.selectedCharacter?.abilityModifier || 0;
  
  // Item bonuses from equipped items
  const itemBonus = getItemBonuses();
  
  // Blessing tokens
  const blessingBonus = gameStore.blessingTokens;
  
  return characterBonus + itemBonus + blessingBonus;
};

const getSeasonModifier = () => {
  const seasonModifiers = {
    [Season.SAMHAIN]: 0,
    [Season.WINTERS_DEPTH]: -2,
    [Season.IMBOLC]: -1,
    [Season.BELTANE]: 1,
    [Season.LUGHNASADH]: 2
  };
  
  return seasonModifiers[gameStore.currentSeason] || 0;
};

const resolveChallengeLandscape = () => {
  try {
    // Roll the eight-sided die
    const diceRoll = Math.floor(Math.random() * 8) + 1;
    gameStore.addToGameLog(`You rolled a ${diceRoll} on a D8.`, true);
    
    const playerBonus = getTotalBonus();
    const totalRoll = diceRoll + playerBonus;
    const difficulty = getChallengeDifficulty();
    
    gameStore.addToGameLog(`You rolled a ${diceRoll} + ${playerBonus} bonus = ${totalRoll} total against difficulty ${difficulty}.`, true);
    
    // Natural 8 always succeeds
    const isNaturalSuccess = diceRoll === 8;
    const isSuccess = isNaturalSuccess || totalRoll >= difficulty;
    
    if (isNaturalSuccess) {
      gameStore.addToGameLog("A natural 8! Automatic success regardless of difficulty!", true);
    }
    
    // Create and store the challenge result
    lastChallengeResult.value = {
      success: isSuccess,
      message: isSuccess ? 
        "You successfully overcome the landscape challenge!" : 
        "You failed to overcome the landscape challenge...",
      damage: isSuccess ? 0 : Math.max(1, Math.floor((difficulty - totalRoll) / 2))
    };
    
    // Apply damage if failed
    if (!isSuccess) {
      playerStore.loseHealth(lastChallengeResult.value.damage);
      gameStore.addToGameLog(`You lost ${lastChallengeResult.value.damage} health from failing the challenge.`, true);
    }
    
    // Move to challenge resolution phase
    gameStore.setPhase(GamePhase.CHALLENGE_RESOLUTION);
  } catch (error) {
    console.error("Error in resolveChallengeLandscape:", error);
    gameStore.addToGameLog("An error occurred while resolving the challenge.", true, 'error');
  }
};

const avoidChallengeLandscape = () => {
  // Check if player has at least 2 resources
  const totalResources = playerStore.resources.length;
  if (totalResources < 2) {
    gameStore.addToGameLog("You need at least 2 resources to avoid this challenge!", true);
    return;
  }
  
  // Spend 2 random resources
  const spentResources = [];
  for (let i = 0; i < 2; i++) {
    if (playerStore.resources.length > 0) {
      const index = Math.floor(Math.random() * playerStore.resources.length);
      const resource = playerStore.resources.splice(index, 1)[0];
      spentResources.push(resource);
    }
  }
  
  // Log the avoidance
  const resourceNames = spentResources.map(r => r.name || r.id).join(" and ");
  gameStore.addToGameLog(`You spent ${resourceNames} to avoid the challenge.`, true);
  
  // Advance to resource management
  gameStore.setPhase(GamePhase.RESOURCE_MANAGEMENT);
};

const handleThreatCheck = () => {
  // Log the threat level evaluation
  gameStore.addToGameLog(`Threat level assessed at ${gameStore.threatTokens} tokens.`, true);

  // Calculate challenge difficulty modifier
  const threatModifier = Math.floor(gameStore.threatTokens / 3);
  if (threatModifier > 0) {
    gameStore.addToGameLog(`Challenge difficulty increased by +${threatModifier} due to threat level.`, false);
  }

  // Check for random event trigger
  if (gameStore.threatTokens >= 5) {
    gameStore.addToGameLog(`The elevated threat level brings uncertainty. Be prepared for a random event.`, false);
  }

  // Check for otherworldly manifestation
  if (gameStore.threatTokens >= 10) {
    gameStore.addToGameLog(`The veil between worlds grows thin! An Otherworldly Manifestation is imminent!`, true);
  }

  // Advance to the next phase
  gameStore.advancePhase();
};

const gatherResources = () => {
  if (!currentLandscape.value) {
    gameStore.addToGameLog("Cannot gather resources - no landscape is available.", true, 'error');
    return;
  }
  
  if (playerStore.isResourceCapacityReached) {
    gameStore.addToGameLog(`Your resource capacity (${playerStore.resourceCapacity}) is full. You must discard resources before gathering more.`, true, 'resource');
    return;
  }
  
  // Determine the number of resources the player can gather
  let resourcesToGather = 1;
  
  // Add seasonal bonuses
  if (gameStore.currentSeason === Season.LUGHNASADH) {
    resourcesToGather += 1; // Lughnasadh gives +1 resource
    gameStore.addToGameLog("The harvest season of Lughnasadh allows you to gather an extra resource.");
  }
  
  // Gather random resources available from the landscape
  if (currentLandscape.value.availableResources && currentLandscape.value.availableResources.length > 0) {
    let successfulGathers = 0;
    
    for (let i = 0; i < resourcesToGather && !playerStore.isResourceCapacityReached; i++) {
      const randomIndex = Math.floor(Math.random() * currentLandscape.value.availableResources.length);
      const resourceId = currentLandscape.value.availableResources[randomIndex];
      
      // Get resource from cardStore
      const resource = cardStore.getResourceById(resourceId);
      
      if (!resource) {
        console.error(`Resource with ID ${resourceId} not found in cardStore`);
        gameStore.addToGameLog(`You attempted to gather a resource, but it was unidentifiable.`, true, 'error');
        continue;
      }
      
      // Add resource to player inventory
      const addResult = playerStore.addResource(resourceId);
      
      if (addResult) {
        gameStore.addToGameLog(`You gathered ${resource.name}.`, true, 'resource');
        successfulGathers++;
      } else if (playerStore.isResourceCapacityReached) {
        gameStore.addToGameLog(`Your resource capacity is reached. You cannot gather more resources.`, true, 'resource');
        break;
      }
    }
    
    if (successfulGathers === 0) {
      gameStore.addToGameLog(`You failed to gather any resources.`, true, 'resource');
    } else {
      gameStore.addToGameLog(`You successfully gathered ${successfulGathers} resource(s) from ${currentLandscape.value.name}.`, true, 'resource');
    }
  } else {
    gameStore.addToGameLog(`There are no resources to gather at ${currentLandscape.value.name}.`, true, 'resource');
  }
  
  // Advance to the next phase
  gameStore.advancePhase();
};

const getRequiredResourcesText = (resources: string[]): string => {
  if (!resources || !resources.length) return 'None';
  return resources.map(id => cardStore.getResourceById(id)?.name || id).join(', ');
};

const canCraftItem = (itemId: string) => {
  if (!craftingService.value) return false;
  return craftingService.value.canCraftItem(itemId);
};

const craftItem = (itemId: string) => {
  if (!craftingService.value) return;
  const result = craftingService.value.craftItem(itemId);
  if (result) {
    gameStore.addToGameLog(`Successfully crafted an item!`, true);
    // If we want to add a virtual die roll for crafting difficulty:
    const dieRoll = Math.floor(Math.random() * 8) + 1;
    gameStore.addToGameLog(`Rolled a ${dieRoll} for crafting check`, true);
    
    // Get crafted item details
    const item = cardStore.getCraftedItemById(itemId);
    if (item) {
      gameStore.addToGameLog(`You now have a ${item.name} (${item.ability})`, true);
      gameStore.addToGameLog(`Beware: ${item.drawback}`, true);
    }
  }
};

// Function to advance from Animal Companion phase
const advancePhase = () => {
  // For the Animal Companion phase, we need to handle the progression
  if (gameStore.currentPhase === GamePhase.ANIMAL_COMPANION) {
    // If we have a selected companion, clear it first
    if (selectedCompanion.value) {
      clearSelectedCompanion();
    }
    
    // Generate a new landscape if needed and advance the game phase
    const cardStore = useCardStore();
    const availableLandscapes = cardStore.landscapes.filter(l => 
      !gameStore.visitedLandscapes.includes(l.id)
    );
    
    if (availableLandscapes.length > 0) {
      // First, check if Wild Horse Plain is the only landscape left
      const wildHorsePlainOnly = availableLandscapes.length === 1 && 
                                availableLandscapes[0].id === 'wild_horse_plain';
      
      let newLandscape;
      
      if (wildHorsePlainOnly) {
        // If Wild Horse Plain is the only landscape left, use it as the final destination
        newLandscape = availableLandscapes[0];
        gameStore.addToGameLog('You can see the Wild Horse Plain in the distance - your final destination!', true);
      } else {
        // If Wild Horse Plain is not the only one left, make sure we don't select it yet
        const nonFinalLandscapes = availableLandscapes.filter(l => l.id !== 'wild_horse_plain');
        
        if (nonFinalLandscapes.length > 0) {
          // Pick a random landscape from the available ones (excluding Wild Horse Plain)
          const randomIndex = Math.floor(Math.random() * nonFinalLandscapes.length);
          newLandscape = nonFinalLandscapes[randomIndex];
        } else {
          // If all other landscapes have been visited, now use Wild Horse Plain
          newLandscape = availableLandscapes[0]; // This must be Wild Horse Plain
          gameStore.addToGameLog('After visiting all the other lands, you finally approach the Wild Horse Plain!', true);
        }
      }
      
      // Update the current landscape
      gameStore.setCurrentLandscape(newLandscape.id);
      // Add to visited landscapes
      gameStore.addVisitedLandscape(newLandscape.id);
      
      // If this is Wild Horse Plain and we've visited it, mark the journey as complete
      if (newLandscape.id === 'wild_horse_plain') {
        gameStore.addToGameLog('You have reached the Wild Horse Plain, completing your journey!', true);
        gameStore.victoryConditions.journeyCompleted = true;
        gameStore.checkVictoryConditions();
      }
    } else {
      // This should not happen, but just in case
      gameStore.addToGameLog('You have visited all landscapes, including the Wild Horse Plain.', true);
      gameStore.completeJourney(true);
    }
  }
  
  // Advance to the next phase
  gameStore.advancePhase();
};

// Function to start a new turn by setting the current landscape to the next one
// and resetting the phase to SEASONAL_ASSESSMENT
const startNewTurn = () => {
  if (nextLandscape.value) {
    // Update current landscape to the next one
    gameStore.currentLandscapeId = gameStore.journeyPath[gameStore.journeyProgress + 1];
    // Advance journey progress
    gameStore.journeyProgress++;
    // Add to game log
    gameStore.addToGameLog(`Arrived at ${nextLandscape.value.name}.`);
    // Reset phase to start the turn cycle - use direct assignment instead of setPhase
    gameStore.currentPhase = GamePhase.SEASONAL_ASSESSMENT;
  } else {
    // No more landscapes, handle journey completion
    gameStore.addToGameLog("You've reached the end of your journey!");
    gameStore.journeyComplete = true;
    gameStore.advancePhase();
  }
};

// End the journey and return to home screen
const endJourney = () => {
  console.log('Ending journey...');
  playerStore.resetPlayer();
  gameStore.resetGame();
  router.push('/');
};

// Helper functions
const formatPhase = (phase: GamePhase): string => {
  if (!phase) return 'Unknown';
  
  const phaseName = phase.toString().replace(/_/g, ' ').toLowerCase();
  return phaseName.split(' ').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
  ).join(' ');
};

const formatSeason = (season: Season): string => {
  if (!season) return 'Unknown';
  
  // Convert enum value to readable format (e.g., SPRING to Spring)
  const seasonName = season.toString();
  return seasonName.charAt(0) + seasonName.slice(1).toLowerCase();
};

const getCardResourceName = (resourceId: string): string => {
  const resource = cardStore.getResourceById(resourceId);
  return resource ? resource.name : 'Unknown Resource';
};

const getResourceDescription = (resourceId: string): string => {
  const resource = cardStore.getResourceById(resourceId);
  return resource ? resource.description : 'A valuable resource that can be used for crafting and survival.';
};

const getCraftedItemName = (itemId: string): string => {
  const item = cardStore.getCraftedItemById(itemId);
  return item ? item.name : 'Unknown Item';
};

const getCraftedItemDescription = (itemId: string): string => {
  const item = cardStore.getCraftedItemById(itemId);
  return item ? item.description : 'A crafted item.';
};

const triggerRandomEvent = () => {
  // Use the gameStore's random event trigger
  gameStore.triggerRandomEvent();
  gameStore.addToGameLog("A random event has been drawn due to the high threat level.", true);
};

const triggerOtherworldlyManifestation = () => {
  // Use the gameStore's otherworldly manifestation trigger
  gameStore.triggerOtherworldlyManifestation();
  gameStore.addToGameLog("The veil between worlds grows thin! An Otherworldly Manifestation is imminent!", true);
};

const advanceToChallenge = () => {
  gameStore.advancePhase();
};

const advanceToNextPhase = () => {
  gameStore.advancePhase();
};
</script>

<style lang="scss" scoped>
.game-board {
  height: 100%;
  display: flex;
  flex-direction: column;
  background-color: #f8f4e9;
}

.game-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 0.25rem;
  display: flex;
  flex-direction: column;
}

.phase-content {
  margin-bottom: 0.25rem;
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.game-log {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}
</style>
</file>

</files>
